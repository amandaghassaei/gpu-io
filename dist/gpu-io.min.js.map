{"version":3,"file":"gpu-io.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,GACjB,CATD,CASGK,MAAM,I,gCCLA,SAAWJ,GAAW,aAK9B,SAASK,EAASC,GACd,OAAQC,OAAOC,MAAMF,IAA2B,iBAAVA,CAC1C,CAIA,SAASG,EAAeH,GACpB,OAAOD,EAASC,IAAUC,OAAOG,SAASJ,EAC9C,CAIA,SAASK,EAAUL,GACf,OAAOG,EAAeH,IAAWA,EAAQ,GAAM,CACnD,CAIA,SAASM,EAAiBN,GACtB,OAAOD,EAASC,IAAUA,EAAQ,CACtC,CAIA,SAASO,EAAkBP,GACvB,OAAOK,EAAUL,IAAUA,EAAQ,CACvC,CAIA,SAASQ,EAAiBR,GACtB,OAAOD,EAASC,IAAUA,EAAQ,CACtC,CAIA,SAASS,EAAkBT,GACvB,OAAOK,EAAUL,IAAUA,EAAQ,CACvC,CAIA,SAASU,EAAoBV,GACzB,OAAOD,EAASC,IAAUA,GAAS,CACvC,CAIA,SAASW,EAAqBX,GAC1B,OAAOK,EAAUL,IAAUA,GAAS,CACxC,CAIA,SAASY,EAAoBZ,GACzB,OAAOD,EAASC,IAAUA,GAAS,CACvC,CAIA,SAASa,EAAqBb,GAC1B,OAAOK,EAAUL,IAAUA,GAAS,CACxC,CAIA,SAASc,EAAgBd,EAAOe,EAAKC,GACjC,OAAOjB,EAASC,IAAUA,GAASe,GAAOf,GAASgB,CACvD,CAIA,SAASC,EAAiBjB,EAAOe,EAAKC,GAClC,OAAOX,EAAUL,IAAUA,GAASe,GAAOf,GAASgB,CACxD,CAIA,SAASE,EAASlB,GACd,MAAwB,iBAAVA,CAClB,CAIA,SAASmB,EAAanB,GAClB,OAAOoB,YAAYC,OAAOrB,MAAYA,aAAiBsB,SAC3D,CAIA,SAASC,EAAQvB,GACb,OAAOwB,MAAMD,QAAQvB,IAAUmB,EAAanB,EAChD,CAIA,SAASyB,EAASzB,GACd,QAAwB,iBAAVA,GAAuBuB,EAAQvB,IAAoB,OAAVA,GAAoBA,aAAiBoB,aAAkBpB,aAAiBsB,SACnI,CAIA,SAASI,EAAU1B,GACf,MAAwB,kBAAVA,CAClB,CAEAN,EAAQ6B,QAAUA,EAClB7B,EAAQgC,UAAYA,EACpBhC,EAAQS,eAAiBA,EACzBT,EAAQW,UAAYA,EACpBX,EAAQuB,iBAAmBA,EAC3BvB,EAAQe,kBAAoBA,EAC5Bf,EAAQc,iBAAmBA,EAC3Bd,EAAQiB,qBAAuBA,EAC/BjB,EAAQgB,oBAAsBA,EAC9BhB,EAAQmB,qBAAuBA,EAC/BnB,EAAQkB,oBAAsBA,EAC9BlB,EAAQK,SAAWA,EACnBL,EAAQoB,gBAAkBA,EAC1BpB,EAAQ+B,SAAWA,EACnB/B,EAAQa,kBAAoBA,EAC5Bb,EAAQY,iBAAmBA,EAC3BZ,EAAQwB,SAAWA,EACnBxB,EAAQyB,aAAeA,EAEvBQ,OAAOC,eAAelC,EAAS,aAAc,CAAEM,OAAO,GAEtD,CAvI+DP,CAAQC,E,2BCsBxE,SAASmC,EAAQC,GACf,IAAIC,GAAK,EACJC,IAAcA,EAfrB,WAGE,IADA,IAAIC,EAAW,IAAIC,WAAW,KACrBC,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAE5B,IADA,IAAIJ,EAAII,EACCC,EAAI,EAAGA,EAAI,EAAGA,IACrBL,EAAQ,EAAJA,EAAQ,WAAaA,IAAM,EAAIA,IAAM,EAE3CE,EAASE,GAAKJ,CAChB,CACA,OAAOE,CACT,CAIoCI,IAClC,IAAK,IAAIF,EAAI,EAAGA,EAAIL,EAAIQ,OAAQH,IAC9BJ,EAAIC,EAA4B,KAAdD,EAAID,EAAIK,KAAcJ,IAAM,EAEhD,OAAY,EAALA,CACT,CA5BAJ,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQ6C,cAgDR,SAAuBC,EAAMC,GAG3B,IAAIC,EAAcF,EAAKG,MAAM,EAAG,IAChC,OAAO,IAAIC,SAAQ,SAAUC,EAASC,GACpC,IAAIC,EAAa,IAAIC,WACrBD,EAAWE,OAAS,WAClB,IAAIC,EAAY,IAAIC,WAAWJ,EAAWK,QACtCC,EAAOb,EAAKG,MAAM,IAClBW,EAAeC,EAAiBL,EAAWT,EAAKD,EAAKgB,MACzDX,EAAQ,IAAIY,KAAK,CAACH,EAAcD,GAAO,CAAEG,KAAMhB,EAAKgB,OACtD,EACAT,EAAWW,kBAAkBhB,EAC/B,GACF,EA7DAhD,EAAQiE,iBA+DR,SAA0BC,EAAanB,GACrC,IAAIoB,EAAeD,EAAYE,MAAM,KACjCC,EAASF,EAAa,GACtBG,EAAOH,EAAa,GACpBL,OAAO,EACPS,OAAe,EACfC,GAAgB,EACpB,IAA6B,IAAzBH,EAAOI,QAAQC,GAAa,CAC9BZ,EAAOY,EACP,IAAIC,EA2BR,SAAoCC,GAClC,IAAIC,EAAWD,EAAKH,QAAQK,IACV,IAAdD,IACFA,EAAWD,EAAKH,QAAQM,KAER,IAAdF,IACFA,EAAWD,EAAKH,QAAQO,IAG1B,OAAOH,CACT,CArCmBI,CAA2BX,GAEtCK,GAAY,GACdJ,EAAgD,EAAjCW,KAAKC,MAAMR,EAAW,IAAM,GAC3CH,GAAgB,GAEhBD,EAAe,EAEnB,EAC8B,IAA1BF,EAAOI,QAAQW,KACjBtB,EAAOsB,EACPb,EAAe,IAQjB,IAJA,IAAIc,EAAef,EAAKgB,UAAU,EAAGf,GACjCgB,EAAajB,EAAKgB,UAAUf,GAC5BiB,EAAcC,KAAKJ,GACnB7B,EAAY,IAAIC,WAAW+B,EAAY5C,QAClC8C,EAAI,EAAGA,EAAIlC,EAAUZ,OAAQ8C,IACpClC,EAAUkC,GAAKF,EAAYG,WAAWD,GAExC,IAAIE,EAAa/B,EAAiBL,EAAWT,EAAKe,EAAMU,GACpDqB,EAAeC,KAAKC,OAAOC,aAAaC,MAAMF,OA7FpD,SAA4BG,GAAO,GAAIpE,MAAMD,QAAQqE,GAAM,CAAE,IAAK,IAAIR,EAAI,EAAGS,EAAOrE,MAAMoE,EAAItD,QAAS8C,EAAIQ,EAAItD,OAAQ8C,IAAOS,EAAKT,GAAKQ,EAAIR,GAAM,OAAOS,CAAM,CAAS,OAAOrE,MAAMsE,KAAKF,EAAQ,CA6FtIG,CAAmBT,KAC7E,MAAO,CAACvB,EAAQ,IAAKwB,EAAcN,GAAYe,KAAK,GACtD,EAvEA,IAAIhE,OAAe,EAEfoC,EAAM,YACNU,EAAO,aASPN,EAAoB,WACpBC,EAAoB,WACpBC,EAAoB,WAEpBuB,EAAK,IAAIZ,WAAW,GACpBa,EAAK,IAAIb,WAAW,GACpBc,EAAK,IAAId,WAAW,GACpBe,EAAK,IAAIf,WAAW,GA6ExB,SAAS9B,EAAiBL,EAAWT,EAAKsB,EAAQG,GAChD,GAAIH,IAAWe,EAMb,OALA5B,EAAU,IAAM,EAChBA,EAAU,IAAMT,GAAO,EACvBS,EAAU,IAAY,IAANT,EAChBS,EAAU,IAAMT,GAAO,EACvBS,EAAU,IAAY,IAANT,EACTS,EAET,GAAIa,IAAWK,EAAK,CAClB,IAAIiC,EAAY,IAAIlD,WAAW,IAK/BV,GAAO,QACP4D,EAAU,GAAKJ,EACfI,EAAU,GAAKH,EACfG,EAAU,GAAKF,EACfE,EAAU,GAAKD,EACfC,EAAU,GAAK5D,IAAQ,GACvB4D,EAAU,GAAK5D,IAAQ,GACvB4D,EAAU,GAAK5D,IAAQ,EACvB4D,EAAU,GAAW,IAAN5D,EACf4D,EAAU,GAAKA,EAAU,GACzBA,EAAU,GAAKA,EAAU,GACzBA,EAAU,IAAMA,EAAU,GAC1BA,EAAU,IAAMA,EAAU,GAC1BA,EAAU,IAAM,EAEhB,IAAIC,EAAMzE,EAAQwE,GAEdE,EAAW,IAAIpD,WAAW,GAM9B,GALAoD,EAAS,GAAKD,IAAQ,GACtBC,EAAS,GAAKD,IAAQ,GACtBC,EAAS,GAAKD,IAAQ,EACtBC,EAAS,GAAW,IAAND,EAEVpC,EAAe,CACjB,IAAIsC,EAlDV,SAA2BlC,GAIzB,IAHA,IAGSc,EAHId,EAAKhC,OAAS,EAGN8C,GAAK,EAAGA,IAC3B,GAAoB,IAAhBd,EAAKc,EAAI,IAAYd,EAAKc,EAAI,KAAOa,GAAM3B,EAAKc,EAAI,KAAOc,GAAM5B,EAAKc,EAAI,KAAOe,GAAM7B,EAAKc,KAAOgB,EACrG,OAAOhB,EAAI,CAGjB,CAyC0BqB,CAAkBvD,GAGtC,OAFAA,EAAUwD,IAAIL,EAAWG,GACzBtD,EAAUwD,IAAIH,EAAUC,EAAgB,IACjCtD,CACT,CAOE,IAAIyD,EAAc,IAAIxD,WAAW,GACjCwD,EAAY,GAAK,EACjBA,EAAY,GAAK,EACjBA,EAAY,GAAK,EACjBA,EAAY,GAAK,EAEjB,IAAIC,EAAc,IAAIzD,WAAW,IAKjC,OAJAyD,EAAYF,IAAIxD,EAAW,GAC3B0D,EAAYF,IAAIC,EAAa,IAC7BC,EAAYF,IAAIL,EAAW,IAC3BO,EAAYF,IAAIH,EAAU,IACnBK,CAEX,CACF,C,sBChMA,UAAwD,EAAO,GAAE,EAA8F,WAAW,aAAa,SAASC,EAAEC,EAAED,GAAG,YAAM,IAAoBA,EAAEA,EAAE,CAACE,SAAQ,GAAI,iBAAiBF,IAAIG,QAAQC,KAAK,sDAAsDJ,EAAE,CAACE,SAASF,IAAIA,EAAEE,SAAS,6EAA6EG,KAAKJ,EAAEtD,MAAM,IAAIC,KAAK,CAAC,SAASqD,GAAG,CAACtD,KAAKsD,EAAEtD,OAAOsD,CAAC,CAAC,SAAS/E,EAAE+E,EAAED,EAAE9E,GAAG,IAAIoF,EAAE,IAAIC,eAAeD,EAAEE,KAAK,MAAMP,GAAGK,EAAEG,aAAa,OAAOH,EAAElE,OAAO,WAAWsE,EAAEJ,EAAEK,SAASX,EAAE9E,EAAE,EAAEoF,EAAEM,QAAQ,WAAWT,QAAQU,MAAM,0BAA0B,EAAEP,EAAEQ,MAAM,CAAC,SAASR,EAAEL,GAAG,IAAID,EAAE,IAAIO,eAAeP,EAAEQ,KAAK,OAAOP,GAAE,GAAI,IAAID,EAAEc,MAAgB,CAAT,MAAMb,GAAG,CAAC,OAAO,KAAKD,EAAEe,QAAQ,KAAKf,EAAEe,MAAM,CAAC,SAASC,EAAEf,GAAG,IAAIA,EAAEgB,cAAc,IAAIC,WAAW,SAAqJ,CAA3I,MAAMhG,GAAG,IAAI8E,EAAEmB,SAASC,YAAY,eAAepB,EAAEqB,eAAe,SAAQ,GAAG,EAAGC,OAAO,EAAE,EAAE,EAAE,GAAG,IAAG,GAAG,GAAG,GAAG,EAAG,EAAE,MAAMrB,EAAEgB,cAAcjB,EAAE,CAAC,CAAC,IAAIuB,EAAE,iBAAiBD,QAAQA,OAAOA,SAASA,OAAOA,OAAO,iBAAiBrI,MAAMA,KAAKA,OAAOA,KAAKA,KAAK,iBAAiB,EAAAyH,GAAQ,EAAAA,EAAOc,SAAS,EAAAd,EAAO,EAAAA,OAAO,EAAOT,EAAEsB,EAAEE,WAAW,YAAYpB,KAAKoB,UAAUC,YAAY,cAAcrB,KAAKoB,UAAUC,aAAa,SAASrB,KAAKoB,UAAUC,WAAWhB,EAAEa,EAAEI,SAAS,iBAAiBL,QAAQA,SAASC,EAAE,WAAW,EAAE,aAAaK,kBAAkBC,YAAY5B,EAAE,SAASD,EAAEU,EAAEoB,GAAG,IAAIvD,EAAEgD,EAAEQ,KAAKR,EAAES,UAAUC,EAAEd,SAASe,cAAc,KAAKxB,EAAEA,GAAGV,EAAEmC,MAAM,WAAWF,EAAEG,SAAS1B,EAAEuB,EAAEI,IAAI,WAAW,iBAAiBrC,GAAGiC,EAAEK,KAAKtC,EAAEiC,EAAEM,SAASC,SAASD,OAAOvB,EAAEiB,GAAG3B,EAAE2B,EAAEK,MAAMpH,EAAE8E,EAAEU,EAAEoB,GAAGd,EAAEiB,EAAEA,EAAEQ,OAAO,YAAYR,EAAEK,KAAK/D,EAAEmE,gBAAgB1C,GAAG2C,YAAW,WAAWpE,EAAEqE,gBAAgBX,EAAEK,KAAK,GAAE,KAAKK,YAAW,WAAW3B,EAAEiB,EAAE,GAAE,GAAG,EAAE,qBAAqBR,UAAU,SAASF,EAAEb,EAAEoB,GAAG,GAAGpB,EAAEA,GAAGa,EAAEY,MAAM,WAAW,iBAAiBZ,EAAEE,UAAUoB,iBAAiB7C,EAAEuB,EAAEO,GAAGpB,QAAQ,GAAGJ,EAAEiB,GAAGrG,EAAEqG,EAAEb,EAAEoB,OAAO,CAAC,IAAIvD,EAAE4C,SAASe,cAAc,KAAK3D,EAAE+D,KAAKf,EAAEhD,EAAEkE,OAAO,SAASE,YAAW,WAAW3B,EAAEzC,EAAE,GAAE,CAAC,EAAE,SAASyB,EAAEM,EAAEU,EAAEN,GAAG,IAAGA,EAAEA,GAAGF,KAAK,GAAG,aAAcE,EAAES,SAAS2B,MAAMpC,EAAES,SAAShE,KAAK4F,UAAU,kBAAkB,iBAAiB/C,EAAE,OAAO9E,EAAE8E,EAAEM,EAAEU,GAAG,IAAIc,EAAE,6BAA6B9B,EAAErD,KAAK4B,EAAE,eAAe8B,KAAKkB,EAAEyB,cAAczB,EAAE0B,OAAOhB,EAAE,eAAe5B,KAAKoB,UAAUC,WAAW,IAAIO,GAAGH,GAAGvD,GAAG0B,IAAI,oBAAoB9D,WAAW,CAAC,IAAIZ,EAAE,IAAIY,WAAWZ,EAAE2H,UAAU,WAAW,IAAIjD,EAAE1E,EAAEgB,OAAO0D,EAAEgC,EAAEhC,EAAEA,EAAEkD,QAAQ,eAAe,yBAAyBzC,EAAEA,EAAE8B,SAASF,KAAKrC,EAAEuC,SAASvC,EAAES,EAAE,IAAI,EAAEnF,EAAE6H,cAAcpD,EAAE,KAAK,CAAC,IAAIqD,EAAE9B,EAAEQ,KAAKR,EAAES,UAAUsB,EAAED,EAAEX,gBAAgB1C,GAAGU,EAAEA,EAAE8B,SAASc,EAAEd,SAASF,KAAKgB,EAAE5C,EAAE,KAAKiC,YAAW,WAAWU,EAAET,gBAAgBU,EAAE,GAAE,IAAI,CAAC,GAAG/B,EAAEI,OAAOjB,EAAEiB,OAAOjB,EAA+B5H,EAAOD,QAAQ6H,CAAE,OAA5kF,0D,8iBCCnE,aACA,SACA,SACA,OACA,aA4CA,SACA,SAOA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SAIA,SACA,SACA,SAGA,aA8LC,WACC6C,G,MAhKO,KAAAC,aAAc,EAcd,KAAAC,uBAAyD,CAAC,EAW1D,KAAAC,0BAA4E,CAAC,EAC7E,KAAAC,yBAAqD,CAAC,EAMrD,KAAAC,YAAsC,CAAC,EAIxC,KAAAC,YAAiC,EAOxB,KAAAC,cAIb,CAAC,EAOY,KAAAC,kBAIb,CAAC,EAOI,KAAAC,iBAAc,MAIrB,EAAAC,sBAAuB,CACvBC,IAAK,EAAAC,2BACLC,gBAAiB,CAAC,GAEnB,EAAC,EAAAC,sBAAuB,CACvBH,IAAK,EAAAI,6BACLF,gBAAiB,CAAC,GAEnB,EAAC,EAAAG,2BAA4B,CAC5BL,IAAK,EAAAM,kCACLJ,gBAAiB,CAAC,GAEnB,EAAC,EAAAK,iCAAkC,CAClCP,IAAK,EAAAQ,wCACLN,gBAAiB,CAAC,GAEnB,EAAC,EAAAO,0BAA2B,CAC3BT,IAAK,EAAAU,iCACLR,gBAAiB,CAAC,GAEnB,EAAC,EAAAS,yBAA0B,CAC1BX,IAAK,EAAAY,gCACLV,gBAAiB,CAAC,G,GAOpB,KAAAW,gBAAiB,EAOT,KAAAC,UAAY,EAyEnB,IAEMC,EAAOnK,OAAOmK,KAAK1B,IACzB,IAAA2B,gBAAeD,EAHG,CAAC,SAAU,UAAW,YAAa,oBAAqB,cAAe,eAAgB,iBAAkB,aAAc,iBAAkB,iBAG3H,wBAChC,IAAAE,mBAAkBF,EAHG,CAAC,UAGgB,4BAERG,IAA1B7B,EAAOwB,iBAA8BM,KAAKN,eAAiBxB,EAAOwB,gBAGtE,IAAM9L,EAAOoM,KACbA,KAAKC,eAAiB,SAACC,GAClBtM,EAAKuK,cAGTvK,EAAKuK,aAAc,EACnBD,EAAOiC,cAAgBjC,EAAOiC,cAAcD,IAAW,IAAAE,wBAAuBF,GAC/E,EAEQ,IAAAG,EAAWnC,EAAM,OACrBoC,EAAKpC,EAAOqC,QAGhB,IAAKD,EAAI,CAGP,IAQME,EATP,GAAItC,EAAOuC,WACJD,EAAMH,EAAOK,WAAWxC,EAAOuC,UAAWvC,EAAOyC,oBAItDL,EAAKE,EAFL1F,QAAQC,KAAK,6DAAsDmD,EAAOuC,UAAS,MAKrF,IAAKH,GACEE,EAAMH,EAAOK,WAAW,EAAAE,OAAQ1C,EAAOyC,oBACzCN,EAAOK,WAAW,EAAAG,OAAQ3C,EAAOyC,oBACjCN,EAAOK,WAAW,EAAAI,oBAAqB5C,EAAOyC,oBAC9CN,EAAOK,WAAW,EAAAK,mBAAoB7C,EAAOyC,sBAEhDL,EAAKE,GAGP,IAAKF,EAEJ,YADAN,KAAKC,eAAe,sC,CAItBD,KAAKgB,UAAW,IAAAA,UAASV,GACrBN,KAAKgB,SACJhB,KAAKN,gBAAgB5E,QAAQmG,IAAI,4BAEjCjB,KAAKN,gBAAgB5E,QAAQmG,IAAI,4BAEtCjB,KAAKM,GAAKA,EAGV,IAAIY,EAAchD,EAAOgD,cAAgBlB,KAAKgB,SAAW,EAAAG,MAAQ,EAAAC,QAC5DpB,KAAKgB,UAAYE,IAAgB,EAAAC,QACrCrG,QAAQC,KAAK,0EACbmG,EAAc,EAAAE,OAEfpB,KAAKkB,YAAcA,EAGnBlB,KAAKqB,aAAenD,EAAOmD,cAAgB,EAAAC,iBAC3CtB,KAAKuB,eAAiBrD,EAAOqD,gBAAkB,EAAAD,iBAI/ChB,EAAGkB,QAAQlB,EAAGmB,YAGdnB,EAAGoB,YAAYpB,EAAGqB,iBAAkB,GAGhC3B,KAAKgB,UAAWV,EAA8BsB,gBAAgB,OAErD,IAAAC,cAAa7B,KAAM,EAAA8B,yBAAyB,GACpDC,mBAAmB,MAExBzB,EAAG0B,WAAW1B,EAAG2B,aAAc,WAELlC,IAAtB7B,EAAOgE,aACVlC,KAAKkC,WAAahE,EAAOgE,YAI1BlC,KAAKmC,OAAO,CAAC9B,EAAO+B,YAAa/B,EAAOgC,eAEpCrC,KAAKN,gBAER5E,QAAQmG,IAAI,UAAGjB,KAAKM,GAAGgC,aAAatC,KAAKM,GAAGiC,yBAAwB,kBAEtE,CAy1DD,OAh/DS,EAAAC,sBAAP,SACAC,EACAvE,GASA,IAAMwE,EAAW,IAAIC,EAAY,EAAD,GAE9BpB,eAAgBkB,EAASG,aAAaC,UACtCxB,aAAcoB,EAASG,aAAaC,WACjC3E,GAAM,CACTmC,OAAQoC,EAASK,WACjBvC,QAASkC,EAAS/B,gBAMpB,OADAgC,EAASK,eAAiBN,EACnBC,CACR,EAiIA,sBAAI,qBAAM,C,IAAV,WACC,OAAO1C,KAAKM,GAAGD,MAChB,E,gCAOA,YAAA2C,wBAAA,SAAwB1L,GACf,IAAAoH,EAAsBsB,KAAI,kBAC5BiD,GAAM,IAAAC,oBAAmB5L,EAAM0I,KAAKkB,aAI1C,YAH+BnB,IAA3BrB,EAAkBuE,KACrBvE,EAAkBuE,IAAO,IAAAE,iBAAgBnD,KAAM,CAAE1I,KAAI,EAAExD,MAAO,CAAC,EAAG,EAAG,EAAG,MAElE4K,EAAkBuE,EAC1B,EAMA,YAAAG,oBAAA,SAAoB9L,GACX,IAAAmH,EAAkBuB,KAAI,cACxBiD,GAAM,IAAAC,oBAAmB5L,EAAM0I,KAAKkB,aAI1C,YAH2BnB,IAAvBtB,EAAcwE,KACjBxE,EAAcwE,IAAO,IAAAI,aAAYrD,KAAM,CAAE1I,KAAI,KAEvCmH,EAAcwE,EACtB,EAgBQ,YAAAK,kBAAR,SACClL,GAEM,MAAmC4H,KAAjCC,EAAc,iBAAEK,EAAE,KAAU,WAErBA,EAA8BsB,gBAAgB,OAEhD,IAAAC,cAAa7B,KAAM,EAAA8B,yBAAyB,GACpDC,mBAAmB,MAExB,IAAMwB,EAASjD,EAAGkD,eAClB,GAAKD,EAOL,OAHAjD,EAAG0B,WAAW1B,EAAG2B,aAAcsB,GAE/BjD,EAAGmD,WAAWnD,EAAG2B,aAAc7J,EAAMkI,EAAGoD,aACjCH,EANNtD,EAAe,gCAOjB,EAKA,YAAA0D,wBAAA,WACC,QAAkC5D,IAA9BC,KAAK4D,qBAAoC,CAC5C,IAAMC,EAAkB,IAAIC,aAAa,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,IACpE9D,KAAK4D,qBAAuB5D,KAAKsD,kBAAkBO,E,CAEpD,OAAO7D,KAAK4D,oBACb,EAKQ,YAAAG,4BAAR,WACC,QAAsChE,IAAlCC,KAAKgE,yBAAwC,CAChD,IAAMC,EAAoB,IAAIH,aAAa,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,IAC9E9D,KAAKgE,yBAA2BhE,KAAKsD,kBAAkBW,E,CAExD,OAAOjE,KAAKgE,wBACb,EAKQ,YAAAE,0BAAR,SAAkCC,GACzB,IAAA/F,EAA2B4B,KAAI,uBACvC,GAA2CD,MAAvC3B,EAAuB+F,GAA2B,CAErD,IADA,IAAMC,EAAmB,CAAC,EAAG,GACpBlL,EAAI,EAAGA,EAAIiL,EAAajL,IAChCkL,EAAiBC,KAChB3L,KAAK4L,IAAI,EAAI5L,KAAK6L,GAAKrL,EAAIiL,GAC3BzL,KAAK8L,IAAI,EAAI9L,KAAK6L,GAAKrL,EAAIiL,IAI7BC,EAAiBC,KAChB3L,KAAK4L,IAAI,GACT5L,KAAK8L,IAAI,IAEV,IAAMC,EAAkB,IAAIX,aAAaM,GACnCb,EAASvD,KAAKsD,kBAAkBmB,GACtCrG,EAAuB+F,GAAeZ,C,CAEvC,OAAOnF,EAAuB+F,EAC/B,EAMA,YAAAO,eAAA,SAAeC,EAAoB7H,GAkBlC,IAjBA,IAAM8H,EAAaD,EAASE,OAASF,EAASvO,OAAS,CAACuO,EAASG,MAAOH,EAASI,QAE3EC,EAAQ,IAAI,EAAAC,SAASjF,KAAM,CAChClD,KAAMA,GAAQ,UAAG6H,EAAS7H,KAAI,UAC9B8H,WAAU,EACVtN,KAAMqN,EAASrN,KACf4N,cAAeP,EAASO,cACxBC,OAAQR,EAASQ,OACjBC,MAAOT,EAASS,MAChBC,MAAOV,EAASU,MAChBC,WAAYX,EAASW,WACrBpD,WAAYyC,EAASzC,aAIhBmB,EAAcrD,KAAKoD,oBAAoBuB,EAASrN,MAE7C4B,EAAI,EAAGA,EAAIyL,EAASW,WAAa,EAAGpM,IAC5C8L,EAAMO,uBAEP,IAASrM,EAAI,EAAGA,EAAIyL,EAASW,WAAYpM,IACxC8G,KAAKwF,KAAK,CACTC,QAASpC,EACTqC,MAAOf,EAASgB,gBAAgBzM,GAChC0M,OAAQZ,IAIV,IAAS9L,GAAK,EAAGA,EAAIyL,EAASkB,YAAa3M,IAC1C8L,EAAMO,uBAGP,OAAOP,CACR,EAOC,YAAAc,iBAAA,SACAhJ,EACAiJ,EACAC,EACAC,GAEM,MAOFjG,KANHC,EAAc,iBACdtB,EAAc,iBACd2B,EAAE,KACFY,EAAW,cACXG,EAAY,eACZE,EAAc,iBAET,EAA2B5C,EAAe7B,GAAxCiC,EAAe,kBAAEF,EAAG,MAE5B,GADiB,KAAbkH,IAAiBA,EAAW,iBACEhG,IAA9BhB,EAAgBgH,GAAyB,CAE5C,GAAY,KAARlH,EACH,MAAM,IAAIqH,MAAM,sCAA+BD,EAAW,qDAA6CnJ,EAAI,OAE5G,IAAMqJ,GAAkB,IAAAC,wBAAuBvH,EAAKqC,GAC9CmF,GAAS,IAAAC,eACdhG,EACAY,EACAG,EACAE,EACA4E,EACA7F,EAAGiG,cACHN,EACAhG,EACA+F,OACAjG,GACA,GAED,IAAKsG,EAEJ,YADApG,EAAe,6BAAsBnD,GAAI,OAAGiJ,EAAQ,2CAAmCE,EAAW,OAInGlH,EAAgBgH,GAAYM,C,CAE7B,OAAOtH,EAAgBgH,EACxB,EAMA,YAAA5D,OAAA,SAAOyC,GACE,IAAAvE,EAAWL,KAAI,OAChB8E,EAAiBF,EAAU,GAApBG,EAAUH,EAAU,GAClC,KAAK,IAAAvQ,mBAAkByQ,MAAW,IAAAzQ,mBAAkB0Q,GACnD,MAAK,IAAA1P,SAAQuP,GACF,IAAIsB,MAAM,0GAAmGpB,EAAK,aAAKC,IADlG,IAAImB,MAAM,qHAA8GM,KAAKC,UAAU7B,KAKxKvE,EAAOyE,MAAQA,EACfzE,EAAO0E,OAASA,EAEhB/E,KAAK0G,OAAS5B,EACd9E,KAAK2G,QAAU5B,CAChB,EAMQ,YAAA6B,WAAR,SACCC,EACAZ,EACAD,EACAc,EACApB,EACAE,GAEQ,IAAAtF,EAAON,KAAI,GAMb+G,EAAiC,GACvC,GAAIrB,EACH,GAAKA,EAAwBsB,MAC5BD,EAAc1C,KAAKqB,QACb,GAAIA,EAAMuB,cAAgB,EAAAhC,SAChC8B,EAAc1C,KAAMqB,EAAmBwB,mBAEvC,IAAK,IAAIhO,EAAI,EAAGA,EAAKwM,EAAuCtP,OAAQ8C,IAAK,CACxE,IAAM8N,EAAStB,EAAuCxM,GACtD6N,EAAc1C,KAAM2C,EAAmBE,aAAgBF,EAAmBE,aAAeF,E,CAK5F,IAAMvB,EAAUoB,EAAWM,oBAAoBlB,EAAaD,EAAwBe,GAIpF/G,KAAKoH,gBAAgBP,EAAW/J,KAAMgK,EAAkBpB,EAAOE,GAI/DtF,EAAG+G,WAAW5B,GAGd,IAASvM,EAAI,EAAGA,EAAI6N,EAAc3Q,OAAQ8C,IACzCoH,EAAGgH,cAAchH,EAAGiH,SAAWrO,GAC/BoH,EAAGkH,YAAYlH,EAAGmH,WAAYV,EAAc7N,GAAGwO,SAGhD,OADAb,EAAWc,6BAA6BlC,EAASsB,GAC1CtB,CACR,EAKQ,YAAAmC,cAAR,SAAsBC,GACb,IAAAvH,EAAON,KAAI,GACf6H,IACHvH,EAAGwH,OAAOxH,EAAGyH,OACbzH,EAAG0H,UAAU1H,EAAG2H,UAAW3H,EAAG4H,qBAEhC,EAKQ,YAAAC,kBAAR,SACCnB,EACAtB,GAIA,YAAc3F,IAAV2F,EACI,CAACsB,IAEL,IAAA3R,SAAQqQ,IAEP,IAAA0C,qBAAoBpB,EAAQtB,IAA2C,EACnEA,EAED,EAAP,KAAYA,GAAwC,GAAF,CAAEsB,IAAK,GAEtDtB,IAAUsB,GAAUtB,EAAwBsB,QAAUA,EAClD,CAACtB,GAEF,CAAEA,EAAoCsB,EAC9C,EAMQ,YAAAqB,uCAAR,SAA+CC,GAE9C,IAAMjF,EAAcrD,KAAKoD,oBAAoBkF,EAAMC,eACnDvI,KAAKwF,KAAK,CACTC,QAASpC,EACTqC,MAAO4C,EACP1C,OAAQ0C,GAEV,EAKQ,YAAAlB,gBAAR,SACCnB,EACAa,EACApB,EACAE,GAEM,IAAEtF,EAAiBN,KAAf,GAAEgB,EAAahB,KAAL,SAGpB,GAAK4F,EAAL,CAUA,IAFA,IAAM4C,GAAe,IAAAnT,SAAQuQ,GAAUA,EAAS,CAACA,GAExC1M,EAAI,EAAGuP,EAAaD,EAAYpS,OAAQ8C,EAAIuP,EAAYvP,IAAK,CACrE,IAAMwP,EAAcF,EAAYtP,GAEhC,GAAIwM,IAAWA,IAAUE,GAAWF,EAAwBsB,QAAUpB,IACpE,IAAAvQ,SAAQqQ,KAAU,IAAA0C,qBAAoBM,EAAahD,IAA0C,GAAK,CACnG,GAA+B,IAA3BgD,EAAYpD,WACf,MAAM,IAAIY,MAAM,kCAA2BwC,EAAY5L,KAAI,gLAExDgK,EAEH4B,EAAYC,kBAAiB,IAG7B3I,KAAKqI,uCAAuCK,GAE5CA,EAAYC,kBAAiB,G,MAG1B7B,EAEH4B,EAAYC,kBAAiB,IAIzBD,EAAYE,yCACf5I,KAAKqI,uCAAuCK,GAE7CA,EAAYC,kBAAiB,G,CAMhC,IAAME,EAASL,EAAY,GACvBM,OAAiD/I,EAC/CgJ,EAAc,CAACzI,EAAG0I,mBACxB,GAAIR,EAAYpS,OAAS,EAAG,CAC3B0S,EAAqB,GACrB,IAAS5P,EAAI,EAAGuP,EAAaD,EAAYpS,OAAQ8C,EAAIuP,EAAYvP,IAChE4P,EAAmBzE,KAAKmE,EAAYtP,GAAG+P,iBACvCF,EAAY1E,KAAK/D,EAAG0I,kBAAoB9P,E,EAG1C,IAAAgQ,iBAAgBlJ,KAAM6I,EAAQA,EAAOI,gBAAiBH,GAElD9H,GACFV,EAA8ByI,YAAYA,GAGtC,MAAoB/I,KAAKmJ,sBAAsBlD,EAAaL,GAA1Dd,EAAK,QAAEC,EAAM,SACrBzE,EAAG8I,SAAS,EAAG,EAAGtE,EAAOC,E,KA5DzB,CACCzE,EAAG+I,gBAAgB/I,EAAGgJ,YAAa,MAE7B,IAAE5C,EAAoB1G,KAAd,OAAE2G,EAAY3G,KAAL,QACvBM,EAAG8I,SAAS,EAAG,EAAG1C,EAAQC,E,CAyD5B,EAKQ,YAAA4C,oBAAR,SAA4B9D,EAAuB3I,EAAc0M,EAAcvD,GACxE,IAGF9I,EAHE,EAA8D6C,KAA5DM,EAAE,KAAEjC,EAAyB,4BAAEC,EAAwB,2BAE3DmL,EAAYpL,EAA0BvB,GAQ1C,GANK2M,IACJA,EAAY,IAAIC,QAChBrL,EAA0BvB,GAAQ2M,QAIlB1J,IAAb5C,EAAwB,CAE3B,IADAA,EAAWmD,EAAGqJ,kBAAkBlE,EAAS3I,IAC1B,EACd,MAAM,IAAIoJ,MAAM,2CAAoCpJ,EAAI,yBAAiBmJ,EAAW,OAGrFwD,EAAUjP,IAAIiL,EAAStI,E,CAQxBmD,EAAGsJ,oBAAoBzM,EAAUqM,EAAMlJ,EAAGuJ,OAAO,EAAO,EAAG,GAE3DvJ,EAAGwJ,wBAAwB3M,GAC3BmB,EAAyBnB,IAAY,CACtC,EACQ,YAAA4M,yBAAR,WAGC,IAFM,IAAEzL,EAAiC0B,KAAT,yBAAEM,EAAON,KAAL,GAC9ByJ,EAAYhU,OAAOmK,KAAKtB,GACrBpF,EAAI,EAAG8Q,EAAgBP,EAAUrT,OAAQ8C,EAAI8Q,EAAe9Q,IAAK,CACzE,IAAM,EAAWuQ,EAAUvQ,GACvBoF,EAAyB,KAC5BgC,EAAG2J,yBAAyB,UACrB3L,EAAyB,G,CAGnC,EAKA,YAAA4L,sBAAA,SAAsBzE,EAAuBQ,GAC5CjG,KAAKuJ,oBAAoB9D,EAAS,mBAAoB,EAAGQ,EAC1D,EAKQ,YAAAkE,mBAAR,SAA2B1E,EAAuBQ,GACjDjG,KAAKuJ,oBAAoB9D,EAAS,gBAAiB,EAAGQ,EACvD,EAKQ,YAAAmE,gBAAR,SAAwB3E,EAAuBQ,GAC9CjG,KAAKuJ,oBAAoB9D,EAAS,aAAc,EAAGQ,EACpD,EAEQ,YAAAkD,sBAAR,SAA8BlD,EAAqBL,GAClD,IAAI,IAAAvQ,SAAQuQ,GAAS,CAKpB,IAHA,IAAMyE,EAAezE,EAAsB,GACrC,EAAQyE,EAAcA,EAAYvF,MAAQ9E,KAAK0G,OAC/C,EAAS2D,EAAcA,EAAYtF,OAAS/E,KAAK2G,QAC9CzN,EAAI,EAAGuP,EAAc7C,EAAsBxP,OAAQ8C,EAAIuP,EAAYvP,IAAK,CAChF,IAAMoR,EAAc1E,EAAsB1M,GAC1C,GAAIoR,EAAWxF,QAAU,GAASwF,EAAWvF,SAAW,EACvD,MAAM,IAAImB,MAAM,0EAAmE,EAAK,aAAK,EAAM,kBAAUoE,EAAWxF,MAAK,aAAKwF,EAAWvF,OAAM,0BAAkBkB,EAAW,M,CAGlL,MAAO,CAAEnB,MAAK,EAAEC,OAAM,E,CAIvB,MAAO,CAAED,MAFKc,EAAUA,EAAoBd,MAAQ9E,KAAK0G,OAEzC3B,OADDa,EAAUA,EAAoBb,OAAS/E,KAAK2G,QAE5D,EAMQ,YAAA4D,4BAAR,SAAoCrM,EAAasM,GAChD,GAAItM,EAAO0H,SAAU,IAAAvQ,SAAQ6I,EAAO0H,SAAW5F,KAAKkB,cAAgB,EAAAE,MAAO,CAC1E,IAAK,IAAIlI,EAAI,EAAGuP,EAAcvK,EAAO0H,OAAsBxP,OAAQ8C,EAAIuP,EAAYvP,IACjF8G,KAAKwK,GAAkC,EAAD,KACnCtM,GAAM,CACTuH,QAAe,IAANvM,EAAUgF,EAAOuH,QAAUvH,EAAOuH,QAAQgF,eAAgBvR,EAAI,GACvE0M,OAAS1H,EAAO0H,OAAsB1M,MAGxC,OAAO,C,CAER,OAAO,CACR,EAEQ,YAAAwR,YAAR,SAAoBxM,GAGX,IAAAoC,EAAON,KAAI,GAEf9B,EAAO2J,YAAYvH,EAAGkB,QAAQlB,EAAGyH,MAEtC,EAWA,YAAAvC,KAAA,SACCtH,GAQA,IAEM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,UAAW,QAAS,SAAU,cAGjB,6BAChC,IAAAE,mBAAkBF,EAHG,CAAC,WAGgB,6BAElCI,KAAKuK,4BAA4BrM,EAAQ,QAA7C,CACM,IAAEoC,EAAoBN,KAAlB,GAAE7B,EAAgB6B,KAAL,YACfyF,EAA2BvH,EAAM,QAAxBwH,EAAkBxH,EAAM,MAAjB0H,EAAW1H,EAAM,OAEzC,IAAIC,EAAJ,CAGA,IAAMwM,EAAY3K,KAAK4G,WAAWnB,EAAS,EAAA7G,qBAAsB,CAAC,GAAG,EAAM8G,EAAOE,GAGlFH,EAAQmF,kBAAkBD,EAAW,gBAAiB,CAAC,EAAG,GAAI,EAAAd,OAC9DpE,EAAQmF,kBAAkBD,EAAW,sBAAuB,CAAC,EAAG,GAAI,EAAAd,OACpEvJ,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAK2D,2BACpC3D,KAAKkK,sBAAsBS,EAAWlF,EAAQ3I,MAG9CkD,KAAK4H,cAAc1J,EAAO2J,YAC1BvH,EAAGuK,WAAWvK,EAAGwK,eAAgB,EAAG,GACpC9K,KAAK0K,YAAYxM,EAdM,CAJqC,CAmB7D,EAYA,YAAA6M,aAAA,SACC7M,GASA,IAEM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,UAAW,QAAS,SAAU,QAAS,cAG1B,qCAChC,IAAAE,mBAAkBF,EAHG,CAAC,WAGgB,qCAElCI,KAAKuK,4BAA4BrM,EAAQ,gBAA7C,CACM,IAAEoC,EAAoBN,KAAlB,GAAE7B,EAAgB6B,KAAL,YACfyF,EAA2BvH,EAAM,QAAxBwH,EAAkBxH,EAAM,MAAjB0H,EAAW1H,EAAM,OAEzC,IAAIC,EAAJ,CAEM,MAAoB6B,KAAKmJ,sBAAsB1D,EAAQ3I,KAAM8I,GAA3Dd,EAAK,QAAEC,EAAM,SAGf4F,EAAY3K,KAAK4G,WAAWnB,EAAS,EAAA7G,qBAAsB,CAAC,GAAG,EAAO8G,EAAOE,GAI7EoF,EAAQ,CAAE,EAAIlG,EAAO,EAAIC,GAQ/B,GAPAU,EAAQmF,kBAAkBD,EAAW,gBAAiB,CAAC,EAAIK,EAAM,GAAI,EAAIA,EAAM,IAAK,EAAAnB,OACpFpE,EAAQmF,kBAAkBD,EAAW,sBAAuBK,EAAO,EAAAnB,OACnEvJ,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAK+D,+BACpC/D,KAAKkK,sBAAsBS,EAAWlF,EAAQ3I,MAG9CkD,KAAK4H,cAAc1J,EAAO2J,YACtB3J,EAAO+M,MAAO,CACX,IAAAA,EAAU/M,EAAM,OACjB,IAAA7I,SAAQ4V,KAAQA,EAAQ,CAACA,IAC9B,IAAK,IAAI/R,EAAI,EAAGgS,EAAWD,EAAM7U,OAAQ8C,EAAIgS,EAAUhS,IAAK,CAE3D,IAAMiS,EAAOF,EAAM/R,GACfiS,IAAS,EAAAC,eACZ9K,EAAGuK,WAAWvK,EAAG+K,MAAO,EAAG,GAExBF,IAAS,EAAAG,gBACZhL,EAAGuK,WAAWvK,EAAG+K,MAAO,EAAG,GAExBF,IAAS,EAAAI,cACZjL,EAAGuK,WAAWvK,EAAG+K,MAAO,EAAG,GAExBF,IAAS,EAAAK,iBACZlL,EAAGuK,WAAWvK,EAAG+K,MAAO,EAAG,E,OAI7B/K,EAAGuK,WAAWvK,EAAGmL,UAAW,EAAG,GAEhCzL,KAAK0K,YAAYxM,EAvCM,CAJ6C,CA4CrE,EAWA,YAAAwN,gBAAA,SACCxN,GAQA,IAEM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,UAAW,QAAS,SAAU,cAGjB,wCAChC,IAAAE,mBAAkBF,EAHG,CAAC,WAGgB,wCAElCI,KAAKuK,4BAA4BrM,EAAQ,mBAA7C,CACM,IAAEoC,EAAoBN,KAAlB,GAAE7B,EAAgB6B,KAAL,YACfyF,EAA2BvH,EAAM,QAAxBwH,EAAkBxH,EAAM,MAAjB0H,EAAW1H,EAAM,OAEzC,IAAIC,EAAJ,CAEM,MAAoB6B,KAAKmJ,sBAAsB1D,EAAQ3I,KAAM8I,GAA3Dd,EAAK,QAAEC,EAAM,SAGf4F,EAAY3K,KAAK4G,WAAWnB,EAAS,EAAA7G,qBAAsB,CAAC,GAAG,EAAO8G,EAAOE,GAG7EoF,EAAQ,CAAE,EAAIlG,EAAO,EAAIC,GAC/BU,EAAQmF,kBAAkBD,EAAW,gBAAiB,CAAC,EAAI,EAAIK,EAAM,GAAI,EAAI,EAAIA,EAAM,IAAK,EAAAnB,OAC5FpE,EAAQmF,kBAAkBD,EAAW,sBAAuBK,EAAO,EAAAnB,OACnEvJ,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAK2D,2BACpC3D,KAAKkK,sBAAsBS,EAAWlF,EAAQ3I,MAG9CkD,KAAK4H,cAAc1J,EAAO2J,YAC1BvH,EAAGuK,WAAWvK,EAAGwK,eAAgB,EAAG,GACpC9K,KAAK0K,YAAYxM,EAjBM,CAJgD,CAsBxE,EAeA,YAAAyN,WAAA,SACCzN,G,MAcM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,UAAW,WAAY,WAAY,iBAAkB,QAAS,SAAU,cAAe,cAG1E,mCAChC,IAAAE,mBAAkBF,EAHG,CAAC,UAAW,WAAY,YAGP,mCAElCI,KAAKuK,4BAA4BrM,EAAQ,cAA7C,CACM,IAAEoC,EAAoBN,KAAlB,GAAE7B,EAAgB6B,KAAL,YACfyF,EAA+CvH,EAAM,QAA5C0N,EAAsC1N,EAAM,SAAlC2N,EAA4B3N,EAAM,SAAxBwH,EAAkBxH,EAAM,MAAjB0H,EAAW1H,EAAM,OAE7D,IAAIC,EAAJ,CAEA,IAAI2G,EAAQ9E,KAAK0G,OACb3B,EAAS/E,KAAK2G,QACdzI,EAAO4N,iBACPhH,GAAF,EAAoB9E,KAAKmJ,sBAAsB1D,EAAQ3I,KAAM8I,IAAtD,MAAEb,EAAM,UAIjB,IAAM4F,EAAY3K,KAAK4G,WAAWnB,EAAS,EAAA7G,qBAAsB,CAAC,GAAG,EAAO8G,EAAOE,GAGnFH,EAAQmF,kBAAkBD,EAAW,gBAAiB,CAACkB,EAAW/G,EAAO+G,EAAW9G,GAAS,EAAA8E,OAC7FpE,EAAQmF,kBAAkBD,EAAW,sBAAuB,CAAC,EAAIiB,EAAS,GAAK9G,EAAQ,EAAG,EAAI8G,EAAS,GAAK7G,EAAS,GAAI,EAAA8E,OACzH,IAAM1F,EAAcjG,EAAOiG,YAAcjG,EAAOiG,YAAc,EAAA4H,4BAC9D,GAAI5H,EAAc,EACjB,MAAM,IAAI+B,MAAM,6EAAsE/B,EAAW,MAElG7D,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAKkE,0BAA0BC,IAC9DnE,KAAKkK,sBAAsBS,EAAWlF,EAAQ3I,MAG9CkD,KAAK4H,cAAc1J,EAAO2J,YAC1BvH,EAAGuK,WAAWvK,EAAG0L,aAAc,EAAG7H,EAAc,GAChDnE,KAAK0K,YAAYxM,EAxBM,CAJ2C,CA6BnE,EAkBA,YAAA+N,YAAA,SACC/N,G,MAgBM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,UAAW,YAAa,YAAa,YAAa,iBAAkB,QAAS,SAAU,UAAW,iBAAkB,cAGvG,oCAChC,IAAAE,mBAAkBF,EAHG,CAAC,UAAW,YAAa,YAAa,aAGrB,oCAElCI,KAAKuK,4BAA4BrM,EAAQ,eAA7C,CACM,IAAEoC,EAAoBN,KAAlB,GAAE7B,EAAgB6B,KAAL,YACfyF,EAA4DvH,EAAM,QAAzDgO,EAAmDhO,EAAM,UAA9CiO,EAAwCjO,EAAM,UAAnCkO,EAA6BlO,EAAM,UAAxBwH,EAAkBxH,EAAM,MAAjB0H,EAAW1H,EAAM,OAE1E,IAAIC,EAAJ,CAEA,IAAI2G,EAAQ9E,KAAK0G,OACb3B,EAAS/E,KAAK2G,QACdzI,EAAO4N,iBACPhH,GAAF,EAAoB9E,KAAKmJ,sBAAsB1D,EAAQ3I,KAAM8I,IAAtD,MAAEb,EAAM,UAIjB,IAAM4F,EAAY3K,KAAK4G,WAAWnB,EAAS,EAAAzG,qBAAsB,CAAC,GAAG,EAAO0G,EAAOE,GAGnFH,EAAQmF,kBAAkBD,EAAW,wBAAyByB,EAAY,EAAG,EAAAvC,OAC7EpE,EAAQmF,kBAAkBD,EAAW,gBAAiB,CAAC,EAAI7F,EAAO,EAAIC,GAAS,EAAA8E,OAC/E,IAAMwC,EAAQH,EAAU,GAAKC,EAAU,GACjCG,EAAQJ,EAAU,GAAKC,EAAU,GACjCI,EAAQ7T,KAAK8T,MAAMF,EAAOD,GAChC5G,EAAQmF,kBAAkBD,EAAW,mBAAoB4B,EAAO,EAAA1C,OAChE,IAAM4C,GAAWP,EAAU,GAAKC,EAAU,IAAM,EAC1CO,GAAWR,EAAU,GAAKC,EAAU,IAAM,EAChD1G,EAAQmF,kBAAkBD,EAAW,sBAAuB,CAAC,EAAI8B,EAAU3H,EAAQ,EAAG,EAAI4H,EAAU3H,EAAS,GAAI,EAAA8E,OACjH,IAAMzT,EAASsC,KAAKiU,KAAKN,EAAQA,EAAQC,EAAQA,GAE3CnI,EAAcjG,EAAO0O,eAAyC,EAAxB1O,EAAO0O,eAAqB,EAAAb,4BACxE,GAAI7N,EAAO2O,QAAS,CACnB,GAAI1I,EAAc,GAAKA,EAAc,GAAM,EAC1C,MAAM,IAAI+B,MAAM,iFAA0E/B,EAAc,EAAC,MAE1GsB,EAAQmF,kBAAkBD,EAAW,iBAAkBvU,EAAQ,EAAAyT,OAC/DvJ,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAKkE,0BAA0BC,G,MAG9DsB,EAAQmF,kBAAkBD,EAAW,iBAAkBvU,EAASgW,EAAW,EAAAvC,OAE3EvJ,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAK2D,2BAErC3D,KAAKkK,sBAAsBS,EAAWlF,EAAQ3I,MAG9CkD,KAAK4H,cAAc1J,EAAO2J,YACtB3J,EAAO2O,QACVvM,EAAGuK,WAAWvK,EAAG0L,aAAc,EAAG7H,EAAc,GAEhD7D,EAAGuK,WAAWvK,EAAGwK,eAAgB,EAAG,GAErC9K,KAAK0K,YAAYxM,EA7CM,CAJ4C,CAkDpE,EAcC,YAAA4O,SAAA,SACA5O,GAWA,IAEM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,UAAW,WAAY,OAAQ,iBAAkB,QAAS,SAAU,cAGvD,iCAChC,IAAAE,mBAAkBF,EAHG,CAAC,UAAW,WAAY,QAGP,iCAElCI,KAAKuK,4BAA4BrM,EAAQ,YAA7C,CACA,IAAMgO,EAAY,CAAChO,EAAO0N,SAAS,GAAI1N,EAAO0N,SAAS,GAAK1N,EAAOsL,KAAK,GAAK,GACvE2C,EAAY,CAACjO,EAAO0N,SAAS,GAAK1N,EAAOsL,KAAK,GAAI0C,EAAU,IAClElM,KAAKiM,YAAY,CAChBxG,QAASvH,EAAOuH,QAChByG,UAAS,EACTC,UAAS,EACTC,UAAWlO,EAAOsL,KAAK,GACvBsC,eAAgB5N,EAAO4N,eACvBpG,MAAOxH,EAAOwH,MACdE,OAAQ1H,EAAO0H,OACfiH,SAAS,EACThF,WAAY3J,EAAO2J,YAZ4C,CAcjE,EAkVA,YAAAkF,kBAAA,SACC7O,G,MAgBM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,QAAS,UAAW,QAAS,SAAU,YAAa,iBAAkB,QAAS,QAAS,QAAS,QAAS,cAG7F,0CAChC,IAAAE,mBAAkBF,EAHG,CAAC,SAGgB,0CAElCI,KAAKuK,4BAA4BrM,EAAQ,qBAA7C,CACM,MAAqD8B,KAAnDM,EAAE,KAAE0M,EAAgB,mBAAE9L,EAAW,cAAE/C,EAAW,cAC9C6I,EAAkB9I,EAAM,MAAjB0H,EAAW1H,EAAM,OAEhC,IAAIC,EAAJ,CAGA,GAA4B,IAAxB6I,EAAM9B,eAA+C,IAAxB8B,EAAM9B,cACtC,MAAM,IAAIgB,MAAM,qHAA8Gc,EAAMlK,KAAI,kBAAUkK,EAAM9B,cAAa,iBAE9J,IAAA9O,EAAW4Q,EAAK,OAClBiG,EAAQ/O,EAAO+O,OAAS7W,EAC9B,GAAI6W,EAAQ7W,EACX,MAAM,IAAI8P,MAAM,wBAAiB+G,EAAK,0CAAkC7W,EAAM,MAE3E8K,IAAgB,EAAAE,OAAS6L,EAAQ,EAAAC,eACpCpS,QAAQC,KAAK,yCAAkCkS,EAAK,wDAAgD,EAAAC,cAAa,MAGlH,IAAIzH,EAAUvH,EAAOuH,QACrB,QAAgB1F,IAAZ0F,EAAuB,CAC1BA,EAAUzF,KAAKgD,wBAAwB,EAAA6G,OACvC,IAAMsD,EAAQjP,EAAOiP,OAAS,CAAC,EAAG,EAAG,GACrC,GAAqB,IAAjBA,EAAM/W,OAAc,MAAM,IAAI8P,MAAM,kDAA2CM,KAAKC,UAAU0G,GAAM,MACxG1H,EAAQ2H,WAAW,UAAW,EAAF,KAAMD,GAAO,GAAF,CAAE,IAAI,KAAAtD,M,CAI9C,IAAMnE,EAAQ1F,KAAKmI,kBAAkBnB,EAAO9I,EAAOwH,OAE7C2H,EAA4C,CAAC,EAGvB,IAAxBrG,EAAM9B,gBAAqBmI,EAAoB,EAAAC,2BAA6B,KAC5EpP,EAAOkH,QAAOiI,EAAoB,EAAAE,iBAAmB,KACrDrP,EAAOmH,QAAOgI,EAAoB,EAAAG,iBAAmB,KAGzD,IAAM7C,EAAY3K,KAAK4G,WAAWnB,EAAS,EAAAvG,0BAA2BmO,GAAqB,EAAO3H,EAAOE,GAGzGH,EAAQmF,kBAAkBD,EAAW,qBAAqB,IAAAvC,qBAAoBpB,EAAOtB,GAAQ,EAAA+H,KAC7F,IAAI3I,EAAQ9E,KAAK0G,OACb3B,EAAS/E,KAAK2G,QACdzI,EAAO4N,iBACPhH,GAAF,EAAoB9E,KAAKmJ,sBAAsB1D,EAAQ3I,KAAM8I,IAAtD,MAAEb,EAAM,UAEjBU,EAAQmF,kBAAkBD,EAAW,gBAAiB,CAAC,EAAI7F,EAAO,EAAIC,GAAS,EAAA8E,OAE/E,IAAM6D,EAAYxP,EAAOwP,WAAa,EACtCjI,EAAQmF,kBAAkBD,EAAW,oBAAqB+C,EAAW,EAAA7D,OACrE,IAAM8D,EAA0B,CAAC3G,EAAMlC,MAAOkC,EAAMjC,QAGpD,GAFAU,EAAQmF,kBAAkBD,EAAW,8BAA+BgD,EAAyB,EAAA9D,OAEzF3I,IAAgB,EAAAE,MAAO,CAC1B,QAA+BrB,IAA3BC,KAAK4N,mBAAoCZ,GAAoBA,EAAiB5W,OAAS6W,EAAQ,CAElG,IAAMY,GAAU,IAAAC,0BAAyB1X,GACzC4J,KAAKgN,iBAAmBa,EACxB7N,KAAK4N,kBAAoB5N,KAAKsD,kBAAkBuK,E,CAEjDvN,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAK4N,mBACpC5N,KAAKmK,mBAAmBQ,EAAWlF,EAAQ3I,K,CAI5CkD,KAAK4H,cAAc1J,EAAO2J,YAC1BvH,EAAGuK,WAAWvK,EAAGyN,OAAQ,EAAGd,GAC5BjN,KAAK0K,YAAYxM,EAhEM,CAJkD,CAqE1E,EAuHA,YAAA8P,uBAAA,SACC9P,GAWA,IAEM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,QAAS,UAAW,QAAS,SAAU,gBAAiB,cAAe,QAAS,cAGnE,+CAChC,IAAAE,mBAAkBF,EAHG,CAAC,SAGgB,+CAElCI,KAAKuK,4BAA4BrM,EAAQ,0BAA7C,CACM,MAA4E8B,KAA1EM,EAAE,KAAE2N,EAAsB,yBAAEvH,EAAM,SAAEC,EAAO,UAAEzF,EAAW,cAAE/C,EAAW,cACrE6I,EAAkB9I,EAAM,MAAjB0H,EAAW1H,EAAM,OAEhC,IAAIC,EAAJ,CAGA,GAA4B,IAAxB6I,EAAM9B,cACT,MAAM,IAAIgB,MAAM,8GAAuGc,EAAMlK,KAAI,kBAAUkK,EAAM9B,cAAa,iBAQ/J,IAAIO,EAAUvH,EAAOuH,QACrB,QAAgB1F,IAAZ0F,EAAuB,CAC1BA,EAAUzF,KAAKgD,wBAAwB,EAAA6G,OACvC,IAAMsD,EAAQjP,EAAOiP,OAAS,CAAC,EAAG,EAAG,GACrC,GAAqB,IAAjBA,EAAM/W,OAAc,MAAM,IAAI8P,MAAM,kDAA2CM,KAAKC,UAAU0G,GAAM,MACxG1H,EAAQ2H,WAAW,UAAW,EAAF,KAAMD,GAAO,GAAF,CAAE,IAAI,KAAAtD,M,CAI9C,IAAMnE,EAAQ1F,KAAKmI,kBAAkBnB,EAAO9I,EAAOwH,OAG7CiF,EAAY3K,KAAK4G,WAAWnB,EAAS,EAAArG,gCAAiC,CAAC,GAAG,EAAOsG,EAAOE,GAG9FH,EAAQmF,kBAAkBD,EAAW,mBAAmB,IAAAvC,qBAAoBpB,EAAOtB,GAAQ,EAAA+H,KAE3F,IAAMS,EAAchQ,EAAOgQ,aAAe,EAC1CzI,EAAQmF,kBAAkBD,EAAW,gBAAiB,CAACuD,EAAcxH,EAAQwH,EAAcvH,GAAU,EAAAkD,OACrG,IAAMsE,EAAgBjQ,EAAOiQ,eAAiB,GACxCC,EAAmB,CAAC1V,KAAK2V,MAAM3H,EAASyH,GAAgBzV,KAAK2V,MAAM1H,EAAUwH,IACnF1I,EAAQmF,kBAAkBD,EAAW,qBAAsByD,EAAkB,EAAAvE,OAC7E,IAAMzT,EAAS,EAAIgY,EAAiB,GAAKA,EAAiB,GAE1D,GAAIlN,IAAgB,EAAAE,MAAO,CAC1B,QAAqCrB,IAAjCC,KAAKsO,yBAA0CL,GAA0BA,EAAuB7X,OAASA,EAAS,CAErH,IAAMyX,GAAU,IAAAC,0BAAyB1X,GACzC4J,KAAKiO,uBAAyBJ,EAC9B7N,KAAKsO,wBAA0BtO,KAAKsD,kBAAkBuK,E,CAEvDvN,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAKsO,yBACpCtO,KAAKmK,mBAAmBQ,EAAWlF,EAAQ3I,K,CAI5CkD,KAAK4H,cAAc1J,EAAO2J,YAC1BvH,EAAGuK,WAAWvK,EAAG+K,MAAO,EAAGjV,GAC3B4J,KAAK0K,YAAYxM,EAlDM,CAJuD,CAuD/E,EAeC,YAAAqQ,gBAAA,SACArQ,G,MAaM0B,EAAOnK,OAAOmK,KAAK1B,GAIzB,IAHA,IAAA2B,gBAAeD,EAHG,CAAC,QAAS,UAAW,UAAW,QAAS,SAAU,iBAAkB,QAAS,cAGhE,wCAChC,IAAAE,mBAAkBF,EAHG,CAAC,SAGgB,wCAElCI,KAAKuK,4BAA4BrM,EAAQ,mBAA7C,CACM,MAAuF8B,KAArFM,EAAE,KAAEoG,EAAM,SAAEC,EAAO,UAAEzF,EAAW,cAAE/C,EAAW,cAAEqQ,EAAgB,mBAAEC,EAAe,kBAChFzH,EAAkB9I,EAAM,MAAjB0H,EAAW1H,EAAM,OAEhC,IAAIC,EAAJ,CAGA,GAA4B,IAAxB6I,EAAM9B,eAA+C,IAAxB8B,EAAM9B,cACtC,MAAM,IAAIgB,MAAM,+HAAwHc,EAAMlK,KAAI,kBAAUkK,EAAM9B,cAAa,iBAGhL,IAAMwJ,EAAiB1H,EAAMnC,OAASmC,EAAM5Q,OAAS4Q,EAAMlC,MAAQkC,EAAMjC,OACrE7D,IAAgB,EAAAE,OAASsN,EAAiB,EAAAxB,eAC7CpS,QAAQC,KAAK,uCAAgC2T,EAAc,wDAAgD,EAAAxB,cAAa,MAGzH,IAAIzH,EAAUvH,EAAOuH,QACrB,QAAgB1F,IAAZ0F,EAAuB,CAC1BA,EAAUzF,KAAKgD,wBAAwB,EAAA6G,OACvC,IAAMsD,EAAQjP,EAAOiP,OAAS,CAAC,EAAG,EAAG,GACrC,GAAqB,IAAjBA,EAAM/W,OAAc,MAAM,IAAI8P,MAAM,kDAA2CM,KAAKC,UAAU0G,GAAM,MACxG1H,EAAQ2H,WAAW,UAAW,EAAF,KAAMD,GAAO,GAAF,CAAE,IAAI,KAAAtD,M,CAI9C,IAAMnE,EAAQ1F,KAAKmI,kBAAkBnB,EAAO9I,EAAOwH,OAE7C2H,EAA4C,CAAC,EAGvB,IAAxBrG,EAAM9B,gBAAqBmI,EAAoB,EAAAC,2BAA6B,KAGhF,IAAM3C,EAAY3K,KAAK4G,WAAWnB,EAAS,EAAAjG,wBAAyB6N,GAAqB,EAAO3H,EAAOE,GAGvGH,EAAQmF,kBAAkBD,EAAW,qBAAqB,IAAAvC,qBAAoBpB,EAAOtB,GAAQ,EAAA+H,KAC7F,IAAI3I,EAAQ4B,EACR3B,EAAS4B,EACTzI,EAAO4N,iBACPhH,GAAF,EAAoB9E,KAAKmJ,sBAAsB1D,EAAQ3I,KAAM8I,IAAtD,MAAEb,EAAM,UAEjBU,EAAQmF,kBAAkBD,EAAW,gBAAiB,CAAC,EAAI7F,EAAO,EAAIC,GAAS,EAAA8E,OAC/E,IAAM8D,EAA0B,CAAC3G,EAAMlC,MAAOkC,EAAMjC,QAGpD,GAFAU,EAAQmF,kBAAkBD,EAAW,8BAA+BgD,EAAyB,EAAA9D,OAEzF3I,IAAgB,EAAAE,MAAO,CAC1B,QAAyBrB,IAArByO,GAAmCC,GAAmBA,EAAgBrY,OAASsY,EAAiB,CAEnG,IAAMb,GAAU,IAAAC,0BAAyBY,GACzC1O,KAAKyO,gBAAkBZ,EACvB7N,KAAKwO,iBAAmBxO,KAAKsD,kBAAkBuK,E,CAEhDvN,EAAG0B,WAAW1B,EAAG2B,aAAcjC,KAAKwO,kBACpCxO,KAAKmK,mBAAmBQ,EAAWlF,EAAQ3I,K,CAK5C,GADAkD,KAAK4H,cAAc1J,EAAO2J,YACtB3J,EAAO2P,QAAS,CACb,MAA4B3P,EAAO2P,QAAjCc,EAAM,SAAE1B,EAAK,QAAE1J,EAAM,SAG7BjD,EAAG0B,WAAW1B,EAAGsO,qBAAsBrL,GAEvCjD,EAAGuO,aAAavO,EAAGwO,UAAW7B,EAAO0B,EADtB,E,MAIfrO,EAAGuK,WAAWvK,EAAGwO,UAAW,EAAGJ,GAEhC1O,KAAK0K,YAAYxM,EAlEM,CAJgD,CAuExE,EAKA,sBAAI,yBAAU,C,IAcd,WACC,OAAO8B,KAAKxB,WACb,E,IAhBA,SAAe0D,GACd,IAAM5K,EAAO,EAAAuS,MAEb,KAAK,IAAAkF,mBAAkB7M,EADD,EAC4B5K,GACjD,MAAM,IAAI4O,MAAM,8BAAuBM,KAAKC,UAAUvE,GAAW,sCAA8B5K,EAAI,wBAAgBA,EAAI,sBAFlG,EAE6H,MAGnJ0I,KAAKxB,aAAc,IAAAnJ,SAAQ6M,GAAeA,EAAwBzL,QAAUyL,EAC5ElC,KAAKgP,qBAAkBjP,CACxB,E,gCAYA,sBAAY,6BAAc,C,IAA1B,WACO,IAAAiP,EAAoBhP,KAAI,gBAC9B,IAAKgP,EAAiB,CACb,IAAA9M,EAAelC,KAAI,WAE3B,GADAgP,EAAkB,IACd,IAAA/a,gBAAeiO,GAClB8M,EAAgB3K,KAAKnC,EAAsBA,EAAsBA,EAAsBA,OACjF,CACN8M,EAAgB3K,KAAI,MAApB2K,EAAwB9M,GACxB,IAAK,IAAItF,EAAIoS,EAAgB5Y,OAAQwG,EAAI,EAAGA,IAC3CoS,EAAgB3K,KAAK,E,CAGvBrE,KAAKgP,gBAAkBA,C,CAExB,OAAOA,CACR,E,gCAKA,YAAAC,MAAA,WACO,IAAEvP,EAAmCM,KAArB,eAAEkP,EAAmBlP,KAAL,eAClCN,GAAgB5E,QAAQmG,IAAI,wBAChC,IAAMwE,EAAUzF,KAAKgD,wBAAwB,EAAA6G,OAC7CpE,EAAQ2H,WAAW,UAAW8B,GAE9BlP,KAAKwF,KAAK,CACTC,QAAO,GAET,EAKA,YAAA0J,eAAA,WACO,MAAmCnP,KAAjCM,EAAE,KAAEyC,EAAc,iBAAE/B,EAAQ,WACpC,IAAK+B,EACJ,MAAM,IAAImD,MAAM,+GAIjB5F,EAAGkB,QAAQlB,EAAGyH,OAGVhF,KACC/B,EAAWV,EAA8BsB,gBAAgB,OAEhD,IAAAC,cAAa7B,KAAM,EAAA8B,yBAAyB,GACpDC,mBAAmB,MAG1B,EAKA,YAAAqN,gBAAA,WACO,IAAE9O,EAAuBN,KAArB,GAAE+C,EAAmB/C,KAAL,eAC1B,IAAK+C,EACJ,MAAM,IAAImD,MAAM,+GAIjB,IAAMkD,EAAWrG,EAAesM,YAAY,IAAIC,EAAaC,SAC7DjP,EAAG8I,SAASA,EAASoG,EAAGpG,EAASqG,EAAGrG,EAAStE,MAAOsE,EAASrE,QAG7DhC,EAAe2M,YAChB,EAUA,YAAAC,QAAA,SAAQzR,QAAA,IAAAA,IAAAA,EAAA,IAKP,IACM0B,EAAOnK,OAAOmK,KAAK1B,IACzB,IAAA2B,gBAAeD,EAFG,CAAC,WAAY,MAAO,YAEN,+BAExB,IAAAS,EAAWL,KAAI,OACjB4P,EAAW1R,EAAO0R,UAAY,SAC9BC,EAAW3R,EAAO2R,UAAYvT,OAGpC+D,EAAOyP,QAAO,SAACxZ,GACTA,EAID4H,EAAO3H,KACV,IAAAF,eAAcC,EAAM4H,EAAO3H,KAAKwZ,MAAK,SAACzZ,GACrCuZ,EAASvZ,EAAM,UAAGsZ,EAAQ,QAC3B,IAEAC,EAASvZ,EAAM,UAAGsZ,EAAQ,SAR1B9U,QAAQC,KAAK,uDAUf,GAAG,YACJ,EAOA,YAAAiV,KAAA,WACChQ,KAAKL,WAAa,EACd,IAAEsQ,EAAgCjQ,KAAnB,cAAEkQ,EAAiBlQ,KAAL,aAC3BmQ,EAAcC,YAAYC,MAEhC,GADArQ,KAAKiQ,cAAgBE,GAChBF,EACJ,MAAO,CAAEK,IAAK,EAAGC,SAAUvQ,KAAKL,WAEjC,IAAM6Q,EAAa,KAAQL,EAAcF,GACpCC,IAAcA,EAAeM,GAElC,IACMF,EAAOvc,OAAO0c,YADL,GAC0BP,GAAgB,EAD1C,IACwDM,GAAYE,QAAQ,IAE3F,OADA1Q,KAAKkQ,aAAeI,EACb,CACNA,IAAG,EACHC,SAAUvQ,KAAKL,UAEjB,EAMA,sBAAI,uBAAQ,C,IAAZ,WACC,OAAOK,KAAKL,SACb,E,gCAKA,YAAAgR,QAAA,e,EAAA,OACSrQ,EAAuBN,KAArB,GAAqBA,KAAL,gBAENlF,QAAQmG,IAAI,6BAG5BjB,KAAK4D,uBACRtD,EAAGsQ,aAAa5Q,KAAK4D,6BACd5D,KAAK4D,sBAET5D,KAAKgE,2BACR1D,EAAGsQ,aAAa5Q,KAAKgE,iCACdhE,KAAKgE,0BAEZvO,OAAOmK,KAAKI,KAAK5B,wBAA4CyS,SAAQ,SAAA5N,GACrE3C,EAAGsQ,aAAa,EAAKxS,uBAAuB6E,GAC7C,WAEOjD,KAAK5B,8BACL4B,KAAKgN,iBACRhN,KAAK4N,oBACRtN,EAAGsQ,aAAa5Q,KAAK4N,0BACd5N,KAAK4N,0BAEN5N,KAAKiO,uBACRjO,KAAKsO,0BACRhO,EAAGsQ,aAAa5Q,KAAKsO,gCACdtO,KAAKsO,yBAETtO,KAAK8Q,2BACRxQ,EAAGsQ,aAAa5Q,KAAK8Q,iCACd9Q,KAAK8Q,0BAIbrb,OAAOmK,KAAKI,KAAK3B,2BAA2BwS,SAAQ,SAAC5N,UAC7C,EAAK5E,0BAA0B4E,EACvC,WAEOjD,KAAK3B,iCAEL2B,KAAK1B,yBAGZ7I,OAAOsb,OAAO/Q,KAAKrB,gBAAgBkS,SAAQ,SAAC,G,IAAE9R,EAAe,kBAC5DtJ,OAAOmK,KAAKb,GAAiB8R,SAAQ,SAAA5N,GACpC3C,EAAG0Q,aAAajS,EAAgBkE,WACzBlE,EAAgBkE,EACxB,GACD,WAEOjD,KAAKrB,eAGZlJ,OAAOsb,OAAO/Q,KAAKvB,eAAeoS,SAAQ,SAAApL,GACzCA,EAAQkL,SACT,IACAlb,OAAOmK,KAAKI,KAAKvB,eAAeoS,SAAQ,SAAA5N,UAEhC,EAAKxE,cAAcwE,EAC3B,WAEOjD,KAAKvB,cAEZhJ,OAAOsb,OAAO/Q,KAAKtB,mBAAmBmS,SAAQ,SAAApL,GAC7CA,EAAQkL,SACT,IACAlb,OAAOmK,KAAKI,KAAKtB,mBAAmBmS,SAAQ,SAAA5N,UAEpC,EAAKvE,kBAAkBuE,EAC/B,WAEOjD,KAAKtB,kBAEiB,QAA7B,EAAAsB,KAAKiR,gCAAwB,SAAEN,iBACxB3Q,KAAKiR,gCAGLjR,KAAK+C,sBAEL/C,KAAKM,UAELN,KAAKK,cAGLL,KAAKC,sBAELD,KAAKzB,mBAKLyB,KAAK7B,mBAEL6B,KAAKN,sBAELM,KAAKL,iBAELK,KAAKgB,gBAELhB,KAAKkB,mBAELlB,KAAKqB,oBAELrB,KAAKuB,sBAELvB,KAAK0G,cAEL1G,KAAK2G,eAEL3G,KAAKxB,mBACLwB,KAAKgP,eACb,EACD,EAtoEA,GAAa,EAAArM,YAAAA,C,sGCzEb,aACA,SACA,SACA,SAGA,aAyBC,WACCD,EACAxE,GAOA,GAFA8B,KAAKkR,UAAYxO,GAEZxE,EACJ,MAAM,IAAIgI,MAAM,uFAEjB,KAAK,IAAA3Q,UAAS2I,GACb,MAAM,IAAIgI,MAAM,+GAAwGM,KAAKC,UAAUvI,GAAO,MAG/I,IAEM0B,EAAOnK,OAAOmK,KAAK1B,IACzB,IAAA2B,gBAAeD,EAHG,CAAC,UAAW,QAGE,mCAAoC1B,EAAOpB,OAC3E,IAAAgD,mBAAkBF,EAHG,CAAC,WAGgB,mCAAoC1B,EAAOpB,MAE3E,IAYF6R,EAZEd,EAAY3P,EAAM,QAEhBoC,EAAiBoC,EAAQ,GAArB1B,EAAa0B,EAAQ,SAE3ByO,EAAc7Q,EAAGkD,eASvB,OAPAlD,EAAG0B,WAAW1B,EAAGsO,qBAAsBuC,IAGlC,IAAAlc,cAAa4Y,KACjBA,EAAU,IAAIuD,YAAYvD,IAGpBA,EAAQ5G,aACd,KAAKhQ,WACJ0X,EAASrO,EAAG+Q,cACZ,MACD,KAAKC,YACJ3C,EAASrO,EAAGiR,eACZ,MACD,KAAKH,YACJ,IAAKpQ,EAEJ,KADY,IAAAa,cAAaa,EAAU,EAAA8O,wBAAwB,GACjD,CAET7C,EAASrO,EAAGiR,eACZ1D,EAAUyD,YAAY1X,KAAKiU,GAC3B,K,CAGFc,EAASrO,EAAGmR,aAIdnR,EAAGmD,WACFnD,EAAGsO,qBACHf,EACAvN,EAAGoD,aAGJ1D,KAAKuD,OAAS4N,EACdnR,KAAK2O,OAASA,EACd3O,KAAKiN,MAAQY,EAAQzX,MACtB,CAqBD,OAhBC,YAAAua,QAAA,WACO,IAAEO,EAAsBlR,KAAb,UAAEuD,EAAWvD,KAAL,OACzBkR,EAAU5Q,GAAGsQ,aAAarN,UAInBvD,KAAKkR,iBAELlR,KAAKuD,cAILvD,KAAK2O,cAEL3O,KAAKiN,KACb,EACD,EA/GA,GAAa,EAAAyE,eAAAA,C,q+CCNb,aAEA,SAQA,SACA,SAEA,SAUA,SA0BA,SAIA,SACA,SAEA,aAiNC,WACChP,EACAxE,GApLO,KAAAM,YAAiC,EAKjC,KAAAmT,aAAe,EAEN,KAAAC,SAA2B,GA2LnC,IAAA9U,GAAUoB,GAAU,CAAC,GAAE,KAC/B,IAAKwE,EACJ,MAAM,IAAIwD,MAAM,kCAA2BpJ,EAAI,qEAEhD,IAAKoB,EACJ,MAAM,IAAIgI,MAAM,2EAEjB,KAAK,IAAA3Q,UAAS2I,GACb,MAAM,IAAIgI,MAAM,mGAA4FM,KAAKC,UAAUvI,GAAO,MAGnI,IAEM0B,EAAOnK,OAAOmK,KAAK1B,IACzB,IAAA2B,gBAAeD,EAHG,CAAC,OAAQ,OAAQ,gBAAiB,aAAc,SAAU,QAAS,QAAS,aAAc,aAAc,SAG1F,6BAA8B1B,EAAOpB,OACrE,IAAAgD,mBAAkBF,EAHG,CAAC,OAAQ,OAAQ,gBAAiB,cAGjB,6BAA8B1B,EAAOpB,MAEnE,IAAA8H,EAAoC1G,EAAM,WAA9B5G,EAAwB4G,EAAM,KAAxBgH,EAAkBhH,EAAM,cAC1CoC,EAAOoC,EAAQ,GAOvB,GAJA1C,KAAKkR,UAAYxO,EACjB1C,KAAKlD,KAAOA,IAGP,IAAAzI,mBAAkB6Q,IAAkBA,EAAgB,EACxD,MAAM,IAAIgB,MAAM,iCAA0BM,KAAKC,UAAUvB,GAAc,0BAAkBpI,EAAI,sCAE9FkD,KAAKkF,cAAgBA,EAGf,MAA4BD,EAAS4M,iBAAiBjN,EAAY9H,EAAM4F,EAAShD,gBAA/EtJ,EAAM,SAAE0O,EAAK,QAAEC,EAAM,SAE7B/E,KAAK8R,QAAU1b,EACf4J,KAAK0G,OAAS5B,EACd9E,KAAK2G,QAAU5B,EAIf,IAAMgN,OAA4BhS,IAAX3J,GAAyBkB,IAAS,EAAAuS,OAASvS,GAAQ,EAAA0a,WAAwB,EAAAC,QAAT,EAAAC,OACnF/M,OAA2BpF,IAAlB7B,EAAOiH,OAAuBjH,EAAOiH,OAAS4M,EAC7D,KAAK,IAAAI,eAAchN,GAClB,MAAM,IAAIe,MAAM,0BAAmBM,KAAKC,UAAUtB,GAAO,0BAAkBrI,EAAI,6BAAqB0J,KAAKC,UAAU,EAAA2L,cAAa,MAGjI,GAAIjN,IAAW,EAAA+M,QAAY5a,IAAS,EAAAuS,OAASvS,GAAQ,EAAA0a,WACpD,MAAM,IAAI9L,MAAM,yGAAkGpJ,EAAI,wBAAgBxF,EAAI,MAE3I0I,KAAKmF,OAASA,EAGd,IAAMC,OAAyBrF,IAAjB7B,EAAOkH,MAAsBlH,EAAOkH,MAAQ,EAAAiN,cAC1D,KAAK,IAAAC,aAAYlN,GAChB,MAAM,IAAIc,MAAM,yBAAkBM,KAAKC,UAAUrB,GAAM,0BAAkBtI,EAAI,6BAAqB0J,KAAKC,UAAU,EAAA8L,YAAW,MAE7HvS,KAAKoF,MAAQA,EACb,IAAMC,OAAyBtF,IAAjB7B,EAAOmH,MAAsBnH,EAAOmH,MAAQ,EAAAgN,cAC1D,KAAK,IAAAC,aAAYjN,GAChB,MAAM,IAAIa,MAAM,yBAAkBM,KAAKC,UAAUpB,GAAM,0BAAkBvI,EAAI,6BAAqB0J,KAAKC,UAAU,EAAA8L,YAAW,MAK7H,GAHAvS,KAAKqF,MAAQA,IAGR,IAAAmN,iBAAgBlb,GACpB,MAAM,IAAI4O,MAAM,wBAAiBM,KAAKC,UAAUnP,GAAK,0BAAkBwF,EAAI,6BAAqB0J,KAAKC,UAAU,EAAAgM,gBAAe,MAE/HzS,KAAK1I,KAAOA,EACZ,IAAMob,EAAezN,EAAS0N,wBAAwB,CACrDjQ,SAAQ,EACRpL,KAAI,EACJwF,KAAI,IAELkD,KAAKuI,cAAgBmK,EAEf,MAKFzN,EAAS2N,uBAAuB,CACnClQ,SAAQ,EACR5F,KAAI,EACJoI,cAAa,EACbwN,aAAY,IARZG,EAAQ,WACRC,EAAgB,mBAChBnE,EAAM,SACNoE,EAAa,gBAOd/S,KAAKgT,kBAAoBF,EACzB9S,KAAKiT,UAAYJ,EACjB7S,KAAKkT,QAAUvE,EACf3O,KAAKmT,eAAiBJ,EAItB,IAAMK,EAAiBnO,EAASoO,0BAA0B,CAAE3Q,SAAQ,EAAEyC,OAAM,EAAEC,MAAK,EAAEC,MAAK,EAAEqN,aAAY,EAAE5V,KAAI,IAC9GkD,KAAKsT,gBAAkBF,EACvBpT,KAAKuT,UAAYjT,EAAG8S,GACpBpT,KAAKwT,eAAiBvO,EAASwO,wBAAwB,CAAE/Q,SAAQ,EAAEgR,KAAMtO,EAAOgO,eAAc,EAAEV,aAAY,EAAE5V,KAAI,IAClHkD,KAAK2T,SAAWrT,EAAGN,KAAKwT,gBACxBxT,KAAK4T,eAAiB3O,EAASwO,wBAAwB,CAAE/Q,SAAQ,EAAEgR,KAAMrO,EAAO+N,eAAc,EAAEV,aAAY,EAAE5V,KAAI,IAClHkD,KAAK6T,SAAWvT,EAAGN,KAAK4T,gBAGxB,IAAMtO,OAAmCvF,IAAtB7B,EAAOoH,WAA2BpH,EAAOoH,WAAa,EACzE,KAAK,IAAAjR,mBAAkBiR,GACtB,MAAM,IAAIY,MAAM,8BAAuBM,KAAKC,UAAUnB,GAAW,0BAAkBxI,EAAI,iCAExFkD,KAAKsF,WAAaA,OAGQvF,IAAtB7B,EAAOgE,aACVlC,KAAKkC,WAAahE,EAAOgE,YAG1BlC,KAAK8T,aAAa5V,EAAO6V,MAC1B,CA+xBD,OA/+Bc,EAAAC,iBAAb,SAA8BtR,EAC7BxE,G,mEAWA,MAAO,CAAP,EAAO,IAAIxH,SAAkB,SAACC,EAASC,GACtC,IAAKsH,EACJ,MAAM,IAAIgI,MAAM,4FAEjB,KAAK,IAAA3Q,UAAS2I,GACb,MAAM,IAAIgI,MAAM,oHAA6GM,KAAKC,UAAUvI,GAAO,MAGpJ,IAEM0B,EAAOnK,OAAOmK,KAAK1B,IACzB,IAAA2B,gBAAeD,EAHG,CAAC,OAAQ,MAAO,SAAU,QAAS,QAAS,SAAU,OAAQ,cAGhD,8CAA+C1B,EAAOpB,OACtF,IAAAgD,mBAAkBF,EAHG,CAAC,OAAQ,OAGQ,8CAA+C1B,EAAOpB,MAEpF,IAAAmX,EAAkD/V,EAAM,IAAnDpB,EAA6CoB,EAAM,KAA7CiH,EAAuCjH,EAAM,OAArCkH,EAA+BlH,EAAM,MAA9BmH,EAAwBnH,EAAM,MAAvB5G,EAAiB4G,EAAM,KAAjBrG,EAAWqG,EAAM,OAChE,KAAK,IAAAlJ,UAASif,GACb,MAAM,IAAI/N,MAAM,oFAA6E+N,EAAG,2BAAmBA,EAAG,MAEvH,GAAI3c,KAAS,IAAA4c,kBAAiB5c,GAC7B,MAAM,IAAI4O,MAAM,yBAAkB5O,EAAI,4CAAoCwF,EAAI,6BAAqB0J,KAAKC,UAAU,EAAA0N,iBAAgB,MAEnI,GAAItc,KAAW,IAAAuc,oBAAmBvc,GACjC,MAAM,IAAIqO,MAAM,2BAAoBrO,EAAM,4CAAoCiF,EAAI,6BAAqB0J,KAAKC,UAAU,EAAA4N,mBAAkB,MAIzI,IAAMrN,EAAQ,IAAI/B,EAASvC,EAAU,CACpC5F,KAAI,EACJxF,KAAMA,GAAQ,EAAAuS,MACd3E,cAAerN,EAASA,EAAOzB,OAAkC,EACjEwO,WAAY,CAAC,EAAG,GAChBO,OAAM,EACNC,MAAK,EACLC,MAAK,EACLC,WAAY,EACZpD,WAAYhE,EAAOgE,aAIdoS,EAAQ,IAAIC,MAClBD,EAAMvd,OAAS,WACdiQ,EAAM7E,OAAO,CAACmS,EAAMxP,MAAOwP,EAAMvP,QAASuP,GAE1C3d,EAAQqQ,EACT,EACAsN,EAAM/Y,QAAU,SAACI,GAChB/E,EAAO,IAAIsP,MAAM,+BAAwBpJ,EAAI,cAAMnB,IACpD,EACA2Y,EAAMzV,IAAMoV,CACb,I,QAwJA,sBAAI,oBAAK,C,IAAT,WACA,OAAOjU,KAAK0G,MACb,E,gCAKA,sBAAI,qBAAM,C,IAAV,WACC,OAAO1G,KAAK2G,OACb,E,gCAKA,sBAAI,qBAAM,C,IAAV,WACC,IAAK3G,KAAK8R,QACT,MAAM,IAAI5L,MAAM,+CAAwClG,KAAKlD,KAAI,OAElE,OAAOkD,KAAK8R,OACb,E,gCAMA,YAAAjN,KAAA,WACC,YAAwB9E,IAAjBC,KAAK8R,OACb,EAMA,YAAA0C,KAAA,WACC,OAAQxU,KAAK6E,MACd,EAMA,YAAA+D,sCAAA,WACC,SAAU5I,KAAKyU,oBAAqBzU,KAAKyU,kBAAkBzU,KAAK6F,aACjE,EAOA,YAAA6O,2BAAA,SAA2B1N,GAClB,IAAAkK,EAAclR,KAAI,UAC1B,GAAIA,OAASgH,EAAO,MAAM,IAAId,MAAM,6DACpC,IAAM7C,EAAc6N,EAAU9N,oBAAoBpD,KAAKuI,eACvD2I,EAAU1L,KAAK,CACdC,QAASpC,EACTqC,MAAO1F,KACP4F,OAAQoB,GAEV,EAwDQ,YAAA8M,aAAR,SACCa,GAEM,MAYF3U,KAXHlD,EAAI,OACJwI,EAAU,aACV4L,EAAS,YACT8B,EAAiB,oBACjBC,EAAS,YACTC,EAAO,UACPK,EAAS,YACTI,EAAQ,WACRE,EAAQ,WACR/O,EAAK,QACLC,EAAM,SAECzE,EAAuB4Q,EAAS,GAA5BjR,EAAmBiR,EAAS,eAEpC0D,EAAiE,MACjE,IAAAvf,SAAQsf,GAAeC,EAAwB3P,EAAS4P,sBAAsBF,EAA0C3U,OACnH2U,aAAY,EAAZA,EAAc1N,eAAgB6N,mBAAkBF,EAAwBD,GAEjF,IAAK,IAAIzb,EAAI,EAAGA,EAAIoM,EAAYpM,IAAK,CACpC,IAAMwO,EAAUpH,EAAGyU,gBACnB,IAAKrN,EAEJ,YADAzH,EAAe,+CAAwCnD,EAAI,cAAMwD,EAAG0U,WAAU,MAG/E1U,EAAGkH,YAAYlH,EAAGmH,WAAYC,GAG9BpH,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG4U,eAAgBvB,GACnDrT,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG6U,eAAgBtB,GACnDvT,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG8U,mBAAoB7B,GACvDjT,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG+U,mBAAoB9B,GAEvDjT,EAAGgV,WAAWhV,EAAGmH,WAAY,EAAGuL,EAAmBlO,EAAOC,EAAQ,EAAGkO,EAAWC,EAAS0B,GAGzF5U,KAAK4R,SAASvN,KAAKqD,E,CAGpBpH,EAAGkH,YAAYlH,EAAGmH,WAAY,MAC9BnH,EAAG+I,gBAAgB/I,EAAGgJ,YAAa,KACpC,EAKA,sBAAI,0BAAW,C,IAAf,WACC,OAAOtJ,KAAK2R,YACb,E,gCAKA,YAAApM,qBAAA,WACS,IAAAD,EAAetF,KAAI,WACR,IAAfsF,IAEJtF,KAAK2R,cAAgB3R,KAAK6F,YAAc,GAAKP,EAC9C,EAKC,YAAAiQ,qBAAA,WACQ,IAAAjQ,EAAetF,KAAI,WACR,IAAfsF,IAEJtF,KAAK2R,cAAgB3R,KAAK6F,YAAc,EAAIP,GAAcA,EAC3D,EAKA,sBAAI,2BAAY,C,IAAhB,WACC,OAAOtF,KAAK2F,gBAAgB3F,KAAK6F,YAClC,E,gCAOA,sBAAI,8BAAe,C,IAAnB,WACO,MAAgD7F,KAA9C4R,EAAQ,WAAED,EAAY,eAAE8C,EAAiB,oBACjD,OAAIA,GAAqBA,EAAkB9C,GAAsB8C,EAAkB9C,GAC5EC,EAASD,EACjB,E,gCAKA,sBAAI,wBAAS,C,IAAb,WACC,GAAwB,IAApB3R,KAAKsF,WACR,MAAM,IAAIY,MAAM,+CAAwClG,KAAKlD,KAAI,4BAElE,OAAOkD,KAAK2F,iBAAiB3F,KAAK6F,YAAc,EAAI7F,KAAKsF,YAActF,KAAKsF,WAC7E,E,gCAKA,YAAAK,gBAAA,SAAgB6P,GACT,MAA8CxV,KAA5CsF,EAAU,aAAEmP,EAAiB,oBAAE7C,EAAQ,WAC3C4D,EAAQ,GAAKA,GAASlQ,IACzBkQ,GAASlQ,IAENkQ,EAAQ,GAAKA,GAASlQ,KAEzBxK,QAAQC,KAAK,qCAA8Bya,EAAK,0BAAkBxV,KAAKlD,KAAI,sCAA8BwI,EAAa,EAAI,IAAM,GAAE,6BAC9HkQ,EAAQ,EACXA,GAASlQ,EAAa5M,KAAKC,KAAKD,KAAK+c,IAAID,GAASlQ,GAElDkQ,GAAgBlQ,GAGlB,IAAIoC,EAAUkK,EAAS4D,GAEvB,OADIf,GAAqBA,EAAkBe,KAAQ9N,EAAU+M,EAAkBe,IACxE,CACN9N,QAAO,EACPV,MAAOhH,KAET,EAMA,YAAA2I,iBAAA,SACCpD,GAEIA,GACHvF,KAAKuF,uBAIFvF,KAAKyU,oBACRzU,KAAKyU,kBAAkBzU,KAAK6F,kBAAe9F,EAE7C,EAEA,YAAA2V,aAAA,SAAa3B,GACN,MAQF/T,KAPHkR,EAAS,YACT8B,EAAiB,oBACjBC,EAAS,YACTC,EAAO,UACPpO,EAAK,QACLC,EAAM,SACNkE,EAAe,kBAER3I,EAAO4Q,EAAS,GAClByE,EAAiB1Q,EAAS4P,sBAAsBd,EAAO/T,MAC7DM,EAAGkH,YAAYlH,EAAGmH,WAAYwB,GAC9B3I,EAAGgV,WAAWhV,EAAGmH,WAAY,EAAGuL,EAAmBlO,EAAOC,EAAQ,EAAGkO,EAAWC,EAASyC,GAEzFrV,EAAGkH,YAAYlH,EAAGmH,WAAY,KAC/B,EAqBA,YAAAtF,OAAA,SACCyC,EACA+P,GAEM,IAAE7X,EAAoBkD,KAAhB,KACJN,EADoBM,KAAL,UACa,eAChCN,GAAgB5E,QAAQmG,IAAI,6BAAsBnE,EAAI,gBAAQ0J,KAAKC,UAAU7B,GAAW,MACtF,MAA4BK,EAAS4M,iBAAiBjN,EAAY9H,EAAM4C,GAAtEtJ,EAAM,SAAE0O,EAAK,QAAEC,EAAM,SAC7B/E,KAAK8R,QAAU1b,EACf4J,KAAK0G,OAAS5B,EACd9E,KAAK2G,QAAU5B,EACf/E,KAAK4V,kBACL5V,KAAK8T,aAAaa,EACnB,EAKA,sBAAI,yBAAU,C,IAad,WACC,OAAO3U,KAAKxB,WACb,E,IAfA,SAAe0D,GACR,IAAEgD,EAAwBlF,KAAX,cAAE1I,EAAS0I,KAAL,KAC3B,KAAK,IAAA+O,mBAAkB7M,EAAYgD,EAAe5N,GACjD,MAAM,IAAI4O,MAAM,8BAAuBM,KAAKC,UAAUvE,GAAW,0BAAkBlC,KAAKlD,KAAI,uBAAexF,EAAI,wBAAgBA,EAAI,sBAAc4N,EAAa,MAG/JlF,KAAKxB,aAAc,IAAAnJ,SAAQ6M,GAAeA,EAAwBzL,QAAUyL,EAC5ElC,KAAKgP,qBAAkBjP,CACxB,E,gCAYA,sBAAY,6BAAc,C,IAA1B,WACO,IAAAiP,EAAoBhP,KAAI,gBAC9B,IAAKgP,EAAiB,CACb,IAAA9M,EAAelC,KAAI,WAE3B,GADAgP,EAAkB,IACd,IAAA/a,gBAAeiO,GAClB8M,EAAgB3K,KAAKnC,EAAsBA,EAAsBA,EAAsBA,OACjF,CACN8M,EAAgB3K,KAAI,MAApB2K,EAAwB9M,GACxB,IAAK,IAAItF,EAAIoS,EAAgB5Y,OAAQwG,EAAI,EAAGA,IAC3CoS,EAAgB3K,KAAK,E,CAGvBrE,KAAKgP,gBAAkBA,C,CAExB,OAAOA,CACR,E,gCAMA,YAAAC,MAAA,SAAM4G,QAAA,IAAAA,IAAAA,GAAA,GACC,MAAwD7V,KAAtDlD,EAAI,OAAEoU,EAAS,YAAEhC,EAAc,iBAAE5J,EAAU,aAAEhO,EAAI,OAC9B4Z,EAAS,gBAChBpW,QAAQmG,IAAI,6BAAsBnE,EAAI,OAE1D,IAAM2I,EAAUyL,EAAUlO,wBAAwB1L,GAClDmO,EAAQ2H,WAAW,UAAW8B,GAC9BlP,KAAKuV,uBAEL,IADA,IAAMO,EAAWD,EAAoBvQ,EAAa,EACzCpM,EAAI,EAAGA,EAAI4c,EAAU5c,IAE7BgY,EAAU1L,KAAK,CACdC,QAAO,EACPG,OAAQ5F,OAGN6V,GAAmB7V,KAAKuF,sBAC7B,EAEQ,YAAAwQ,gBAAR,WACO,MAAgD/V,KAA9C8E,EAAK,QAAEC,EAAM,SAAEmM,EAAS,YAAEjI,EAAe,kBAC3C+M,EAAehW,KAAI,WACjBM,EAAO4Q,EAAS,IAGxB,IAAAhI,iBAAgBgI,EAAWlR,KAAMiJ,GAE7B,MAAwDjJ,KAAtDmT,EAAc,iBAAED,EAAO,UAAED,EAAS,YAAE1K,EAAa,gBACvD,OAAQA,GACP,KAAK,EAAAyJ,gBACajS,IAAbO,EAAGuJ,OAENsJ,EAAiB,EACjBF,EAAY3S,EAAG2V,KACf/C,EAAU5S,EAAGuJ,MACbmM,EAAaA,GAAc,IAAIlS,aAAagB,EAAQC,EAASoO,IAE7D6C,EAAaA,GAAc,IAAI1E,YAAYxM,EAAQC,EAASoO,GAI7D,MACD,KAAK,EAAAtJ,MAGJsJ,EAAiB,EACjBF,EAAY3S,EAAG2V,KACfD,EAAaA,GAAc,IAAIlS,aAAagB,EAAQC,EAASoO,GAC7D,MACD,KAAK,EAAA9B,cAiBL,KAAK,EAAAE,eAEJ4B,EAAiB,EACjBF,EAAa3S,EAA8B4V,aAC3ChD,EAAU5S,EAAGmR,aACbuE,EAAaA,GAAc,IAAI5E,YAAYtM,EAAQC,EAASoO,GAG5D,MACD,KAAK,EAAA1B,aAEJ0B,EAAiB,EACjBF,EAAa3S,EAA8B4V,aAC3CF,EAAaA,GAAc,IAAI5E,YAAYtM,EAAQC,EAASoO,GAG5D,MACD,KAAK,EAAAgD,KASL,KAAK,EAAAC,MAEJjD,EAAiB,EACjBF,EAAa3S,EAA8B4V,aAC3ChD,EAAU5S,EAAGmN,IACbuI,EAAaA,GAAc,IAAIhgB,WAAW8O,EAAQC,EAASoO,GAG3D,MACD,KAAK,EAAA1F,IAEJ0F,EAAiB,EACjBF,EAAa3S,EAA8B4V,aAC3CF,EAAaA,GAAc,IAAIhgB,WAAW8O,EAAQC,EAASoO,GAG3D,MACD,QACC,MAAM,IAAIjN,MAAM,mCAA4BqC,EAAa,sBAG3D,GADAvI,KAAKgW,WAAaA,GACd,IAAAK,aAAY/V,GACf,MAAO,CAAE2S,UAAS,EAAEC,QAAO,EAAE8C,WAAU,EAAE7C,eAAc,EAAE5K,cAAa,GAEtE,MAAM,IAAIrC,MAAM,yDAAkD5F,EAAGgW,uBAAuBhW,EAAGgJ,aAAY,KAE7G,EAEQ,YAAAiN,eAAR,SACCP,EACA7C,EACA5K,GAEM,MAAyCvI,KAAvC8E,EAAK,QAAEC,EAAM,SAAEG,EAAa,gBAAE5N,EAAI,OAEpCkf,GAAiBxW,KAAK8R,QAAU9R,KAAK8R,QAAUhN,EAAQC,GAAUG,EAGjEuR,EAA0BlO,IAAkB,EAAAyJ,YAAcgE,EAAW/O,cAAgBqK,YACrFoF,EAAsB1W,KAAI,kBAC5ByW,IAA4BC,IAC/BA,EAAoB,IAAIthB,SAAU4gB,EAA2BzS,QAC7DvD,KAAK0W,kBAAoBA,GAKtBV,EAAW5f,SAAWogB,IAAiB,IAAAG,yBAAwBrf,GAAM,KAAU0e,EAAW/O,YAC7FjH,KAAK4W,QAAUZ,EACJhW,KAAK4W,UAAS5W,KAAK4W,QAAU3R,EAAS4R,iBAAiBvf,EAAMkf,GAAe,IAChF,IAAAI,EAAY5W,KAAI,QAGxB,GAAI0W,GAAqBE,IAAYZ,GAAc9Q,IAAkBiO,EACpE,IAAK,IAAIja,EAAI,EAAG,EAAS4L,EAAQC,EAAQ7L,EAAI,EAAQA,IAAK,CACzD,IAAM4d,EAAS5d,EAAIia,EACb4D,EAAS7d,EAAIgM,EACnB,GAAI6R,GAAUP,EAAe,MAC7B,IAAK,IAAI5Z,EAAI,EAAGA,EAAIsI,EAAetI,IAEjCga,EAAQG,EAASna,GADd8Z,GACmB,IAAAM,YAAWN,EAAmB,GAAKI,EAASla,IAAI,GAEhDoZ,EAAWc,EAASla,E,CAK9C,OAAOga,CACR,EAMA,YAAAK,UAAA,WACO,MAA+BjX,KAA7B8E,EAAK,QAAEC,EAAM,SACbzE,EADwB,YACR,GAClB,EAAoEN,KAAK+V,kBAAvE9C,EAAS,YAAEC,EAAO,UAAE8C,EAAU,aAAE7C,EAAc,iBAAE5K,EAAa,gBAGrE,OADAjI,EAAG4W,WAAW,EAAG,EAAGpS,EAAOC,EAAQkO,EAAWC,EAAS8C,GAChDhW,KAAKuW,eAAeP,EAAY7C,EAAgB5K,EACxD,EAOM,YAAA4O,eAAN,W,oHAGC,OAFQrS,GAAF,EAA+B9E,MAAxB,MAAE+E,EAAM,SAAEmM,EAAS,YACxB5Q,EAAiB4Q,EAAS,GAATA,EAAS,UAK5B,EAAoElR,KAAK+V,kBAAvE9C,EAAS,YAAEC,EAAO,UAAE8C,EAAU,aAAE7C,EAAc,iBAAE5K,EAAa,gBAErE,IAAM,IAAA6O,iBAAgB9W,EAA8B,EAAG,EAAGwE,EAAOC,EAAQkO,EAAWC,EAAS8C,KAJrF,CAAP,EAAOhW,KAAKiX,a,OAKb,OADA,SACO,CAAP,EAAOjX,KAAKuW,eAAeP,EAAY7C,EAAgB5K,I,QAGhD,YAAA8O,wBAAR,SAAgCC,GAC/B,IAAMvG,EAAS/Q,KAAKiX,YACd,EAAyCjX,KAAvC8E,EAAK,QAAEC,EAAM,SAAEG,EAAa,gBAAE5N,EAAI,OAE1CggB,EAAaA,IACVhgB,IAAS,EAAAuS,OAASvS,IAAS,EAAA0a,WAAc,IAAM,GAElD,IAAM3R,EAASvE,SAASe,cAAc,UACtCwD,EAAOyE,MAAQA,EACfzE,EAAO0E,OAASA,EAKhB,IAJA,IAAMxE,EAAUF,EAAOK,WAAW,MAC5B6W,EAAYhX,EAAQiX,aAAa,EAAG,EAAG1S,EAAOC,GAC9CxB,EAASgU,EAAUnf,KAEhBqX,EAAI,EAAGA,EAAI1K,EAAQ0K,IAC3B,IAAK,IAAID,EAAI,EAAGA,EAAI1K,EAAO0K,IAAK,CAG/B,IAFA,IAAMgG,EAAQ/F,EAAI3K,EAAQ0K,EACpBiI,GAAgB1S,EAAS,EAAI0K,GAAK3K,EAAQ0K,EACvCtW,EAAI,EAAGA,EAAIgM,EAAehM,IAClCqK,EAAO,EAAIkU,EAAeve,GAAK6X,EAAO7L,EAAgBsQ,EAAQtc,GAAKoe,EAE9C,IAAlBpS,IAEH3B,EAAO,EAAIkU,EAAe,GAAKlU,EAAO,EAAIkU,GAC1ClU,EAAO,EAAIkU,EAAe,GAAKlU,EAAO,EAAIkU,IAEvCvS,EAAgB,IACnB3B,EAAO,EAAIkU,EAAe,GAAK,I,CAKlC,OADAlX,EAAQmX,aAAaH,EAAW,EAAG,GAC5BlX,CACR,EAOA,YAAAsX,SAAA,SAASzZ,GAGR,GAAIA,EAAQ,CACX,IACM0B,EAAOnK,OAAOmK,KAAK1B,IACzB,IAAA2B,gBAAeD,EAFG,CAAC,cAEa,4B,CAEjC,IAAMS,EAASL,KAAKqX,wBAAwBnZ,GAAUA,EAAOoZ,YACvDhD,EAAQ,IAAIC,MAElB,OADAD,EAAMzV,IAAMwB,EAAOuX,YACZtD,CACR,EAUA,YAAA3E,QAAA,SAAQzR,QAAA,IAAAA,IAAAA,EAAA,IAMP,IACM0B,EAAOnK,OAAOmK,KAAK1B,IACzB,IAAA2B,gBAAeD,EAFG,CAAC,WAAY,MAAO,aAAc,YAEpB,4BAExB,IAAA9C,EAASkD,KAAI,KACf6P,EAAW3R,EAAO2R,UAAY,EAAAvT,OAC9BsT,EAAW1R,EAAO0R,UAAY9S,EAErBkD,KAAKqX,wBAAwBnZ,EAAOoZ,YAC5CxH,QAAO,SAACxZ,GACTA,EAID4H,EAAO3H,KACV,IAAAF,eAAcC,EAAM4H,EAAO3H,KAAKwZ,MAAK,SAACzZ,GACrCuZ,EAASvZ,EAAM,UAAGsZ,EAAQ,QAC3B,IAEAC,EAASvZ,EAAM,UAAGsZ,EAAQ,SAR1B9U,QAAQC,KAAK,4CAAqC+B,EAAI,2BAUxD,GAAG,YACJ,EAMA,YAAA+a,qBAAA,SAAqBnQ,GACd,MAAgD1H,KAA9CkR,EAAS,YAAE5L,EAAU,aAAE4B,EAAY,eAAEpK,EAAI,OACzCiG,EAAuBmO,EAAS,eAAhB5Q,EAAO4Q,EAAS,GACxC,IAAKnO,EACJ,MAAM,IAAImD,MAAM,+CAIjB,GAAIZ,EAAa,EAChB,MAAM,IAAIY,MAAM,oBAAapJ,EAAI,0PAElC,IAAMgb,EAA0B/U,EAAegV,WAAWC,IAAItQ,GAC9DpH,EAAG2X,cAAcH,EAAwBI,gBACzCJ,EAAwBI,eAAiBhR,EAAaQ,QACtDoQ,EAAwBK,aAAc,CACvC,EAMQ,YAAAvC,gBAAR,WACO,IAAE1E,EAAwBlR,KAAf,UAAE4R,EAAa5R,KAAL,SACnBM,EAAO4Q,EAAS,GACxBU,EAASf,SAAQ,SAAAnJ,GAChBpH,EAAG2X,cAAcvQ,IACjB,IAAA0Q,qBAAoB9X,EAAIoH,EACzB,IACAkK,EAASxb,OAAS,SAIX4J,KAAKyU,iBACb,EAOA,YAAAzP,MAAA,SAAMlI,GAEL,OAAOkD,KAAKkR,UAAUxM,eAAe1E,KAAMlD,EAC5C,EAKA,YAAA6T,QAAA,WACO,IAAE7T,EAAoBkD,KAAhB,KAAEkR,EAAclR,KAAL,UACfM,EAAuB4Q,EAAS,GAIxC,GAJ+BA,EAAS,gBAEpBpW,QAAQmG,IAAI,iCAA0BnE,EAAI,QAEzDwD,EAAI,MAAM,IAAI4F,MAAM,iFAEzBlG,KAAK4V,yBAEE5V,KAAK4R,gBAEL5R,KAAKkR,UAERlR,KAAK4W,gBAAgB5W,KAAK4W,QAC1B5W,KAAKgW,mBAAmBhW,KAAKgW,UAClC,EAsFD,EAjnCA,GAAa,EAAA/Q,SAAAA,C,0KCxDb,aACA,SACA,SAkCA,SACA,SASA,SAEA,SACA,SASMoT,EAAU,CACfC,aAAc,CAAC,EACfC,kBAAmB,CAAC,GAyIrB,SAAgBC,EACf9V,EACApL,GAEQ,IAAA4J,EAA0BwB,EAAQ,YAArB1B,EAAa0B,EAAQ,SAE1C,OAAIxB,IAAgB,EAAAC,QAASH,KAStB1J,IAAS,EAAA+Z,eAAiB/Z,IAAS,EAAA6e,MAAQ7e,IAAS,EAAA8e,OAAS9e,IAAS,EAAAmW,KAAOnW,IAAS,EAAAia,gBAAkBja,IAAS,EAAAma,aACzH,CA+RA,SAAgBgH,EACf/V,EACAgQ,GAEQ,IAAApS,EAA8BoC,EAAQ,GAAlCxB,EAA0BwB,EAAQ,YAArB1B,EAAa0B,EAAQ,SAGxCO,EAAM,UAAGjC,EAAQ,YAAI0R,EAAY,YAAIxR,IAAgB,EAAAC,MAAQ,IAAM,KACzE,QAAkCpB,IAA9BsY,EAAQC,aAAarV,GACxB,OAAOoV,EAAQC,aAAarV,GAG7B,IAAMyE,EAAUpH,EAAGyU,gBACnB,IAAKrN,EAEJ,OADA2Q,EAAQC,aAAarV,IAAO,EACrBoV,EAAQC,aAAarV,GAE7B3C,EAAGkH,YAAYlH,EAAGmH,WAAYC,GAG9B,IAAMgM,EAAOpT,EAAG,EAAA+R,eACVlN,EAAS7E,EAAG,EAAA2R,SAKlB3R,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG4U,eAAgBxB,GACnDpT,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG6U,eAAgBzB,GACnDpT,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG8U,mBAAoBjQ,GACvD7E,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG+U,mBAAoBlQ,GAEjD,MAAyC,EAAAF,SAAS2N,uBAAuB,CAC9ElQ,SAAQ,EACR5F,KAAM,mBACNoI,cAAe,EACfwN,aAAY,IAJLI,EAAgB,mBAAED,EAAQ,WAAElE,EAAM,SAM1CrO,EAAGgV,WAAWhV,EAAGmH,WAAY,EAAGqL,EAblB,GACC,GAYkD,EAAGD,EAAUlE,EAAQ,MAGtF,IAAM+J,EAAcpY,EAAGqY,oBACvB,IAAKD,EAIJ,OAFApY,EAAG2X,cAAcvQ,GACjB2Q,EAAQC,aAAarV,IAAO,EACrBoV,EAAQC,aAAarV,GAE7B3C,EAAG+I,gBAAgB/I,EAAGgJ,YAAaoP,GAEnCpY,EAAGsY,qBAAqBtY,EAAGgJ,YAAahJ,EAAG0I,kBAAmB1I,EAAGmH,WAAYC,EAAS,GAEtF,IAAMmR,EAAcvY,EAAGgW,uBAAuBhW,EAAGgJ,eAAiBhJ,EAAGwY,qBAOrE,OAJAxY,EAAG2X,cAAcvQ,GACjBpH,EAAGyY,kBAAkBL,GAErBL,EAAQC,aAAarV,GAAO4V,EACrBR,EAAQC,aAAarV,EAC7B,CASA,SAAgB+V,EACftW,EACAgQ,EACAvN,EACAuO,G,MAEQpT,EAA4EoC,EAAQ,GAAhFxB,EAAwEwB,EAAQ,YAAnErB,EAA2DqB,EAAQ,aAArDnB,EAA6CmB,EAAQ,eAArCzC,EAA6ByC,EAAQ,eAArB1B,EAAa0B,EAAQ,SAGtFO,EAAM,UAAGjC,EAAQ,YAAI0R,EAAY,YAAIvN,EAAM,YAAIuO,EAAI,YAAIxS,IAAgB,EAAAC,MAAQ,IAAM,KAC3F,QAAuCpB,IAAnCsY,EAAQE,kBAAkBtV,GAC7B,OAAOoV,EAAQE,kBAAkBtV,GAGlC,IAAMyE,EAAUpH,EAAGyU,gBACnB,IAAKrN,EAEJ,OADA2Q,EAAQE,kBAAkBtV,IAAO,EAC1BoV,EAAQE,kBAAkBtV,GAElC3C,EAAGkH,YAAYlH,EAAGmH,WAAYC,GAE9B,IAAMuR,EAAS3Y,EAAGoT,GACZwF,EAAW5Y,EAAG6E,GAKpB7E,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG4U,eAAgB+D,GACnD3Y,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG6U,eAAgB8D,GACnD3Y,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG8U,mBAAoB8D,GACvD5Y,EAAG2U,cAAc3U,EAAGmH,WAAYnH,EAAG+U,mBAAoB6D,GAWvD,IATM,MAAwD,EAAAjU,SAAS2N,uBAAuB,CAC7FlQ,SAAQ,EACR5F,KAAM,iBACNoI,cATqB,EAUrBwN,aAAY,IAJLI,EAAgB,mBAAED,EAAQ,WAAElE,EAAM,SAAEoE,EAAa,gBAOnDhC,EAAS,CAAC,EAAG,KAAM,KAAM,KAAM,KAAO,KAAM,GAAI,KAAM,IACxDoI,EAAc,EAAAlU,SAAS4R,iBAAiBnE,EAAc3B,EAAO3a,OAAS2c,GAAe,GAChF7Z,EAAI,EAAGA,EAAI6X,EAAO3a,OAAQ8C,IAClCigB,EAAYjgB,EAAI6Z,GAAiBhC,EAAO7X,GACxC6X,EAAO7X,GAAKigB,EAAYjgB,EAAI6Z,GAE7B,GAAIL,IAAiB,EAAAV,WAAY,CAEhC,IAAMoH,EAAgB,IAAI9H,YAAY6H,EAAY/iB,QAC5CijB,EAAe,IAAIjkB,SAASgkB,EAAc7V,QAChD,IAASrK,EAAI,EAAGA,EAAIigB,EAAY/iB,OAAQ8C,KACvC,IAAAogB,YAAWD,EAAa,EAAIngB,EAAGigB,EAAYjgB,IAAI,GAEhDigB,EAAcC,C,CAEf9Y,EAAGgV,WAAWhV,EAAGmH,WAAY,EAAGqL,EA9BlB,EACC,EA6BkD,EAAGD,EAAUlE,EAAQwK,GAItF,IAAMvT,EAAS,IAAI,EAAAX,SAASvC,EAAU,CACrC5F,KAAM,kCACNxF,KAAMob,EACNxN,cAnCqB,EAoCrBN,WAAY,CAtCC,EACC,GAsCdQ,MAAO,EAAAiN,cACPhN,MAAO,EAAAgN,cACPlN,OAAQ,EAAA8M,UAGHsH,EAASpU,IAAW,EAAA+M,OAAS,GAAM,EAEnCjM,EAAc,yBAChBuT,EAAuB,oWAkBvBtY,IAAgB,EAAAC,QACnBqY,GAAuB,IAAAC,8BAA6BD,EAAsBvT,GAAa,IAExF,IAAMyT,GAAiB,IAAApT,eACtBhG,EACAY,EACAG,EACAE,EACAiY,EACAlZ,EAAGqZ,gBACH1T,EACAhG,IAAc,GAEbsZ,OAAQ,eAAQA,EA9EJ,EA8EkB,aAAKA,EA7EtB,EA6EqC,QACjD,IAAAK,mBAAkBlH,GAAgB,cAAgB,IAAAmH,WAAUnH,GAAgB,YAAa,eAAiB,I,QAE5G3S,GACA,GAGD,SAAS+Z,EAAUC,EAAajlB,GAC/B,OAAI4e,IAAS,EAAArB,cAAsB3Z,KAAK5D,IAAI,EAAG4D,KAAK7D,IAAIC,EAAM,EAAGilB,KACzDA,EAAMjlB,GAAOA,CACtB,CAEA,IAAMklB,EAAetX,EAASoD,iBAAiB,EAAAlH,qBAAsB,GAAI,CAAC,EAAGqH,GAC7E,GAAI+T,GAAgBN,EAAgB,CACnC,IAAMjU,GAAU,IAAAwU,eAAc3Z,EAAI0Z,EAAcN,EAAgBzT,EAAahG,GAC7E,GAAIwF,EAAS,CAEZG,EAAO+C,kBAAiB,IACxB,IAAAO,iBAAgBxG,EAAUkD,EAAQA,EAAOqD,iBACzC3I,EAAG8I,SAAS,EAAG,EAjGH,EACC,GAiGb9I,EAAG+G,WAAW5B,GAEdnF,EAAGgH,cAAchH,EAAGiH,UACpBjH,EAAGkH,YAAYlH,EAAGmH,WAAYC,GAE9BpH,EAAG4Z,WAAW5Z,EAAG6Z,mBAAmB1U,EAAS,iBAAkB,CAAC,EAAG,IACnEnF,EAAG4Z,WAAW5Z,EAAG6Z,mBAAmB1U,EAAS,uBAAwB,CAAC,EAAG,IACzEnF,EAAG0B,WAAW1B,EAAG2B,aAAcS,EAASiB,2BACxCjB,EAASwH,sBAAsBzE,EAASQ,GAGxC3F,EAAGuK,WAAWvK,EAAGwK,eAAgB,EAAG,GACpCxK,EAAGkB,QAAQlB,EAAGyH,OAKd,IAHA,IAAMqS,EAAWxU,EAAOqR,YACpBoD,GAAY,EACVC,GAAM,IAAAT,WAAUnH,GAAgB,EAAKA,IAAiB,EAAAV,WAAa,IAAO,KACvExC,EAAI,EAAGA,EAnHJ,EAmHeA,IAC1B,IAAK,IAAIC,EAAI,EAAGA,EAnHJ,EAmHgBA,IAAK,CAChC,IAAI8K,OAAQ,EACZ,GAAIpV,IAAW,EAAA+M,OACdqI,GAAYxJ,EAvHH,EAuHUtB,EAAYD,GAC9BuB,EAxHQ,EAwHDtB,EAAYqK,EAAUtK,EAAI,EAxHzB,IAyHRuB,EAzHQ,EAyHD+I,EAAUrK,EAAI,EAxHZ,GAwHiCD,GAC1CuB,EA1HQ,EA0HD+I,EAAUrK,EAAI,EAzHZ,GAyHiCqK,EAAUtK,EAAI,EA1HhD,KA0H8D,MACjE,CACN,IAAMgL,EAAKV,EAAUtK,EAAI+J,EA5HhB,GA8HTgB,EAAWxJ,EA9HF,EA6HE+I,EAAUrK,EAAI8J,EA5Hf,GA6HqBiB,E,CAE1BthB,EAhII,EAgIAuW,EAAYD,EACtB,GAAI9W,KAAK+c,KAAK8E,EAAWH,EAASlhB,IAAMqhB,GAAYD,EAAK,CACxDD,GAAY,EACZ,K,EAIHhC,EAAQE,kBAAkBtV,GAAOoX,EAEjC/Z,EAAGma,cAAchV,E,MAEjB4S,EAAQE,kBAAkBtV,IAAO,EAIlC3C,EAAG0Q,aAAa0I,E,MAEhBrB,EAAQE,kBAAkBtV,IAAO,EAKlC,OAFA2C,EAAO+K,UACPrQ,EAAG2X,cAAcvQ,GACV2Q,EAAQE,kBAAkBtV,EAClC,CA6GA,SAAgByX,EAAoBpjB,GAEnC,IAAIzC,GAAO8lB,IACP7lB,EAAM6lB,IACV,OAAOrjB,GACN,KAAK,EAAA+Z,cACJxc,EAAM,EAAA+lB,kBACN9lB,EAAM,EAAA+lB,kBACN,MACD,KAAK,EAAA1E,KACJthB,EAAM,EAAAimB,SACNhmB,EAAM,EAAAimB,SACN,MACD,KAAK,EAAAxJ,eACJ1c,EAAM,EAAAmmB,mBACNlmB,EAAM,EAAAmmB,mBACN,MACD,KAAK,EAAA7E,MACJvhB,EAAM,EAAAqmB,UACNpmB,EAAM,EAAAqmB,UACN,MACD,KAAK,EAAA1J,aACJ5c,EAAM,EAAAumB,iBACNtmB,EAAM,EAAAumB,iBACN,MACD,KAAK,EAAA5N,IACJ5Y,EAAM,EAAAymB,QACNxmB,EAAM,EAAAymB,QAGR,MAAO,CACN1mB,IAAG,EAAEC,IAAG,EAEV,CAlzBA,EAAAmQ,SAAS4R,iBAAmB,SAC3Bvf,EACAlB,EACAolB,GAEA,YAFA,IAAAA,IAAAA,GAAA,GAEO,KAAK,IAAA7E,yBAAwBrf,EAAMkkB,GAAnC,CAAwDplB,EAChE,EASA,EAAA6O,SAAS4M,iBAAmB,SAC3BrI,EACA1M,EACA4C,GAEA,IAAI,IAAA7L,UAAS2V,GAAiB,CAC7B,KAAK,IAAAnV,mBAAkBmV,GACtB,MAAM,IAAItD,MAAM,0BAAmBM,KAAKC,UAAU+C,GAAK,0BAAkB1M,EAAI,iCAE9E,IAAM,EAAS0M,EAWT,EAAQ9Q,KAAKC,KAAKD,KAAKiU,KAAK,IAC5B,EAASjU,KAAKC,KAAK,EAAS,GAElC,OADI+G,GAAgB5E,QAAQmG,IAAI,iBAAU,EAAK,aAAK,EAAM,oCAA4BuI,EAAI,yBAAiB1M,EAAI,OACxG,CAAEgI,MAAK,EAAEC,OAAM,EAAE3O,OAAM,E,CAE/B,IAAM0O,EAAS0E,EAAkB,GACjC,KAAK,IAAAnV,mBAAkByQ,GACtB,MAAM,IAAIoB,MAAM,yBAAkBM,KAAKC,UAAU3B,GAAM,0BAAkBhI,EAAI,iCAE9E,IAAMiI,EAAUyE,EAAkB,GAClC,KAAK,IAAAnV,mBAAkB0Q,GACtB,MAAM,IAAImB,MAAM,0BAAmBM,KAAKC,UAAU1B,GAAO,0BAAkBjI,EAAI,iCAEhF,MAAO,CAAEgI,MAAK,EAAEC,OAAM,EACvB,EAMA,EAAAE,SAASwO,wBAA0B,SAClCvV,GAQQ,IAAAwE,EAAiDxE,EAAM,SAA7CwV,EAAuCxV,EAAM,KAAvCkV,EAAiClV,EAAM,eAAvBwU,EAAiBxU,EAAM,aAG/D,OAAIwV,IAAS,EAAArB,eAKT2G,EAAetW,EAAUgQ,EAAcU,EAAgBM,GAJnDA,EAQD,EAAArB,aASR,EAMC,EAAApN,SAASoO,0BAA4B,SACrCnV,GASM,IAAAiH,EAAWjH,EAAM,OACvB,GAAIiH,IAAW,EAAA8M,QAEd,OAAO9M,EAGA,IAAAzC,EAA+CxE,EAAM,SAA3CwU,EAAqCxU,EAAM,aAA7BkH,EAAuBlH,EAAM,MAAtBmH,EAAgBnH,EAAM,MAAfpB,EAASoB,EAAM,KAEzDwU,IAAiB,EAAAV,eACF,IAAAnQ,cAAaa,EAAU,EAAA+Y,+BAA+B,KACpE,IAAA5Z,cAAaa,EAAU,EAAAgZ,0BAA0B,KAClC1C,EAAetW,EAAUgQ,EAAcvN,EAAQC,IAAW4T,EAAetW,EAAUgQ,EAAcvN,EAAQE,KAC3HvK,QAAQC,KAAK,wCAAiCoK,EAAM,+BAAuBuN,EAAY,sBAActN,EAAK,aAAKC,EAAK,4DAAoDvI,EAAI,kBAAUqI,EAAM,kCAC5LA,EAAS,EAAA8M,UAELS,IAAiB,EAAA7I,SACJ,IAAAhI,cAAaa,EAAU,EAAAgZ,0BAA0B,IAChD1C,EAAetW,EAAUgQ,EAAcvN,EAAQC,IAAW4T,EAAetW,EAAUgQ,EAAcvN,EAAQE,KAC3HvK,QAAQC,KAAK,wCAAiCoK,EAAM,+BAAuBuN,EAAY,sBAActN,EAAK,aAAKC,EAAK,4DAAoDvI,EAAI,kBAAUqI,EAAM,kCAC5LA,EAAS,EAAA8M,UAGX,OAAO9M,CACR,EAMA,6BAsBA,EAAAF,SAAS2N,uBAAyB,SACjC1U,GAOQ,IAGJyQ,EACHkE,EACAC,EACAC,EANOrQ,EAAgDxE,EAAM,SAA5CpB,EAAsCoB,EAAM,KAAtCgH,EAAgChH,EAAM,cAAvBwU,EAAiBxU,EAAM,aACtDoC,EAA8BoC,EAAQ,GAAlCxB,EAA0BwB,EAAQ,YAO9C,GAPsCA,EAAQ,SAOhC,CAab,GAZAqQ,EAAgB7N,EASM,IAAlBA,IACH6N,EAAgB,GAEbL,IAAiB,EAAA7I,OAAS6I,IAAiB,EAAAV,WAG9C,OAAQe,GACP,KAAK,EACJF,EAAYvS,EAA8Bqb,IAC1C,MACD,KAAK,EACJ9I,EAAYvS,EAA8Bsb,GAC1C,MAID,KAAK,EACJ/I,EAAWvS,EAAG2V,KACd,MACD,QACC,MAAM,IAAI/P,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,YAKnF,OAAQiW,GACP,KAAK,EACJF,EAAYvS,EAA8Bub,YAC1C,MACD,KAAK,EACJhJ,EAAYvS,EAA8Bwb,WAC1C,MAID,KAAK,EACJjJ,EAAYvS,EAA8B4V,aAC1C,MACD,QACC,MAAM,IAAIhQ,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAGpF,OAAQ4V,GACP,KAAK,EAAAV,WAEJ,OADArD,EAAUrO,EAA8B0R,WAChCe,GACP,KAAK,EACJD,EAAoBxS,EAA8Byb,KAClD,MACD,KAAK,EACJjJ,EAAoBxS,EAA8B0b,MAClD,MAID,KAAK,EACJlJ,EAAoBxS,EAA8B2b,QAClD,MACD,QACC,MAAM,IAAI/V,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAEnF,MACD,KAAK,EAAA+M,MAEJ,OADA8E,EAAUrO,EAA8BuJ,MAChCkJ,GACP,KAAK,EACJD,EAAoBxS,EAA8B4b,KAClD,MACD,KAAK,EACJpJ,EAAoBxS,EAA8B6b,MAClD,MAID,KAAK,EACJrJ,EAAoBxS,EAA8B8b,QAClD,MACD,QACC,MAAM,IAAIlW,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAEnF,MACD,KAAK,EAAAuU,cAEJ,GADA1C,EAASrO,EAAG+Q,cACRnQ,IAAgB,EAAAE,OAASsR,IAAiB,EAAArB,cAC7CyB,EAAmBD,OAEnB,OAAQE,GACP,KAAK,EACJD,EAAoBxS,EAA8B+b,KAClD,MACD,KAAK,EACJvJ,EAAoBxS,EAA8Bgc,MAClD,MAID,KAAK,EACJxJ,EAAoBxS,EAA8Bic,QAClD,MACD,QACC,MAAM,IAAIrW,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAGpF,MACD,KAAK,EAAAqZ,KAEJ,OADAxH,EAASrO,EAAG6V,KACJpD,GACP,KAAK,EACJD,EAAoBxS,EAA8Bkc,IAClD,MACD,KAAK,EACJ1J,EAAoBxS,EAA8Bmc,KAClD,MAID,KAAK,EACJ3J,EAAoBxS,EAA8Boc,OAClD,MACD,QACC,MAAM,IAAIxW,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAEnF,MACD,KAAK,EAAAsZ,MAEJ,OADAzH,EAASrO,EAAG8V,MACJrD,GACP,KAAK,EACJD,EAAoBxS,EAA8Bqc,KAClD,MACD,KAAK,EACJ7J,EAAoBxS,EAA8Bsc,MAClD,MAID,KAAK,EACJ9J,EAAoBxS,EAA8Buc,QAClD,MACD,QACC,MAAM,IAAI3W,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAEnF,MACD,KAAK,EAAAyU,eAEJ,OADA5C,EAASrO,EAAGiR,eACJwB,GACP,KAAK,EACJD,EAAoBxS,EAA8Bwc,MAClD,MACD,KAAK,EACJhK,EAAoBxS,EAA8Byc,OAClD,MAID,KAAK,EACJjK,EAAoBxS,EAA8B0c,SAClD,MACD,QACC,MAAM,IAAI9W,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAEnF,MACD,KAAK,EAAA2Q,IAEJ,OADAkB,EAASrO,EAAGmN,IACJsF,GACP,KAAK,EACJD,EAAoBxS,EAA8B2c,KAClD,MACD,KAAK,EACJnK,EAAoBxS,EAA8B4c,MAClD,MAID,KAAK,EACJpK,EAAoBxS,EAA8B6c,QAClD,MACD,QACC,MAAM,IAAIjX,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAEnF,MACD,KAAK,EAAA2U,aAEJ,OADA9C,EAASrO,EAAGmR,aACJsB,GACP,KAAK,EACJD,EAAoBxS,EAA8B8c,MAClD,MACD,KAAK,EACJtK,EAAoBxS,EAA8B+c,OAClD,MAID,KAAK,EACJvK,EAAoBxS,EAA8Bgd,SAClD,MACD,QACC,MAAM,IAAIpX,MAAM,qCAA8B6M,EAAa,0BAAkBjW,EAAI,OAEnF,MACD,QACC,MAAM,IAAIoJ,MAAM,6BAAsBwM,EAAY,2BAAmB5V,EAAI,O,KAErE,CAEN,GAAIoI,EAAgB,GAAKA,EAAgB,EACxC,MAAM,IAAIgB,MAAM,qCAA8BhB,EAAa,0BAAkBpI,EAAI,OAQlF,OAHAiW,EAAgB,EAChBF,EAAWvS,EAAG2V,KACdnD,EAAmBxS,EAAG2V,KACdvD,GACP,KAAK,EAAA7I,MACJ8E,EAASrO,EAAGuJ,MACZ,MACD,KAAK,EAAAmI,WACJrD,EAAUrO,EAA8B0R,aAAc,IAAAnQ,cAAaa,EAAU,EAAA6a,wBAAwBC,eACrG,MAOD,QACC,MAAM,IAAItX,MAAM,6BAAsBwM,EAAY,wCAAgC5V,EAAI,O,CAKzF,QAAeiD,IAAX4O,QAAqC5O,IAAb8S,QAA+C9S,IAArB+S,EAAgC,CACrF,IAAM2K,EAAgB,GAItB,WAHe1d,IAAX4O,GAAsB8O,EAAcpZ,KAAK,eAC5BtE,IAAb8S,GAAwB4K,EAAcpZ,KAAK,iBACtBtE,IAArB+S,GAAgC2K,EAAcpZ,KAAK,oBACjD,IAAI6B,MAAM,wBAAiBwM,EAAY,+BAAuBxN,EAAa,qCAA6BuY,EAAcrnB,OAAS,EAAI,IAAM,GAAE,YAAIqnB,EAAc3jB,KAAK,MAAK,0BAAkBgD,EAAI,M,CAEpM,QAAsBiD,IAAlBgT,GAA+B7N,EAAgB,GAAKA,EAAgB,GAAK6N,EAAgB7N,EAC5F,MAAM,IAAIgB,MAAM,+BAAwB6M,EAAa,+BAAuB7N,EAAa,0BAAkBpI,EAAI,OAGhH,MAAO,CACN+V,SAAQ,EACRC,iBAAgB,EAChBnE,OAAM,EACNoE,cAAa,EAEf,EAMA,qBAoEA,mBAsLA,EAAA9N,SAAS0N,wBAA0B,SAClCzU,GAMQ,IAAAwE,EAAmBxE,EAAM,SAAfpB,EAASoB,EAAM,KACzB+B,EAA6ByC,EAAQ,eAArB1B,EAAa0B,EAAQ,SACrCpL,EAAS4G,EAAM,KACnBwU,EAAepb,EAkBnB,GAhBgBkhB,EAAyB9V,EAAUpL,KAE9Cob,IAAiB,EAAArB,eAAiBqB,IAAiB,EAAAyD,KAEtDzD,EAAe,EAAAV,YAKflX,QAAQC,KAAK,uBAAgB2X,EAAY,iEAAyD5V,EAAI,+LAEtG4V,EAAe,EAAA7I,QAKZ7I,EAgCE,CAEN,GAAI0R,IAAiB,EAAA7I,MAEpB,IADkB,IAAAhI,cAAaa,EAAU,EAAAgb,wBAAwB,GAMlDjF,EAAiB/V,EAAUgQ,KAExC5X,QAAQC,KAAK,oHAA6G+B,EAAI,OAC9H4V,EAAe,EAAAV,iBAPhBlX,QAAQC,KAAK,6FAAsF+B,EAAI,OACvG4V,EAAe,EAAAV,WAUjB,GAAIU,IAAiB,EAAAV,YAGC,IAAAnQ,cAAaa,EAAU,EAAAib,6BAA6B,KAIxE,IAAA9b,cAAaa,EAAU,EAAAgb,wBAAwB,GAGlCjF,EAAiB/V,EAAUgQ,KAIxC5X,QAAQC,KAAK,iEACbkF,EAAe,iE,KA/DH,CACd,GAAIyS,IAAiB,EAAA7I,MAGpB,IADkB,IAAAhI,cAAaa,EAAU,EAAAkb,mBAAmB,GAM7CnF,EAAiB/V,EAAUgQ,KAExC5X,QAAQC,KAAK,oHAA6G+B,EAAI,OAC9H4V,EAAe,EAAAV,iBAGhBlX,QAAQC,KAAK,6FAAsF+B,EAAI,OACvG4V,EAAe,EAAAV,WAIjB,GAAIU,IAAiB,EAAAV,YAEpB,IAAAnQ,cAAaa,EAAU,EAAA6a,wBAAwB,GAEjC9E,EAAiB/V,EAAUgQ,IAIxC5X,QAAQC,KAAK,gE,CAuChB,OAAO2X,CACR,EAMA,wBAuCA,EAAAzN,SAAS4P,sBAAwB,SAACd,EAAiC/M,GAC1D,IAAA9B,EAAuC8B,EAAK,cAA7BlC,EAAwBkC,EAAK,MAAtBjC,EAAiBiC,EAAK,OAAdlK,EAASkK,EAAK,KAC9C+L,EAAgB/L,EAAMmM,eACtBT,EAAe1L,EAAMuB,cACrBnS,EAAS4Q,EAAMnC,OAASmC,EAAM5Q,OAAS,KAG7C,GAAI2d,EAAM3d,SAAW0O,EAAQC,EAASG,KAChC9O,GAAWA,GAAW2d,EAAM3d,SAAWA,EAAS8O,GACpD,MAAM,IAAIgB,MAAM,+BAAwB6N,EAAM3d,OAAM,0BAAkB0G,EAAI,gBAAQ1G,EAAS,iBAAUA,EAAM,SAAU,GAAE,wBAAgB0O,EAAK,aAAKC,EAAM,gCAAwBG,EAAa,MAM9L,IAAI2Y,GAAiB,EACrB,OAAO9J,EAAM9M,aACZ,KAAK3R,MACJuoB,GAAiB,EACjB,MACD,KAAK/Z,aACJ+Z,EAAiBnL,IAAiB,EAAA7I,MAClC,MACD,KAAK5S,WACJ4mB,EAAiBnL,IAAiB,EAAArB,cAClC,MACD,KAAKyM,UACJD,EAAiBnL,IAAiB,EAAAyD,KAClC,MACD,KAAK7E,YASHuM,EAAiBnL,IAAiB,EAAAnB,eAEnC,MACD,KAAKwM,WACJF,EAAiBnL,IAAiB,EAAA0D,MAClC,MACD,KAAKhF,YACJyM,EAAiBnL,IAAiB,EAAAjB,aAClC,MACD,KAAKzb,WACJ6nB,EAAiBnL,IAAiB,EAAAjF,IAClC,MACD,QACC,MAAM,IAAIvH,MAAM,8BAAuB6N,EAAM9M,YAAYnK,KAAI,0BAAkBA,EAAI,iCAAyB,EAAAkhB,gBAAgBC,KAAI,SAAAhX,GAAe,OAAAA,EAAYnK,IAAZ,IAAkBhD,KAAK,MAAK,OAIvK,MAAe4gB,EAAoBhI,GAAjC7d,EAAG,MAAEC,EAAG,MAIVopB,EAAcpZ,EAAQC,EAASgO,EAC/BoL,EAAepK,EAAM3d,SAAW8nB,EAElCvI,EAAiB5B,EACrB,GAAI8J,GAAkBM,EAAc,CACnCxI,EAAiB,EAAA1Q,SAAS4R,iBAAiBnE,EAAcwL,GAIzD,IADA,IAAME,EAAQ1L,IAAiB,EAAAV,YAAc6L,EAAkB,IAAIzoB,SAASugB,EAAepS,QAAU,KAC5FrK,EAAI,EAAGmlB,EAAOtK,EAAM3d,OAAS8O,EAAehM,EAAImlB,EAAMnlB,IAC9D,IAAK,IAAI0D,EAAI,EAAGA,EAAIsI,EAAetI,IAAK,CACvC,IAAM0hB,EAAYvK,EAAM7a,EAAIgM,EAAgBtI,GACxC9I,EAAQwqB,EACRC,GAAU,EACVzqB,EAAQe,GACXf,EAAQe,EACR0pB,GAAU,GACAzqB,EAAQgB,IAClBhB,EAAQgB,EACRypB,GAAU,GAEPA,GACHzjB,QAAQC,KAAK,sCAA+BujB,EAAS,eAAOxqB,EAAK,0BAAkBgJ,EAAI,gCAAwB4V,EAAY,MAE5H,IAAM8C,EAAQtc,EAAI6Z,EAAgBnW,EAC9BwhB,GACH,IAAA9E,YAAW8E,EAAM,EAAI5I,EAAO1hB,GAAO,GAEnC6hB,EAAeH,GAAS1hB,C,EAM5B,OAAO6hB,CACR,C,4yBCx9BA,aA8BA,SAOA,SAQA,SASA,SACA,SAEA,aA8CC,WACCjT,EACAxE,GAFD,WApCQ,KAAAsgB,iBAAiD,CAAC,EAKzC,KAAAC,sBAA8C,CAAC,EAI/C,KAAAC,UAAyC,CAAC,EAK1C,KAAAC,UAA4C,CAAC,EAE7C,KAAAC,mBAAqB,IAAIlV,QAGvB,KAAAmV,wBAAuF,GA6BjG,IAAA/hB,GAAUoB,GAAU,CAAC,GAAE,KAC/B,IAAKwE,EACJ,MAAM,IAAIwD,MAAM,oCAA6BpJ,EAAI,uEAElD,IAAKoB,EACJ,MAAM,IAAIgI,MAAM,+EAEjB,KAAK,IAAA3Q,UAAS2I,GACb,MAAM,IAAIgI,MAAM,uGAAgGM,KAAKC,UAAUvI,GAAO,MAGvI,IAEM0B,EAAOnK,OAAOmK,KAAK1B,IACzB,IAAA2B,gBAAeD,EAHG,CAAC,OAAQ,iBAAkB,WAAY,wBAGzB,+BAAgC1B,EAAOpB,OACvE,IAAAgD,mBAAkBF,EAHG,CAAC,OAAQ,kBAGQ,+BAAgC1B,EAAOpB,MAErE,IAAA4c,EAAmDxb,EAAM,eAAzC4gB,EAAmC5gB,EAAM,SAA/B6gB,EAAyB7gB,EAAM,qBAGjE8B,KAAKkR,UAAYxO,EACjB1C,KAAKlD,KAAOA,EAGZ,IAAM0c,GAAuB,IAAAxkB,UAAS0kB,GACpCA,EACCA,EAA4B5f,KAAK,MAC9B,GAAuD,IAAAklB,0BAC5DxF,EAAsB9W,EAASxB,YAAapE,GADrCmiB,EAAY,eAAEC,EAAe,kBAAEC,EAAiB,oBAYxD,GATAnf,KAAKof,sBAAwBH,EAE7BC,EAAgBrO,SAAQ,SAAC/T,EAAM5D,GAC9B,EAAK2lB,wBAAwBxa,KAAK,CACjCvH,KAAI,EACJuiB,WAAY,EACZC,YAAapmB,GAEf,IACI8G,KAAKiH,cAAgBsY,GACpBJ,EAAmB,CACtBnf,KAAKyK,eAAiB,GACtB,IAAK,IAAIvR,EAAI,EAAGsmB,EAAcL,EAAkB/oB,OAAQ8C,EAAIsmB,EAAatmB,IACxE8G,KAAKyK,eAAepG,KAAK,IAAIob,EAAgB/c,EAAUxE,EAAQ,CAAEsb,qBAAsB2F,EAAkBjmB,K,EAMxG6lB,IACH/e,KAAKye,sBAAwB,EAAH,GAAQM,IAG/Brc,EAASxB,cAAgB,EAAAE,QAAU6d,EAAaS,SAAS,SAAUT,EAAaS,SAAS,SAAWT,EAAaS,SAAS,eACjH,IAAA7d,cAAaa,EAAU,EAAAid,0BAA0B,KACpD3f,KAAKzB,YAAc,sDAI7B,GAAIugB,EACH,IAAS5lB,EAAI,EAAGA,EAAI4lB,EAAS1oB,OAAQ8C,IAAK,CACnC,MAAwB4lB,EAAS5lB,GAA/B,EAAI,OAAEpF,EAAK,QAAEwD,EAAI,OACzB0I,KAAKoN,WAAW,EAAMtZ,EAAOwD,E,CAGhC,CAuiBD,OAjiBC,YAAAsoB,UAAA,SAAUb,GACD,IAAAN,EAA0Bze,KAAI,sBAGlC6f,GAAiB,EAOrB,GANApqB,OAAOmK,KAAKmf,GAAsBlO,SAAQ,SAAA5N,GACrCwb,EAAsBxb,KAAS8b,EAAqB9b,KACvD4c,GAAiB,EACjBpB,EAAsBxb,GAAO8b,EAAqB9b,GAEpD,IACK4c,EAAL,CAWA,IAVM,MAMF7f,KALHwe,EAAgB,mBAChBG,EAAS,YACTC,EAAkB,qBAClB1N,EAAS,YACTwN,EAAS,YAEFpe,EAAO4Q,EAAS,GAElB4O,EAAcrqB,OAAOmK,KAAK+e,GACvBzlB,EAAI,EAAG6mB,EAAcD,EAAY1pB,OAAQ8C,EAAI6mB,EAAa7mB,IAAK,CACvE,IACMuM,EAAUkZ,EADV1b,EAAM6c,EAAY5mB,IAExBoH,EAAGma,cAAchV,GACjBmZ,EAAmBoB,OAAOva,UACnBkZ,EAAU1b,E,CAGlB,IADA,IAAMgd,EAAqBxqB,OAAOmK,KAAK4e,GACvB0B,GAAPhnB,EAAI,EAAwB+mB,EAAmB7pB,QAAQ8C,EAAIgnB,EAAoBhnB,IAAK,CAC5F,IAAM+J,EAAMgd,EAAmB/mB,GAC/BoH,EAAG0Q,aAAawN,EAAiBvb,WAC1Bub,EAAiBvb,E,CAIzB,IADA,IAAM6b,EAAWrpB,OAAOsb,OAAO2N,GACfyB,GAAPjnB,EAAI,EAAiB4lB,EAAS1oB,QAAQ8C,EAAIinB,EAAajnB,IAC/D4lB,EAAS5lB,GAAGiE,SAAW,IAAIuM,QAG5B,GAAI1J,KAAKyK,eACH,CAAIvR,EAAI,EAAb,IAAK,IAAWsmB,EAAcxf,KAAKyK,eAAerU,OAAQ8C,EAAIsmB,EAAatmB,IAC1E8G,KAAKyK,eAAevR,GAAG0mB,UAAUb,EADgB3oB,CA/BxB,CAmC5B,EAOQ,YAAAgqB,mBAAR,SAA2BC,EAAoBC,GACtC,IAAA9B,EAAqBxe,KAAI,iBACjC,GAAIwe,EAAiB6B,GAEpB,OAAO7B,EAAiB6B,GAezB,IAZM,MAAiFrgB,KAA/EkR,EAAS,YAAEpU,EAAI,OAAEsiB,EAAqB,wBAAEX,EAAqB,wBAAElgB,EAAW,cAEjF+B,EAMG4Q,EAAS,GALZjR,EAKGiR,EAAS,eAJZxR,EAIGwR,EAAS,eAHZhQ,EAGGgQ,EAAS,YAFZ3P,EAEG2P,EAAS,eADZ7P,EACG6P,EAAS,aAGPtR,EAAOnK,OAAOmK,KAAK0gB,GAChBpnB,EAAI,EAAGA,EAAI0G,EAAKxJ,OAAQ8C,IAAK,CACrC,IAAM+J,EAAMrD,EAAK1G,GACjBulB,EAAsBxb,GAAOqd,EAA6Brd,E,CAGvDvD,GAAgB5E,QAAQmG,IAAI,oDAA6CnE,EAAI,0CAAkC0J,KAAKC,UAAUgY,KAClI,IAAMpY,GAAS,IAAAC,eACdhG,EACAY,EACAG,EACAE,EACA6d,EACA9e,EAAGqZ,gBACH7c,EACAmD,EACAwe,EACAlgB,EACyC,IAAzC9I,OAAOmK,KAAK4e,GAAkBpoB,QAE/B,GAAKiQ,EAKL,OADAmY,EAAiB6B,GAAcha,EACxBmY,EAAiB6B,GAJvBpgB,EAAe,4DAAqDnD,EAAI,MAK1E,EAMA,YAAAqK,oBAAA,SAAoBrK,EAA6BkJ,EAA8CN,GAK9F,IAJM,IAAEmZ,EAAuC7e,KAAhB,wBAAEkR,EAAclR,KAAL,UAEtCugB,EAAa,GACXC,EAAiD,CAAC,EAC/CtnB,EAAI,EAAG,EAAS2lB,EAAwBzoB,OAAQ8C,EAAI,EAAQA,IAAK,CACjE,IACA8N,EAAUtB,EADKmZ,EAAwB3lB,GAAE,YACd,MAElCiM,EAEG6B,EAAK,OAFA5B,EAEL4B,EAAK,MAFO3B,EAEZ2B,EAAK,MAFc1P,EAEnB0P,EAAK,KADRsM,EACGtM,EAAK,gBADSwM,EACdxM,EAAK,eADyB4M,EAC9B5M,EAAK,eACHyZ,EAAWrb,IAAUoO,EAAiB,EAAKpO,IAAU,EAAAsb,OAAS,EAAI,EAClEC,EAAWtb,IAAUuO,EAAiB,EAAKvO,IAAU,EAAAqb,OAAS,EAAI,EAClEE,EAAYzb,IAAWmO,EAAkB,EAAKnO,IAAW,EAAA+M,OAAS,EAAI,EAC5EqO,GAAc,aAAMrnB,EAAC,YAAIunB,EAAQ,YAAIE,EAAQ,YAAIC,GACjDJ,EAAyB,UAAG,EAAAK,kBAAgB,OAAG3nB,IAAO,UAAGunB,GACzDD,EAAyB,UAAG,EAAAM,kBAAgB,OAAG5nB,IAAO,UAAGynB,GACzDH,EAAyB,UAAG,EAAAO,kBAAgB,OAAG7nB,IAAO,UAAG0nB,GACrD1P,EAAUhQ,cAAgB,EAAAE,QAAS,IAAAyY,WAAUviB,KAChDkpB,EAAyB,UAAG,EAAAQ,oBAAkB,OAAG9nB,IAAO,I,CAG1D,IAAM6M,EAAWtQ,OAAOmK,KAAKoG,GAAwBiY,KAAI,SAAAhb,GAAO,iBAAIA,EAAG,YAAI+C,EAAuB/C,GAAlC,IAA0CnJ,OACpGmJ,EAAM,UAAGnG,GAAI,OAAGiJ,GAAQ,OAAGwa,GAGjC,GAAIvgB,KAAK2e,UAAU1b,GAAM,OAAOjD,KAAK2e,UAAU1b,GAGzC,MAA+CjD,KAA7C0e,EAAS,YAAEC,EAAS,YAAEC,EAAkB,qBACxCte,EAAuB4Q,EAAS,GAA5BjR,EAAmBiR,EAAS,eAElC8I,EAAe9I,EAAUpL,iBAAiBhJ,EAAMiJ,EAAUC,EAAwBhG,KAAKlD,MAC7F,QAAqBiD,IAAjBia,EAAJ,CAKA,IAAMN,EAAiB1Z,KAAKogB,mBAAmBG,EAAYC,GAC3D,QAAuBzgB,IAAnB2Z,EAAJ,CAKA,IAAMjU,GAAU,IAAAwU,eAAc3Z,EAAI0Z,EAAcN,EAAgB1Z,KAAKlD,KAAMmD,GAC3E,QAAgBF,IAAZ0F,EAGH,OAFAnF,EAAG0Q,aAAa0I,QAChBzZ,EAAe,kCAA2BgD,EAAG,6BAAqBjD,KAAKlD,KAAI,OAM5EwD,EAAG+G,WAAW5B,GAEd,IADA,IAAMwb,EAAexrB,OAAOmK,KAAK8e,GACjByB,GAAPjnB,EAAI,EAAiB+nB,EAAa7qB,QAAQ8C,EAAIinB,EAAajnB,IAAK,CACxE,IAAMgoB,EAAcD,EAAa/nB,GAC3BioB,EAAUzC,EAAUwC,GAClBptB,EAAgBqtB,EAAO,MAAhB7pB,EAAS6pB,EAAO,KAC/BnhB,KAAKohB,mBAAmB3b,EAASyb,EAAaptB,EAAOwD,E,CAKtD,OAFAqnB,EAAU1b,GAAOwC,EACjBmZ,EAAmBpkB,IAAIiL,EAASxC,GACzBwC,C,CAxBNxF,EAAe,0CAAmCsgB,EAAU,6BAAqBvgB,KAAKlD,KAAI,M,MAN1FmD,EAAe,wCAAiCnD,GAAI,OAAGiJ,EAAQ,6BAAqB/F,KAAKlD,KAAI,MA+B/F,EAMQ,YAAAskB,mBAAR,SACC3b,EACAyb,EACAptB,EACAwD,G,MAEQ4Z,EAAyBlR,KAAhB,UAAE0e,EAAc1e,KAAL,UACpBM,EAAoC4Q,EAAS,GAAzCjR,EAAgCiR,EAAS,eAI/CmQ,EAJsCnQ,EAAS,cAIrB,EAAA/P,MAE5BhE,EAAiC,QAAtB,EAAAuhB,EAAUwC,UAAY,eAAE/jB,SAAS6a,IAAIvS,GAEpD,QAAiB1F,IAAb5C,EAAwB,CAC3B,IAAMmkB,EAAYhhB,EAAG6Z,mBAAmB1U,EAASyb,GACjD,GAAkB,OAAdI,EAEH,YADAxmB,QAAQC,KAAK,kCAA2BmmB,EAAW,0BAAkBlhB,KAAKlD,KAAI,iKAAyJxF,EAAI,yBAAiBgJ,EAAG0U,WAAU,MAG1Q7X,EAAWmkB,EAGP5C,EAAUwC,IACbxC,EAAUwC,GAAa/jB,SAAS3C,IAAIiL,EAAStI,GAK9C,IAAMgkB,EAAU7gB,EAAGihB,WAAW9b,EAAStI,GACnCqkB,GAAU,EAuBd,GAtBIlqB,IAAS,EAAAmqB,iBAAmBnqB,IAAS,EAAAoqB,iBAAmBpqB,IAAS,EAAAqqB,iBAAmBrqB,IAAS,EAAAsqB,iBAC3F,IAAApsB,WAAU2rB,IAAYA,EAAQla,cAAgB3R,QAClDksB,GAAU,GAEDlqB,IAAS,EAAAuqB,kBAAoBvqB,IAAS,EAAAwqB,kBAAoBxqB,IAAS,EAAAyqB,kBAAoBzqB,IAAS,EAAA0qB,kBACrG,IAAA/tB,gBAAektB,IAAYA,EAAQla,cAAgBnD,eACvD0d,GAAU,GAEDlqB,IAAS,EAAA2qB,gBAAkB3qB,IAAS,EAAA4qB,gBAAkB5qB,IAAS,EAAA6qB,gBAAkB7qB,IAAS,EAAA8qB,gBAC/F,IAAAjuB,WAAUgtB,IAAYA,EAAQla,cAAgBjR,aAClDwrB,GAAU,GAEDlqB,IAAS,EAAA+qB,iBAAmB/qB,IAAS,EAAAgrB,iBAAmBhrB,IAAS,EAAAirB,iBAAmBjrB,IAAS,EAAAkrB,kBAClGnB,GAKO,IAAA5sB,sBAAqB0sB,IAAYA,EAAQla,cAAgBmK,cACpEoQ,GAAU,IAJL,IAAA/sB,sBAAqB0sB,IAAYA,EAAQla,cAAgBjR,aAC7DwrB,GAAU,IAMTA,EAEH,YADAvhB,EAAe,2BAAoBihB,EAAW,0BAAkBlhB,KAAKlD,KAAI,kEAA0DxF,EAAI,6DAAqD6pB,EAAQla,YAAYnK,KAAI,K,CAOtN,OAAQxF,GAIP,KAAK,EAAAmqB,gBACJnhB,EAAGmiB,UAAUtlB,EAAUrJ,EAAQ,EAAI,GACnC,MACD,KAAK,EAAA4tB,gBACJphB,EAAGoiB,UAAUvlB,EAAWrJ,EAAmB,GAAK,EAAI,EAAIA,EAAmB,GAAK,EAAI,GACpF,MACD,KAAK,EAAA6tB,gBACJrhB,EAAGqiB,UAAUxlB,EAAWrJ,EAAmB,GAAK,EAAI,EAAIA,EAAmB,GAAK,EAAI,EAAIA,EAAmB,GAAK,EAAI,GACpH,MACD,KAAK,EAAA8tB,gBACJthB,EAAGsiB,UAAUzlB,EAAWrJ,EAAmB,GAAK,EAAI,EAAIA,EAAmB,GAAK,EAAI,EAAIA,EAAmB,GAAK,EAAI,EAAIA,EAAmB,GAAK,EAAI,GACpJ,MACD,KAAK,EAAA+tB,iBACJvhB,EAAGuiB,UAAU1lB,EAAUrJ,GACvB,MACD,KAAK,EAAAguB,iBACJxhB,EAAG4Z,WAAW/c,EAAUrJ,GACxB,MACD,KAAK,EAAAiuB,iBACJzhB,EAAGwiB,WAAW3lB,EAAUrJ,GACxB,MACD,KAAK,EAAAkuB,iBACJ1hB,EAAGyiB,WAAW5lB,EAAUrJ,GACxB,MACD,KAAK,EAAAmuB,eACJ3hB,EAAGmiB,UAAUtlB,EAAUrJ,GACvB,MACD,KAAK,EAAAouB,eACJ5hB,EAAG0iB,WAAW7lB,EAAUrJ,GACxB,MACD,KAAK,EAAAquB,eACJ7hB,EAAG2iB,WAAW9lB,EAAUrJ,GACxB,MACD,KAAK,EAAAsuB,eACJ9hB,EAAG4iB,WAAW/lB,EAAUrJ,GACxB,MAED,KAAK,EAAAuuB,gBACAhB,EAAU/gB,EAA8B6iB,WAAWhmB,EAAUrJ,GAC5DwM,EAAGmiB,UAAUtlB,EAAUrJ,GAC5B,MACD,KAAK,EAAAwuB,gBACAjB,EAAU/gB,EAA8B8iB,YAAYjmB,EAAUrJ,GAC7DwM,EAAG0iB,WAAW7lB,EAAUrJ,GAC7B,MACD,KAAK,EAAAyuB,gBACAlB,EAAU/gB,EAA8B+iB,YAAYlmB,EAAUrJ,GAC7DwM,EAAG2iB,WAAW9lB,EAAUrJ,GAC7B,MACD,KAAK,EAAA0uB,gBACAnB,EAAU/gB,EAA8BgjB,YAAYnmB,EAAUrJ,GAC7DwM,EAAG4iB,WAAW/lB,EAAUrJ,GAC7B,MACD,QACC,MAAM,IAAIoS,MAAM,+BAAwB5O,EAAI,4BAAoB0I,KAAKlD,KAAI,OAE5E,EAMQ,YAAAymB,mBAAR,SAA2BzmB,EAAchJ,EAAqBwD,GACrD,IAAAonB,EAAc1e,KAAI,UAEpBmhB,EAAUzC,EAAU5hB,GAC1B,IAAKqkB,EAGJ,OADAzC,EAAU5hB,GAAQ,CAAEK,SAAU,IAAIuM,QAAW5V,OAAO,IAAAuB,SAAQvB,GAAUA,EAAmB2C,QAAU3C,EAAOwD,KAAI,IACvG,EAER,IAAMksB,EAAWrC,EAAQrtB,MAIzB,GAFAqtB,EAAQrtB,OAAQ,IAAAuB,SAAQvB,GAAUA,EAAmB2C,QAAU3C,GAE3D,IAAAuB,SAAQvB,GAAQ,CACnB,IAAK,IAAIoF,EAAI,EAAG,EAAUpF,EAAmBsC,OAAQ8C,EAAI,EAAQA,IAChE,GAAKpF,EAAmBoF,KAAQsqB,EAAsBtqB,GACrD,OAAO,EAGT,OAAO,C,CAER,OAAOpF,IAAU0vB,CAClB,EAQA,YAAApW,WAAA,SACCtQ,EACAhJ,EACAwD,G,MAEM,EAA+D0I,KAA7D2e,EAAS,YAAED,EAAS,YAAExN,EAAS,YAAE2N,EAAuB,0BACxDnf,EAAuBwR,EAAS,eAAhB5Q,EAAO4Q,EAAS,GAGxC,IAAI,IAAA7b,SAAQvB,IACKA,EAAmBsC,OACtB,EAAG,MAAM,IAAI8P,MAAM,kCAA4BpS,EAAmBgG,KAAK,MAAK,mCAA2BkG,KAAKlD,KAAI,+EAI9H,IAAI2mB,EAA6B,QAAf,EAAA/E,EAAU5hB,UAAK,eAAExF,KACnC,GAAIA,EAAM,CACT,IAAMob,GAAe,IAAAgR,6BAA4B5vB,EAAOwD,EAAMwF,EAAMkD,KAAKlD,MACzE,QAAoBiD,IAAhB0jB,EAA2BA,EAAc/Q,OAI5C,GAAI+Q,IAAgB/Q,EACnB,MAAM,IAAIxM,MAAM,mBAAYpJ,EAAI,6BAAqBkD,KAAKlD,KAAI,qCAA6B2mB,EAAW,oBAAY/Q,EAAY,K,CAIjI,QAAoB3S,IAAhB0jB,EACH,MAAM,IAAIvd,MAAM,oCAA6BpJ,EAAI,mGAIlD,GADgBkD,KAAKujB,mBAAmBzmB,EAAMhJ,EAAO2vB,GACrD,CAGA,IAAME,EAAiB9E,EAAwB+E,MAAK,SAACzC,GAAY,OAAAA,EAAQrkB,OAASA,CAAjB,IAC7D6mB,IAAkB,IAAAxvB,WAAUL,KAC/B6vB,EAAetE,WAAavrB,GAGzB4L,GAAgB5E,QAAQmG,IAAI,2BAAoBnE,EAAI,0BAAkBkD,KAAKlD,KAAI,sBAAc0J,KAAKC,UAAU3S,GAAM,MAItH,IADA,IAAM+vB,EAAepuB,OAAOmK,KAAK+e,GACxBzlB,EAAI,EAAG6mB,EAAc8D,EAAaztB,OAAQ8C,EAAI6mB,EAAa7mB,IAAK,CACxE,IAEMuM,EAAUkZ,EAFIkF,EAAa3qB,IAGjCoH,EAAG+G,WAAW5B,GACdzF,KAAKohB,mBAAmB3b,EAAS3I,EAAMhJ,EAAO2vB,E,CAK/C,GAAIzjB,KAAKyK,eACH,CAAIvR,EAAI,EAAb,IAAK,IAAWsmB,EAAcxf,KAAKyK,eAAerU,OAAQ8C,EAAIsmB,EAAatmB,IAC1E8G,KAAKyK,eAAevR,GAAGkU,WAAWtQ,EAAMhJ,EAAOwD,EADElB,CAvB/B,CA2BrB,EAMA,YAAAuR,6BAAA,SACClC,EACAC,GAEA,GAAqB,IAAjBA,EAAMtP,OAAV,CACA,IAAKqP,EACJ,MAAM,IAAIS,MAAM,8FAEX,IAAE0Y,EAAgD5e,KAA9B,mBAAE6e,EAA4B7e,KAAL,wBAEnD,IADoB4e,EAAmB5G,IAAIvS,GAE1C,MAAM,IAAIS,MAAM,2EAAoElG,KAAKlD,KAAI,OAI9F,IADA,IAAMgnB,EAAc,IAAIxuB,MAAMoD,KAAK5D,IAAI4Q,EAAMtP,OAAQyoB,EAAwBzoB,SAAS2tB,MAAM,GACnF7qB,EAAI,EAAG,EAAS2lB,EAAwBzoB,OAAQ8C,EAAI,EAAQA,IAAK,CACnE,MAA8B2lB,EAAwB3lB,GAApDmmB,EAAU,aAAEC,EAAW,cAC3BwE,EAAYzE,IAAe,EAE9BvkB,QAAQC,KAAK,wDAAiDskB,EAAU,4BAAoBrf,KAAKlD,KAAI,OAErGgnB,EAAYzE,GAAcC,C,CAInBpmB,EAAI,EAAb,IAAK,IAAW,EAASwM,EAAMtP,OAAQ8C,EAAI,EAAQA,IAAK,CAC/C,IAAA8N,EAAUtB,EAAMxM,GAAE,MAClB4L,EAAkBkC,EAAK,MAAhBjC,EAAWiC,EAAK,OACzBwO,EAAQsO,EAAY5qB,GAC1B,KAAIsc,EAAQ,GAAZ,CACQ,IAAArQ,EAA0E6B,EAAK,OAAvE5B,EAAkE4B,EAAK,MAAhE3B,EAA2D2B,EAAK,MAAzDsM,EAAoDtM,EAAK,gBAAxCwM,EAAmCxM,EAAK,eAAxB4M,EAAmB5M,EAAK,eACjFgd,EAAiB7e,IAAWmO,EAClC,GAAI0Q,GAAkB5e,IAAUoO,GAAkBnO,IAAUuO,EAAgB,CAC3E,IAAMqQ,EAAa,CAAC,GAAMnf,EAAO,GAAMC,GACjCmf,EAAgB,UAAG,EAAAC,2BAAyB,OAAG3O,GAUrD,GAT6BxV,KAAKujB,mBAAmBW,EAAeD,EAAY,EAAAnC,mBAE/E9hB,KAAKohB,mBACJ3b,EACAye,EACAD,EACA,EAAAnC,kBAGEkC,EAAgB,CACnB,IAAMpf,EAAa,CAACE,EAAOC,GACrBqf,EAAoB,UAAG,EAAAC,8BAA4B,OAAG7O,GAC3BxV,KAAKujB,mBAAmBa,EAAmBxf,EAAY,EAAAkd,mBAEvF9hB,KAAKohB,mBACJ3b,EACA2e,EACAxf,EACA,EAAAkd,iB,EAxBmB,C,CAzBM,CAuD/B,EAMA,YAAAlX,kBAAA,SACCnF,EACAyb,EACAptB,EACAwD,GAEA,IAAKmO,EACJ,MAAM,IAAIS,MAAM,mFAIjB,IAF+BlG,KAAI,mBACIgY,IAAIvS,GAE1C,MAAM,IAAIS,MAAM,2EAAoElG,KAAKlD,KAAI,OAE9F,IAAM4V,GAAe,IAAAgR,6BAA4B5vB,EAAOwD,EAAM4pB,EAAalhB,KAAKlD,MAIhFkD,KAAKohB,mBAAmB3b,EAASyb,EAAaptB,EAAO4e,EACtD,EAKA,YAAA/B,QAAA,WACO,MAAiE3Q,KAA/DkR,EAAS,YAAEsN,EAAgB,mBAAEG,EAAS,YAAEC,EAAkB,qBAC1Dte,EAAuB4Q,EAAS,GAGxC,GAH+BA,EAAS,gBAEpBpW,QAAQmG,IAAI,mCAA4BjB,KAAKlD,KAAI,QAChEwD,EAAI,MAAM,IAAI4F,MAAM,mFAqBzB,GAlBAzQ,OAAOsb,OAAO4N,GAAW9N,SAAQ,SAAApL,GAC5BA,IACHnF,EAAGma,cAAchV,GACjBmZ,EAAmBoB,OAAOva,GAE5B,IACAhQ,OAAOmK,KAAK+e,GAAW9N,SAAQ,SAAA5N,UACvB0b,EAAU1b,EAClB,IAGAxN,OAAOsb,OAAOyN,GAAkB3N,SAAQ,SAAAxK,GACvC/F,EAAG0Q,aAAa3K,EACjB,IACA5Q,OAAOmK,KAAK4e,GAAkB3N,SAAQ,SAAA5N,UAC9Bub,EAAiBvb,EACzB,IAEIjD,KAAKyK,eAAgB,CACxB,IAAK,IAAIvR,EAAI,EAAGsmB,EAAcxf,KAAKyK,eAAerU,OAAQ8C,EAAIsmB,EAAatmB,IAC1E8G,KAAKyK,eAAevR,GAAGyX,UAExB3Q,KAAKyK,eAAerU,M,QAEd4J,KAAKyK,sBAMLzK,KAAKkR,iBAELlR,KAAKlD,YAELkD,KAAKof,6BAELpf,KAAKye,6BAELze,KAAKzB,mBAELyB,KAAK0e,iBAEL1e,KAAK2e,iBAEL3e,KAAK4e,0BAEL5e,KAAKwe,wBAELxe,KAAK6e,uBACb,EACD,EAlqBA,GAAa,EAAAU,WAAAA,EAoqBb,kBACC,WACC7c,EACAxE,EAQAomB,GAVD,MAcC,YAAM5hB,EAAUxE,IAAO,KAEfsb,EAAyB8K,EAAmB,qB,OAEpD,EAAKlF,sBAAwB5F,E,CAC9B,CACD,OArB8B,OAqB9B,EArBA,CAA8B+F,E,sTC9tB9B,aACA,SAOA,SAOA,SAoMA,SAAgBpc,EAAgBT,EAAuBxE,GAM9C,IAAA5G,EAAgB4G,EAAM,KAAhBpK,EAAUoK,EAAM,MACxB2E,EAAY3E,EAAO2E,WAAa,GAChC0hB,GAAc,IAAAlvB,SAAQvB,GAAUA,EAAmBsC,OAAS,EAC5DouB,GAAY,IAAAC,iBAAgBntB,EAAMitB,GAClCrf,EAAgC,IAAhBqf,EAAoB,EAAIA,EACxCG,GAAa,IAAAD,iBAAgBntB,EAAM4N,GACnCpI,EAAOoB,EAAOpB,MAAQ,mBAAY0nB,EAAS,qBAAaD,GAC9D,OAAO,IAAI,EAAAhF,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,oBACR7W,EAAS,YAAI2hB,EAAS,0BAC1B3hB,EAAS,YAAI6hB,EAAU,uDAEbF,IAAcE,EAAaA,EAAa,GAAE,iBAExD5F,SAAU,CACT,CACChiB,KAAM,UACNhJ,MAAK,EACLwD,MAAM,IAAA4L,oBAAmB5L,EAAMoL,EAASxB,gBAI5C,CArNA,uBAA4BwB,EAAuBxE,GAK1C,IAAA5G,EAAS4G,EAAM,KACjB2E,EAAY3E,EAAO2E,WAAa,GAChC8hB,GAAW,IAAAF,iBAAgBntB,EAAM,GACjCwF,EAAOoB,EAAOpB,MAAO,gBAAQ,IAAAoG,oBAAmB5L,EAAMoL,EAASxB,aAAY,UACjF,OAAO,IAAI,EAAAqe,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,mCAER7W,EAAS,aAAI,IAAA+hB,mBAAkBttB,GAAK,mCACxCuL,EAAS,YAAI8hB,EAAQ,0EAIzB7F,SAAU,CACT,CACChiB,KAAM,UACNhJ,MAAO,EACPwD,KAAM,EAAAmW,OAIV,EAcC,4BAAiC/K,EAAuBxE,GAOhD,IAAA5G,EAAS4G,EAAM,KACjB2mB,EAAY3mB,EAAO2mB,WAAa,EAChChiB,EAAY3E,EAAO2E,WAAa,GAChCiiB,EAAa5mB,EAAO4mB,YAAc,OAClCH,GAAW,IAAAF,iBAAgBntB,EAAMwtB,EAAW1uB,QAC5C2uB,EAAyB,IAAIzvB,MAAMuvB,GACnC/nB,EAAOoB,EAAOpB,MAAQ,UAAG+nB,EAAS,qBAAY,IAAA3hB,oBAAmB5L,EAAMoL,EAASxB,aAAY,YAAI4jB,GACtG,OAAO,IAAI,EAAAvF,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,2BAEfqL,EAAuB9G,KAAI,SAAC+G,EAAI9rB,GAAM,wBAAW2J,EAAS,aAAI,IAAA+hB,mBAAkBttB,GAAK,4BAAoB4B,EAAC,IAApE,IAAyEY,KAAK,MAAK,iBACtH+I,EAAS,YAAI8hB,EAAQ,uDAEVI,EAAuB9G,KAAI,SAAC+G,EAAI9rB,GAAM,+BAAkBA,EAAC,mBAAW4rB,EAA9B,IAA4ChrB,KAAK,OAAM,QAE5GglB,SAAUiG,EAAuB9G,KAAI,SAAC+G,EAAI9rB,GACzC,MAAO,CACN4D,KAAM,iBAAU5D,GAChBpF,MAAOoF,EACP5B,KAAM,EAAAmW,IAER,KAEF,EAaC,2BAAgC/K,EAAuBxE,GAM/C,IAAA5G,EAAgB4G,EAAM,KAAhBpK,EAAUoK,EAAM,MACxB2E,EAAY3E,EAAO2E,WAAa,GAChC0hB,GAAc,IAAAlvB,SAAQvB,GAAUA,EAAmBsC,OAAS,EAC5DouB,GAAY,IAAAC,iBAAgBntB,EAAMitB,GAClCrf,EAAgC,IAAhBqf,EAAoB,EAAIA,EACxCG,GAAa,IAAAD,iBAAgBntB,EAAM4N,GACnC+f,GAAqB,IAAAC,wCAAuChgB,GAC5DpI,EAAOoB,EAAOpB,MAAQ,mBAAY0nB,EAAS,qBAAaD,GAC9D,OAAO,IAAI,EAAAhF,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,mCAER7W,EAAS,YAAI2hB,EAAS,8BACtB3hB,EAAS,aAAI,IAAA+hB,mBAAkBttB,GAAK,mCACxCuL,EAAS,YAAI6hB,EAAU,uDAEbF,IAAcE,EAAaA,EAAa,GAAE,6CAAqCO,EAAkB,QAE/GnG,SAAU,CACT,CACChiB,KAAM,UACNhJ,MAAO,EACPwD,KAAM,EAAAmW,KAEP,CACC3Q,KAAM,UACNhJ,MAAK,EACLwD,MAAM,IAAA4L,oBAAmB5L,EAAMoL,EAASxB,gBAI5C,EAaC,gCAAqCwB,EAAuBxE,GAMpD,IAAA5G,EAAgB4G,EAAM,KAAhBpK,EAAUoK,EAAM,MACxB2E,EAAY3E,EAAO2E,WAAa,GAChC0hB,GAAc,IAAAlvB,SAAQvB,GAAUA,EAAmBsC,OAAS,EAC5DouB,GAAY,IAAAC,iBAAgBntB,EAAMitB,GAClCrf,EAAgC,IAAhBqf,EAAoB,EAAIA,EACxCG,GAAa,IAAAD,iBAAgBntB,EAAM4N,GACnC+f,GAAqB,IAAAC,wCAAuChgB,GAC5DpI,EAAOoB,EAAOpB,MAAQ,mBAAY0nB,EAAS,qBAAaD,GAC9D,OAAO,IAAI,EAAAhF,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,mCAER7W,EAAS,YAAI2hB,EAAS,8BACtB3hB,EAAS,aAAI,IAAA+hB,mBAAkBttB,GAAK,mCACxCuL,EAAS,YAAI6hB,EAAU,uDAEbF,IAAcE,EAAaA,EAAa,GAAE,6CAAqCO,EAAkB,QAE/GnG,SAAU,CACT,CACChiB,KAAM,UACNhJ,MAAO,EACPwD,KAAM,EAAAmW,KAEP,CACC3Q,KAAM,UACNhJ,MAAK,EACLwD,MAAM,IAAA4L,oBAAmB5L,EAAMoL,EAASxB,gBAI5C,EAaA,oBA2CC,2BAAgCwB,EAAuBxE,GAO/C,IAAA5G,EAAS4G,EAAM,KACjB2E,EAAY3E,EAAO2E,WAAa,GAChCsiB,OAA6BplB,IAAnB7B,EAAOinB,QAAwB,EAAIjnB,EAAOinB,QACpDhY,EAAQjP,EAAOiP,OAAS,CAAC,EAAG,EAAG,GAC/BrQ,EAAOoB,EAAOpB,MAAQ,WACtB6nB,GAAW,IAAAF,iBAAgBntB,EAAM,GACvC,OAAO,IAAI,EAAAioB,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,oBACR7W,EAAS,mCACTA,EAAS,kCACbA,EAAS,YAAI8hB,EAAQ,uDAEXA,EAAQ,4BAEtB7F,SAAU,CACT,CACChiB,KAAM,UACNhJ,MAAOqZ,EACP7V,KAAM,EAAAuS,OAEP,CACC/M,KAAM,YACNhJ,MAAOqxB,EACP7tB,KAAM,EAAAuS,SAIV,EAUC,uBAA4BnH,EAAuBxE,GAGnD,OAAOiF,EAAgBT,EAAU,CAChCpL,KAAM,EAAAuS,MACN/V,MAAO,EACPgJ,KAAMoB,EAAOpB,MAEf,EAeC,4BAAiC4F,EAAuBxE,GAOhD,IAAA5G,EAAS4G,EAAM,KACjB2E,EAAY3E,EAAO2E,WAAa,GAEhC8hB,GAAW,IAAAF,iBAAgBntB,EADX,GAEhB8tB,GAAgB,IAAAX,iBAAgB,EAAA5a,MAFhB,GAGhBwb,GAAa,IAAAT,mBAAkBttB,GAC/BguB,EAAaF,IAAkBT,EAC/B7nB,EAAOoB,EAAOpB,MAAQ,oBAAa6nB,GACzC,OAAO,IAAI,EAAApF,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,qFAIR7W,EAAS,YAAIwiB,EAAU,8FAGNC,EAAa,GAAKF,EAAa,6EAGxDtG,SAAU,CACT,CACChiB,KAAM,UACNhJ,MAAO,EACPwD,KAAM,EAAAmW,KAEP,CACC3Q,KAAM,UACNhJ,WAAwBiM,IAAjB7B,EAAOqnB,MAAsBrnB,EAAOqnB,MAAQ,EACnDjuB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,YACNhJ,WAA0BiM,IAAnB7B,EAAOinB,QAAwBjnB,EAAOinB,QAAU,EACvD7tB,KAAM,EAAAuS,SAIV,EAiBC,kCAAuCnH,EAAuBxE,GAUtD,IAAA5G,EAAS4G,EAAM,KACjB2E,EAAY3E,EAAO2E,WAAa,GAChCiiB,EAAa5mB,EAAO4mB,YAAc,OAClC5f,EAAgB4f,EAAW1uB,OAC3BuuB,GAAW,IAAAF,iBAAgBntB,EAAM4N,GACjCkgB,GAAgB,IAAAX,iBAAgB,EAAA5a,MAAO3E,GACvCmgB,GAAa,IAAAT,mBAAkBttB,GAC/BguB,EAAaF,IAAkBT,EAC/B7nB,EAAOoB,EAAOpB,MAAQ,0BAAmB6nB,EAAQ,cAAMzf,EAAa,eAC1E,OAAO,IAAI,EAAAqa,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,yIAMR7W,EAAS,YAAIwiB,EAAU,kGAGiB,IAAlBngB,EAAsB,MAAQ,SAAQ,YAAIogB,EAAa,GAAKF,EAAa,kCAAyC,SAAfN,GAAwC,SAAfA,GAAwC,SAAfA,EAAwB,GAAK,WAAIA,GAAY,0GAIhOhG,SAAU,CACT,CACChiB,KAAM,UACNhJ,MAAO,EACPwD,KAAM,EAAAmW,KAEP,CACC3Q,KAAM,UACNhJ,WAAwBiM,IAAjB7B,EAAOqnB,MAAsBrnB,EAAOqnB,MAAQ,EACnDjuB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,YACNhJ,WAA0BiM,IAAnB7B,EAAOinB,QAAwBjnB,EAAOinB,QAAU,EACvD7tB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,aACNhJ,MAAOoK,EAAOsnB,UAAY,CAAC,EAAG,EAAG,GACjCluB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,aACNhJ,MAAOoK,EAAOunB,UAAY,CAAC,EAAG,EAAG,GACjCnuB,KAAM,EAAAuS,SAIV,EAmBC,wCAA6CnH,EAAuBxE,GAY5D,IAAA5G,EAAS4G,EAAM,KACjB2E,EAAY3E,EAAO2E,WAAa,GAChC8hB,GAAW,IAAAF,iBAAgBntB,EAAM,GACjC+tB,GAAa,IAAAT,mBAAkBttB,GAC/BouB,EAAyB,UAAbf,EACZgB,EAAYznB,EAAOynB,WAAa,IAChC7oB,EAAOoB,EAAOpB,MAAQ,0BAAmB6nB,EAAQ,YAAIgB,GAC3D,OAAO,IAAI,EAAApG,WAAW7c,EAAU,CAC/B5F,KAAI,EACJ4c,eAAgB,6LAQR7W,EAAS,YAAIwiB,EAAU,yGAGKK,EAAY,GAAK,QAAO,mCAA2BC,EAAS,2QAMhG7G,SAAU,CACT,CACChiB,KAAM,UACNhJ,MAAO,EACPwD,KAAM,EAAAmW,KAEP,CACC3Q,KAAM,UACNhJ,WAAwBiM,IAAjB7B,EAAOqnB,MAAsBrnB,EAAOqnB,MAAQ,EACnDjuB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,SACNhJ,MAAOoK,EAAO0nB,MAAQ,EACtBtuB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,YACNhJ,WAA0BiM,IAAnB7B,EAAOinB,QAAwBjnB,EAAOinB,QAAU,EACvD7tB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,aACNhJ,MAAOoK,EAAOunB,UAAY,CAAC,EAAG,EAAG,GACjCnuB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,aACNhJ,MAAOoK,EAAOsnB,UAAY,CAAC,EAAG,EAAG,GACjCluB,KAAM,EAAAuS,OAEP,CACC/M,KAAM,gBACNhJ,MAAOoK,EAAO2nB,aAAe,CAAC,EAAG,EAAG,GACpCvuB,KAAM,EAAAuS,SAIV,EAKA,mCAAwCnH,GACvC,OAAO,IAAI,EAAA6c,WAAW7c,EAAU,CAC/B5F,KAAM,mBACN4c,eAAgB,gVAclB,C,6FC9iBA,iBAKC,WAAalK,EAAOC,EAAOqW,EAAOC,QAArB,IAAAvW,IAAAA,EAAA,QAAO,IAAAC,IAAAA,EAAA,QAAO,IAAAqW,IAAAA,EAAA,QAAO,IAAAC,IAAAA,EAAA,GACjC/lB,KAAKwP,EAAIA,EACTxP,KAAKyP,EAAIA,EACTzP,KAAK8lB,EAAIA,EACT9lB,KAAK+lB,EAAIA,CACV,CAcD,OAbC,sBAAI,oBAAK,C,IAAT,WACC,OAAO/lB,KAAK8lB,CACb,E,gCACA,sBAAI,qBAAM,C,IAAV,WACC,OAAO9lB,KAAK+lB,CACb,E,gCACA,YAAAC,KAAA,SAAKC,GAKJ,OAJAjmB,KAAKwP,EAAIyW,EAAEzW,EACXxP,KAAKyP,EAAIwW,EAAExW,EACXzP,KAAK8lB,EAAIG,EAAEH,EACX9lB,KAAK+lB,EAAIE,EAAEF,EACJ/lB,IACR,EACD,EAxBA,GAAa,EAAAuP,QAAAA,C,uPCLb,aAMA,SAoFA,SAAgB2W,EAAepyB,EAAYwD,GAC1C,OAAQA,GACP,KAAK,EAAA0a,WACL,KAAK,EAAAnI,MACJ,OAAO,IAAA5V,gBAAeH,GACvB,KAAK,EAAAqiB,KAEJ,QAAIriB,GAAS,SAETA,EAAQ,OACL,IAAAK,WAAUL,IAClB,KAAK,EAAAsiB,MAEJ,QAAItiB,GAAS,WAETA,EAAQ,SACL,IAAAK,WAAUL,IAClB,KAAK,EAAA2Z,IAEJ,QAAI3Z,GAAS,gBAETA,EAAQ,cACL,IAAAK,WAAUL,IAClB,KAAK,EAAAud,cAEJ,QAAIvd,EAAQ,OACL,IAAAW,sBAAqBX,GAC7B,KAAK,EAAAyd,eAEJ,QAAIzd,EAAQ,SACL,IAAAW,sBAAqBX,GAC7B,KAAK,EAAA2d,aAEJ,QAAI3d,EAAQ,cACL,IAAAW,sBAAqBX,GAC7B,QACC,MAAM,IAAIoS,MAAM,uBAAgB5O,IAEnC,CArGA,2BAAgCA,GAC/B,OAAO,EAAAmb,eAAexa,QAAQX,IAAS,CACxC,EAMA,yBAA8BA,GAC7B,OAAO,EAAA8a,aAAana,QAAQX,IAAS,CACtC,EAMA,uBAA4BA,GAC3B,OAAO,EAAAib,WAAWta,QAAQX,IAAS,CACpC,EAMA,8BAAmCA,GAClC,OAAO,EAAA+c,kBAAkBpc,QAAQX,IAAS,CAC3C,EAKA,4BAAiCA,GAChC,OAAO,EAAA6c,gBAAgBlc,QAAQX,IAAS,CACzC,EAMA,6BAAkC4K,EAA+BgD,EAAuB5N,GACvF,IAAI,IAAAjC,SAAQ6M,GAAa,CAExB,GAAKA,EAAwB9L,SAAW8O,EACvC,OAAO,EAER,IAAK,IAAIhM,EAAI,EAAGA,EAAKgJ,EAAwB9L,OAAQ8C,IACpD,IAAKgtB,EAAgBhkB,EAAwBhJ,GAAI5B,GAChD,OAAO,C,MAIT,IAAK4uB,EAAehkB,EAAY5K,GAC/B,OAAO,EAGT,OAAO,CACR,EAOA,mBAwCA,0BAA+BsI,EAAgBumB,EAAqB3b,EAAoB1N,GACvF8C,EAAKiR,SAAQ,SAAA5N,GACRkjB,EAAUluB,QAAQgL,GAAO,GAC5BnI,QAAQC,KAAK,8BAAuBkI,EAAG,uBAAeuH,GAAU,OAAG1N,EAAO,sBAAeA,EAAI,KAAM,GAAE,6BAAqB0J,KAAKC,UAAU0f,GAAU,KAErJ,GACD,EAEA,6BAAkCvmB,EAAgBwmB,EAAwB5b,EAAoB1N,GAC7FspB,EAAavV,SAAQ,SAAA5N,GACpB,GAAIrD,EAAK3H,QAAQgL,GAAO,EACvB,MAAM,IAAIiD,MAAM,+BAAwBjD,EAAG,+BAAuBuH,GAAU,OAAG1N,EAAO,sBAAeA,EAAI,KAAM,GAAE,KAEnH,GACD,C,o+CCzIa,EAAAkV,WAAa,aAIb,EAAAnI,MAAQ,QAIR,EAAAwH,cAAgB,gBAIhB,EAAA8E,KAAO,OAIP,EAAA5E,eAAiB,iBAIjB,EAAA6E,MAAQ,QAIR,EAAA3E,aAAe,eAIf,EAAAhE,IAAM,MAIN,EAAA4Y,KAAO,OAIP,EAAAC,KAAO,OAMP,EAAArU,QAAU,UAIV,EAAAC,OAAS,SAMT,EAAAG,cAAgB,gBAIhB,EAAAqO,OAAS,SAWT,EAAA1C,gBAAkB,CAACla,aAAc7M,WAAY6mB,UAAWxM,YAAayM,WAAY3M,YAAapb,WAAYV,OAQ1G,EAAAmd,eAAiB,CAAC,EAAAT,WAAY,EAAAnI,MAAO,EAAAwH,cAAe,EAAA8E,KAAM,EAAA5E,eAAgB,EAAA6E,MAAO,EAAA3E,aAAc,EAAAhE,KAY/F,EAAA2E,aAAe,CAAC,EAAAH,QAAS,EAAAC,QAWzB,EAAAK,WAAa,CAAC,EAAAF,cAAe,EAAAqO,QAc7B,EAAA6F,IAAM,MAIN,EAAAtQ,KAAO,OAYP,EAAA5B,kBAAoB,CAAC,EAAAkS,IAAK,EAAAtQ,MAIzB,EAAA9B,gBAAkB,CAAC,EAAA9C,cAAe,EAAAxH,MAAO,EAAAmI,YAM1C,EAAA7Q,MAAQ,SAIR,EAAAC,MAAQ,MAUR,EAAAR,OAAS,SAIT,EAAAC,OAAS,QAIT,EAAAE,mBAAqB,qBAIpB,EAAAD,oBAAsB,sBAMvB,EAAA0lB,gBAAkB,OAIlB,EAAAC,mBAAqB,UAIrB,EAAAnlB,iBAAmB,QAUnB,EAAAugB,iBAAmB,mBAInB,EAAAC,iBAAmB,mBAInB,EAAAC,iBAAmB,mBAInB,EAAAC,iBAAmB,mBAInB,EAAAC,eAAiB,iBAIjB,EAAAC,eAAiB,iBAIjB,EAAAC,eAAiB,iBAIjB,EAAAC,eAAiB,iBAIjB,EAAAC,gBAAkB,kBAIlB,EAAAC,gBAAkB,kBAIlB,EAAAC,gBAAkB,kBAIlB,EAAAC,gBAAkB,kBAIjB,EAAAf,gBAAkB,kBAIjB,EAAAC,gBAAkB,kBAInB,EAAAC,gBAAkB,kBAIjB,EAAAC,gBAAkB,kBAoDpB,EAAAhjB,qBAAuB,UAIvB,EAAAI,qBAAuB,UAIvB,EAAAE,0BAA4B,eAI5B,EAAAI,yBAA2B,cAI3B,EAAAF,gCAAkC,qBAIjC,EAAAI,wBAA0B,aAK3B,EAAA+N,gBAAkB,kBAIlB,EAAAC,gBAAkB,kBAIjB,EAAAkZ,2BAA6B,6BAI9B,EAAAC,sBAAwB,wBAIxB,EAAAC,0BAA4B,4BAI5B,EAAAtZ,0BAA4B,4BAwB5B,EAAAlN,uBAAyB,SAACF,GAAsB,MAAM,IAAIgG,MAAMhG,EAAU,EAM1E,EAAA6L,4BAA8B,GAM9B,EAAA6O,kBAAoB,EAIpB,EAAAC,kBAAoB,WAAK,GAAI,EAI7B,EAAAC,UAAa,WAAK,GAIlB,EAAAC,SAAW,WAAK,GAAI,EAIpB,EAAAC,mBAAqB,EAIrB,EAAAC,mBAAqB,WAAK,IAAK,EAI/B,EAAAC,WAAc,WAAK,IAInB,EAAAC,UAAY,WAAK,IAAK,EAItB,EAAAC,iBAAmB,EAInB,EAAAC,iBAAmB,WAAK,IAAK,EAI7B,EAAAC,SAAY,WAAK,IAIjB,EAAAC,QAAU,WAAK,IAAK,EAKpB,EAAAsL,oBAAsB,KAItB,EAAAC,mBAAqB,KAIrB,EAAAC,eAAiB,SAIjB,EAAA7Z,cAAgB,SAMhB,EAAA8Z,oBAAsB,sBAItB,EAAAC,sBAAwB,wBAExB,EAAA1b,aAAe,eACf,EAAAC,gBAAkB,kBAClB,EAAAJ,cAAgB,gBAChB,EAAAE,eAAiB,gB,qOChd9B,aAyBC,2BAAgCzI,GAChC,GAAIA,IAAc,EAAAvB,iBAAkB,OAAO,EAC3C,GAAIuB,IAAc,EAAA4jB,mBAAoB,OAAO,EAC7C,GAAI5jB,IAAc,EAAA2jB,gBAAiB,OAAO,EAC1C,MAAM,IAAItgB,MAAM,0CAAmCM,KAAKC,UAAU5D,GAAU,KAC7E,EAKA,8BAAmCvL,EAAoB4J,GACtD,OAAQ5J,GACP,KAAK,EAAA0a,WACL,KAAK,EAAAnI,MACJ,OAAO,EAAAA,MACR,KAAK,EAAAwH,cACL,KAAK,EAAAE,eACL,KAAK,EAAAE,aACJ,OAAIvQ,IAAgB,EAAAE,MAAc,EAAAqM,IAC3B,EAAA6Y,KACR,KAAK,EAAAnQ,KACL,KAAK,EAAAC,MACL,KAAK,EAAA3I,IACJ,OAAO,EAAAA,IACR,QACC,MAAM,IAAIvH,MAAM,wBAAiB5O,EAAI,+BAExC,EAKA,mCACCA,EACAkkB,GAEA,YAFA,IAAAA,IAAAA,GAAA,GAEQlkB,GACP,KAAK,EAAA0a,WACJ,OAAIwJ,EAA2B1X,aACxBwN,YACR,KAAK,EAAAzH,MACJ,OAAO/F,aACR,KAAK,EAAAuN,cACJ,OAAOpa,WACR,KAAK,EAAAkf,KACJ,OAAO2H,UACR,KAAK,EAAAvM,eACJ,OAAOD,YACR,KAAK,EAAA8E,MACJ,OAAO2H,WACR,KAAK,EAAAtM,aACJ,OAAOL,YACR,KAAK,EAAA3D,IACJ,OAAOzX,WACR,QACC,MAAM,IAAIkQ,MAAM,6BAAsB5O,EAAI,OAE7C,EAKA,2BAAgCA,EAAoB4N,GACnD,OAAQ5N,GACP,KAAK,EAAA0a,WACL,KAAK,EAAAnI,MACJ,OAAsB,IAAlB3E,EAA4B,QACzB,aAAMA,GACd,KAAK,EAAAmM,cACL,KAAK,EAAAE,eACL,KAAK,EAAAE,aACJ,OAAsB,IAAlBvM,EAA4B,OACzB,cAAOA,GACf,KAAK,EAAAiR,KACL,KAAK,EAAAC,MACL,KAAK,EAAA3I,IACJ,OAAsB,IAAlBvI,EAA4B,MACzB,cAAOA,GAEhB,MAAM,IAAIgB,MAAM,wBAAiB5O,EAAI,+BACtC,EAKC,6BAAkCA,GAClC,OAAQA,GACP,KAAK,EAAA0a,WACL,KAAK,EAAAnI,MACJ,MAAO,GACR,KAAK,EAAAwH,cACL,KAAK,EAAAE,eACL,KAAK,EAAAE,aACJ,MAAO,IACR,KAAK,EAAA0E,KACL,KAAK,EAAAC,MACL,KAAK,EAAA3I,IACJ,MAAO,IAET,MAAM,IAAIvH,MAAM,wBAAiB5O,EAAI,iCACtC,EAKA,kDAAuD4N,GACtD,OAAQA,GACP,KAAK,EACJ,MAAO,KACR,KAAK,EACJ,MAAO,MACR,KAAK,EACJ,MAAO,OACR,KAAK,EACJ,MAAO,GAET,MAAM,IAAIgB,MAAM,iCAA0BhB,EAAa,sDACxD,C,qWCzIa,EAAA0Y,kBAAoB,oBAKpB,EAAAL,uBAAyB,yBAEzB,EAAA7B,yBAA2B,2BAC3B,EAAAD,8BAAgC,gCAGhC,EAAAyL,oBAAsB,sBAMtB,EAAAxJ,uBAAyB,yBAGzB,EAAAC,4BAA8B,8BAE9B,EAAA7b,wBAA0B,0BAI1B,EAAA0P,uBAAyB,yBAEzB,EAAAmO,yBAA2B,2BAExC,wBACCjd,EACAykB,EACAC,GAGA,QAHA,IAAAA,IAAAA,GAAA,QAG4CrnB,IAAxC2C,EAASnE,YAAY4oB,GAA8B,OAAOzkB,EAASnE,YAAY4oB,GAE3E,IACJE,EADI/mB,EAAoDoC,EAAQ,GAAxDzC,EAAgDyC,EAAQ,eAAxCnE,EAAgCmE,EAAQ,YAARA,EAAQ,eAEpE,IACC2kB,EAAY/mB,EAAGuB,aAAaslB,EACjB,CAAV,MAAOxrB,GAAG,CAaZ,OAZI0rB,GAEH9oB,EAAY4oB,GAAiBE,EACzB3kB,EAAShD,gBAAgB5E,QAAQmG,IAAI,4BAAqBkmB,EAAa,QAE3E5oB,EAAY4oB,IAAiB,EACzBzkB,EAAShD,gBAAgB5E,QAAQmG,IAAI,sBAAemmB,EAAW,YAAc,GAAE,sBAAcD,EAAa,OAG1GE,GAAcD,GAClBnnB,EAAe,mEAA4DknB,EAAa,MAElFE,CACR,C,iWCxDA,IAAMC,EAA2E,IAAI5d,QAC/E6d,EAAuE,IAAI7d,QA2CjF,2BACChH,EACAmG,EACA2e,EACA1e,GAEQ,IAAAxI,EAAOoC,EAAQ,GACjBO,EAAM6F,EAAqB,EAAD,CAAE0e,GAAa1e,GAAkB,GAAI0e,EACjE9O,EAAc4O,EAAetP,IAAI/U,GACrC,IAAKyV,EAAa,CAEjB,GADAA,EAnDF,SACChW,EACAmG,EACA2e,EACA1e,GAEQ,IAAAxI,EAAiCoC,EAAQ,GAArCzC,EAA6ByC,EAAQ,eAArB1B,EAAa0B,EAAQ,SAE3CgW,EAAcpY,EAAGqY,oBACvB,GAAKD,EAAL,CAOA,GAHApY,EAAG+I,gBAAgB/I,EAAGgJ,YAAaoP,GAEnCpY,EAAGsY,qBAAqBtY,EAAGgJ,YAAahJ,EAAG0I,kBAAmB1I,EAAGmH,WAAY+f,EAAU,GACnF1e,EAAoB,CAEvB,IAAK9H,EACJ,MAAM,IAAIkF,MAAM,wDAEjB,GAAI4C,EAAmB1S,OAAS,GAC/B,MAAM,IAAI8P,MAAM,uCAEjB,IAAK,IAAIhN,EAAI,EAAGuuB,EAAc3e,EAAmB1S,OAAQ8C,EAAIuuB,EAAavuB,IACzEoH,EAAGsY,qBAAqBtY,EAAGgJ,YAAahJ,EAAG0I,kBAAoB9P,EAAI,EAAGoH,EAAGmH,WAAYqB,EAAmB5P,GAAI,E,CAI9G,IAAMwC,EAAS4E,EAAGgW,uBAAuBhW,EAAGgJ,aAK5C,OAJG5N,IAAW4E,EAAGwY,sBAChB7Y,EAAe,uDAAgD4I,EAAO/L,KAAI,cAAMpB,EAAM,MAGhFgd,C,CAxBNzY,EAAe,mDAA4C4I,EAAO/L,KAAI,cAAMwD,EAAG0U,WAAU,KAyB3F,CAgBgB0S,CAAgBhlB,EAAUmG,EAAQ2e,EAAU1e,IACrD4P,EAAa,OAClB4O,EAAe9sB,IAAIyI,EAAKyV,GACxB,IAAMiP,EAAkBJ,EAA0BvP,IAAIwP,IAAa,GAGnE,GAFAG,EAAgBtjB,KAAKqU,GACrB6O,EAA0B/sB,IAAIgtB,EAAUG,GACpC7e,EACH,IAAK,IAAI5P,EAAI,EAAGuuB,EAAc3e,EAAmB1S,OAAQ8C,EAAIuuB,EAAavuB,IAAK,CAC9E,IAAMwO,EAAUoB,EAAmB5P,GAC7B,EAAkBquB,EAA0BvP,IAAItQ,IAAY,GAClE,EAAgBrD,KAAKqU,GACrB6O,EAA0B/sB,IAAIkN,EAAS,E,EAI1CpH,EAAG+I,gBAAgB/I,EAAGgJ,YAAaoP,EACpC,EAMA,+BAAoCpY,EAAoDoH,GACvFpH,EAAG+I,gBAAgB/I,EAAGgJ,YAAa,MAEnC,IAAMqe,EAAkBJ,EAA0BvP,IAAItQ,GACtD,GAAIigB,EACH,IAAK,IAAIzuB,EAAI,EAAG0uB,EAAkBD,EAAgBvxB,OAAQ8C,EAAI0uB,EAAiB1uB,IAC9EoH,EAAGyY,kBAAkB4O,EAAgBzuB,IAGvCquB,EAA0BvH,OAAOtY,EAClC,C,wGC3FA,aAMA,SAMa,EAAAmgB,iBAAmB,iBACzB,EAAAb,oBAAmB,gBAAO,IAAAc,iBAAgB,EAAAtB,iBAAgB,kJAMxD,EAAAQ,oBAAmB,gBAAO,IAAAc,iBAAgB,EAAArB,oBAAmB,2fAqB/D,EAAAQ,sBAAqB,gBAAO,IAAAa,iBAAgB,EAAAtB,iBAAgB,2EAG1D,EAAAS,sBAAqB,gBAAO,IAAAa,iBAAgB,EAAArB,oBAAmB,qQ,kHC3CxE,aAKa,EAAA3nB,2BAA6B,8CAEjC,EAAA6nB,sBAAqB,mDAGrB,EAAAC,0BAAyB,iKASzB,EAAAA,0BAAyB,8FAMxB,EAAAD,sBAAqB,yHAKrB,EAAAC,0BAAyB,sT,wHC9BnC,aAGA,SAEa,EAAArnB,iCAAmC,YAC9C,EAAAwoB,6BAA4B,0CAED,EAAArB,2BAA0B,8kBAgBzB,EAAAA,2BAA0B,oXAU9C,EAAApZ,0BAAyB,ucAWzB,EAAAC,gBAAe,sIAIf,EAAAC,gBAAe,iP,uHCjDzB,aAGA,SAEa,EAAA/N,gCAAkC,YAC7C,EAAAsoB,6BAA4B,w4BA6BpB,EAAAza,0BAAyB,0jB,yHCnCnC,aAGA,SAEa,EAAAnO,kCAAoC,YAC/C,EAAA4oB,6BAA4B,06BA8BpB,EAAAza,0BAAyB,ueAYzB,EAAAC,gBAAe,iFAGf,EAAAC,gBAAe,iO,+HCnDzB,aAEa,EAAAnO,wCAA0C,YACrD,EAAA0oB,6BAA4B,irC,kHCHjB,EAAA9oB,6BAA+B,qjC,kHCA/B,EAAA8oB,6BAA+B,m9B,sqCCA5C,aACA,SA+DC,2EA/DQ,EAAAplB,WAAW,IACpB,aA+DC,wEA/DQ,EAAAsC,QAAQ,IACjB,aACA,SA8DC,0EA9DQ,EAAAsa,UAAU,IACnB,aA8DC,8EA9DQ,EAAA7N,cAAc,IACvB,aACA,SACA,SACA,SACA,SACA,SAMMsW,EAAW,EAAH,WACbC,YAAaC,EAAMD,YACnBrO,kBAAmBsO,EAAMtO,kBACzBuO,gBAAiBD,EAAMC,gBACvBtO,UAAWqO,EAAMrO,UACjBuO,iBAAkBF,EAAME,iBACxB9hB,cAAe4hB,EAAM5hB,cACrB2T,cAAeiO,EAAMjO,cACrB5D,YAAa6R,EAAM7R,YACnBjQ,uBAAwB8hB,EAAM9hB,uBAC9B4Y,yBAA0BkJ,EAAMlJ,yBAChCqJ,WAAYH,EAAMG,WAClBva,yBAA0Boa,EAAMpa,yBAChC4V,4BAA6BwE,EAAMxE,4BACnCtb,oBAAqB8f,EAAM9f,oBAC3BgP,gBAAiB8Q,EAAM9Q,iBACpBkR,GACAC,GACAC,GACAC,GACAC,GACAC,GA8CH,EAAAX,SAAAA,EAzCA,IAAAhnB,EAMGknB,EAAK,SALRU,EAKGV,EAAK,kBAJRW,EAIGX,EAAK,+BAHRY,EAGGZ,EAAK,iCAFRa,EAEGb,EAAK,gCADRc,EACGd,EAAK,kCAmBR,EAAAlnB,SAAAA,EACA,EAAA4nB,kBAAAA,EACA,EAAAC,+BAAAA,EACA,EAAAC,iCAAAA,EACA,EAAAC,gCAAAA,EACA,EAAAC,kCAAAA,EAtBA,IAAA3lB,EAUG4lB,EAAQ,YATXC,EASGD,EAAQ,iBARXE,EAQGF,EAAQ,gBAPXG,EAOGH,EAAQ,qBANX9lB,EAMG8lB,EAAQ,gBALXI,EAKGJ,EAAQ,gBAJXK,EAIGL,EAAQ,YAHXM,EAGGN,EAAQ,iBAFXO,EAEGP,EAAQ,uBADXQ,EACGR,EAAQ,6BAaX,EAAA5lB,YAAAA,EACA,EAAA6lB,iBAAAA,EACA,EAAAC,gBAAAA,EACA,EAAAC,qBAAAA,EAGA,EAAAjmB,gBAAAA,EACA,EAAAkmB,gBAAAA,EACA,EAAAC,YAAAA,EACA,EAAAC,iBAAAA,EALA,EAAAC,uBAAAA,EACA,EAAAC,6BAAAA,EAOD,W,2RCtFA,aACA,SAsMA,SAASC,EAAoBpyB,GAC5B,OAAOA,GACN,IAAK,MACL,IAAK,OACJ,MAAO,QACR,IAAK,QACL,IAAK,QACJ,MAAO,OACR,IAAK,QACL,IAAK,QACJ,MAAO,OACR,IAAK,QACL,IAAK,QACJ,MAAO,OAET,MAAM,IAAI4O,MAAM,uBAAgB5O,EAAI,KACrC,CAgBA,SAASme,EAAIne,GAAY,MAAO,UAAGA,EAAI,sBAAcA,EAAI,wBAAgBA,EAAI,gBAAQoyB,EAAoBpyB,GAAK,WAAY,CAC1H,SAASqyB,EAAKryB,GAAY,MAAO,UAAGA,EAAI,uBAAeA,EAAI,wBAAgBA,EAAI,iBAASoyB,EAAoBpyB,GAAK,WAAY,CAC7H,SAASsyB,EAAMtyB,GAAW,MAAO,UAAGA,EAAI,wBAAgBA,EAAI,gDAAiD,CAC7G,SAASuyB,EAAMvyB,GAAW,MAAO,UAAGA,EAAI,wBAAgBA,EAAI,iCAAkC,CAC9F,SAASwyB,EAAUxyB,GAAW,MAAO,UAAGA,EAAI,4BAAoBA,EAAI,uCAAwC,CAC5G,SAASzC,EAAIk1B,EAAWC,GAAa,MAAO,UAAGD,EAAK,sBAAcA,EAAK,qBAAaC,EAAK,wBAAgBD,EAAK,gBAAQL,EAAoBK,GAAM,gBAAQL,EAAoBM,GAAM,WAAY,CAC9L,SAASl1B,EAAIi1B,EAAWC,GAAa,MAAO,UAAGD,EAAK,sBAAcA,EAAK,qBAAaC,EAAK,wBAAgBD,EAAK,gBAAQL,EAAoBK,GAAM,gBAAQL,EAAoBM,GAAM,WAAY,CAC9L,SAASC,EAAMF,EAAWC,GAAa,MAAO,UAAGD,EAAK,wBAAgBA,EAAK,qBAAaC,EAAK,uBAAeA,EAAK,0BAAkBD,EAAK,kBAAUL,EAAoBK,GAAM,gBAAQL,EAAoBM,GAAM,kBAAUN,EAAoBM,GAAM,aAAc,CAChQ,SAASE,EAAIH,EAAUC,GAAa,MAAO,UAAGD,EAAK,sBAAcA,EAAK,qBAAaA,EAAK,qBAAaC,EAAK,kCAtB1G,SAA8B1yB,GAC7B,OAAOA,GACN,IAAK,OACJ,MAAO,QACR,IAAK,QACJ,MAAO,OACR,IAAK,QACJ,MAAO,OACR,IAAK,QACJ,MAAO,OAET,MAAM,IAAI4O,MAAM,uBAAgB5O,EAAI,KACrC,CAUoI6yB,CAAqBH,GAAM,UAAW,CAC1K,SAASI,EAAKn0B,EAAWgI,EAAWuL,GAAgB,MAAO,YAAKvT,EAAC,aAAKgI,EAAC,kBAAUhI,EAAI,GAAKuT,EAAI,cAAMvL,EAAI,GAAKuL,EAAI,kBAAUvT,EAAI,GAAKuT,EAAI,aAAKvL,EAAC,iBAAShI,EAAC,cAAMgI,EAAI,GAAKuL,EAAI,IAAK,CAEhL,SAAS6gB,EAAKp0B,EAAWgI,EAAWuL,GAAgB,MAAO,CAAC,EAAG,EAAG,GAAGyU,KAAI,SAAA1E,GAAU,kBAAKtjB,EAAC,cAAMgI,EAAIsb,GAAU/P,EAAI,gBAAQ4gB,GAAMn0B,EAAI,GAAKuT,GAAOvL,EAAI,EAAIsb,GAAU/P,EAAMA,GAAK,IAAzF,IAA8F1P,KAAK,MAAQ,CA8O9L,SAASwwB,EAAYP,EAAuBC,GAC5C,MAAM,iCAA0BD,EAAK,2BAAmBC,EAAK,6BAC1DD,EAAK,oBAAYA,EAAK,8BACtBA,EAAK,oCACLA,EAAK,+JAKR,CACA,SAASQ,EAAKR,EAAgBC,GAAkB,MAAO,UAAGD,EAAK,uBAAeA,EAAK,qBAAaC,EAAK,kCAAmC,CACxI,SAASQ,EAAMT,EAAgBC,GAAkB,MAAO,UAAGA,EAAK,wBAAgBD,EAAK,qBAAaC,EAAK,wBAAgBA,EAAK,iBAASN,EAAoBK,GAAM,gBAAQL,EAAoBM,GAAM,WAAY,CAC7M,SAASS,EAAaV,EAAgBC,GACtC,MAAM,UAAGD,EAAK,+BAAuBA,EAAK,qBAAaC,EAAK,0FAI7CD,EAAK,gBAAQL,EAAoBM,GAAM,kBAAUN,EAAoBM,GAAM,sBAG1F,CACA,SAASU,EAAcX,EAAgBC,GACvC,MAAO,UAAGD,EAAK,gCAAwBA,EAAK,qBAAaC,EAAK,sFAInDD,EAAK,kBAAUL,EAAoBK,GAAM,qBAAaL,EAAoBM,GAAM,kBAAUN,EAAoBM,GAAM,uBAE3H,CAGJ,SAASW,EAAUC,GACnB,MAAO,uBAA4B,KAAZA,EAAiB,GAAKA,EAAO,wJAO5BA,EAAO,qPAa3B,CACJ,SAASC,EAAWD,GACpB,MAAO,wBAA6B,KAAZA,EAAiB,GAAKA,EAAO,wJAO7BA,EAAO,qPAa3B,CACJ,SAASE,EAAWF,GACpB,MAAO,wBAA6B,KAAZA,EAAiB,GAAKA,EAAO,kJAM7BA,EAAO,qPAa3B,CACJ,SAASG,EAAWH,GACpB,MAAO,wBAA6B,KAAZA,EAAiB,GAAKA,EAAO,0IAO7BA,EAAO,oJAS3B,CAxkBS,EAAA/J,iBAAmB,eAOnB,EAAAC,iBAAmB,eAKlB,EAAAE,mBAAqB,iBAQtB,EAAAD,iBAAmB,eAMnB,EAAAoD,0BAA4B,kBAM5B,EAAAE,6BAA+B,qBAO5C,2BAAgCpF,GAC/B,IAAM+L,EAAe/L,EAAagM,MAAM,gBACxC,IAAKD,GAAwC,IAAxBA,EAAa50B,OAAc,MAAO,CAAE6oB,aAAY,EAAEC,gBAAiB,IACxF,IAAMA,GAAkB,IAAAgM,wBAAuBjM,GAC/C,GAA+B,IAA3BC,EAAgB9oB,OAAc,MAAO,CAAE6oB,aAAY,EAAEC,gBAAe,GACxEA,EAAgBrO,SAAQ,SAAC/T,EAAM5D,GAC9B,IAAMqvB,EAAQ,IAAI4C,OAAO,gCAAyBruB,EAAI,OAAO,MAC7DmiB,EAAeA,EAAanhB,QAAQyqB,EAAO,gCAAyBrvB,EAAC,YAAI4D,GAC1E,IACA,IAAMsuB,EAAwBnM,EAAagM,MAAM,sBAC7CG,aAAqB,EAArBA,EAAuBh1B,SAC1B0E,QAAQC,KAAK,+DAAgEkkB,GAI9E,IADA,IAAIoM,EAA8C,CAAC,EAC1CnyB,EAAI,EAAGA,EAAIgmB,EAAgB9oB,OAAQ8C,IAE3CmyB,EAAiB,UAAG,EAAAlH,2BAAyB,OAAGjrB,IAAO,OACvDmyB,EAAiB,UAAG,EAAAhH,8BAA4B,OAAGnrB,IAAO,OAG3D,SAASoyB,EAA4BpyB,EAAWqyB,EAAgBC,QAAA,IAAAA,IAAAA,EAAA,IAC/D,IAAMC,EAA6B,KAAhBD,EAAqB,GAAK,IAE7C,MAAO,YAD8B,KAAhBA,EAAqBD,EAAS,IAEvC,sCAA8BryB,EAAC,kBAAUqyB,EAAM,kDAC9C,KAAXA,EAAgB,eAAQ,EAAAxK,kBAAgB,OAAG7nB,EAAC,UAAW,GAAE,sBACpD,EAAA2nB,kBAAgB,OAAG3nB,EAAC,8BACnB,EAAA4nB,kBAAgB,OAAG5nB,EAAC,kCACjBsyB,EAAW,+BAAuBC,EAAU,0CAE5CD,EAAW,wDAAgD,EAAArH,2BAAyB,OAAGjrB,EAAC,YAAIuyB,EAAU,kDAGzG,EAAA3K,kBAAgB,OAAG5nB,EAAC,kCACjBsyB,EAAW,wDAAgD,EAAArH,2BAAyB,OAAGjrB,EAAC,YAAIuyB,EAAU,0CAEtGD,EAAW,yDAAiD,EAAArH,2BAAyB,OAAGjrB,EAAC,YAAIuyB,EAAU,0CAGrG,KAAXF,EAAgB,0BACX,EAAA1K,kBAAgB,OAAG3nB,EAAC,8BACnB,EAAA4nB,kBAAgB,OAAG5nB,EAAC,kCACjBsyB,EAAW,sDAA8C,EAAArH,2BAAyB,OAAGjrB,EAAC,aAAK,EAAAmrB,8BAA4B,OAAGnrB,EAAC,YAAIuyB,EAAU,0CAEzID,EAAW,wEAAgE,EAAArH,2BAAyB,OAAGjrB,EAAC,aAAK,EAAAmrB,8BAA4B,OAAGnrB,EAAC,YAAIuyB,EAAU,kDAG9J,EAAA3K,kBAAgB,OAAG5nB,EAAC,kCACjBsyB,EAAW,wEAAgE,EAAArH,2BAAyB,OAAGjrB,EAAC,aAAK,EAAAmrB,8BAA4B,OAAGnrB,EAAC,YAAIuyB,EAAU,0CAE3JD,EAAW,yEAAiE,EAAArH,2BAAyB,OAAGjrB,EAAC,aAAK,EAAAmrB,8BAA4B,OAAGnrB,EAAC,YAAIuyB,EAAU,yCAG9J,GAAE,QAEZ,CAEA,SAASC,EAAwBH,GAChC,MAAO,YACPA,EAAM,uDAA+CA,EAAM,4HAG3DA,EAAM,sDAA8CA,EAAM,oMAK1DA,EAAM,sDAA8CA,EAAM,4LAK3D,CAmEA,MAAO,CACNtM,aA3CDA,EAAe,YACbxpB,OAAOmK,KAAKyrB,GAAkBpN,KAAI,SAAChb,GAAQ,wBAAWooB,EAAiBpoB,GAAI,YAAIA,EAAG,IAAvC,IAA4CnJ,KAAK,MAAK,8UAYjG4xB,EAAwB,IAAG,uCAE3B,CAAC,IAAK,KAAKzN,KAAI,SAAAsN,GAAU,OAAAG,EAAwBH,EAAxB,IAAiCzxB,KAAK,MAAK,uBAGpE,CAAE,KACJ,gBACA,eACA,gBACCmkB,KAAI,SAAAvK,GAAQ,OA5CNiY,GAD6BC,EA6CIlY,GA5CL,6BAAsBkY,GAAa,UAC/DC,EAAeD,EAAW,WAAa,GACvC,8CAC6BA,EAAW,gBAASA,GAAa,GAAE,qYAQvDD,EAAc,2BAAmBE,EAAW,+BAC5CF,EAAc,oCAA4BE,EAAW,+BACrDF,EAAc,oCAA4BE,EAAW,+BACrDF,EAAc,gCAAwBE,EAAW,qKAfjE,IAAoCD,EAC7BD,EACAE,CA2CM,IAAkC/xB,KAAK,MAAK,eAEvDolB,EAAgBjB,KAAI,SAACkD,EAAS3L,GACjC,MAAO,kBAAW,EAAAwL,oBAAkB,OAAGxL,EAAK,eACxC8V,EAA4B9V,EAAO,IAAG,WACnC,IAAG1b,KAAK,MAAK,uCAEjB,CAAC,IAAK,KAAKmkB,KAAI,SAAAsN,GACjB,OAAOrM,EAAgBjB,KAAI,SAACkD,EAAS3L,GACpC,OAAO8V,EAA4B9V,EAAO+V,EAC3C,IAAGzxB,KAAK,KACT,IAAGA,KAAK,MAAK,sBAETolB,EAAgBjB,KAAI,SAACkD,EAAS3L,GAClC,MAAO,iBAAU,EAAAwL,oBAAkB,OAAGxL,EAAK,eACxC8V,EAA4B9V,EAAO,GAAI,UAAS,WAC5C,IAAG1b,KAAK,MAAK,uBAGlBmlB,GAGAC,gBAAe,EAEjB,EAyDA,0BAA+BD,GAG9B,IATahpB,EAAWgI,EAAWuL,EAS/BsiB,EAAkB,GAiOtB,OA5NI7M,EAAaS,SAAS,SACzBoM,GAAmB,gBACnBrW,EAAI,OAAM,aACVA,EAAI,SAAQ,aACZA,EAAI,SAAQ,aACZA,EAAI,SAAQ,OAITwJ,EAAaS,SAAS,UACzBoM,GAAmB,gBACnBnC,EAAK,OAAM,aACXA,EAAK,SAAQ,aACbA,EAAK,SAAQ,aACbA,EAAK,SAAQ,OAIV1K,EAAaS,SAAS,WACzBoM,GAAmB,gBACnBjC,EAAM,SAAQ,aACdA,EAAM,QAAO,aACbA,EAAM,QAAO,aACbA,EAAM,QAAO,OAIV5K,EAAaS,SAAS,WACzBoM,GAAmB,gBACnBlC,EAAM,SAAQ,aACdA,EAAM,QAAO,aACbA,EAAM,QAAO,aACbA,EAAM,QAAO,OAIV3K,EAAaS,SAAS,eACzBoM,GAAmB,gBACnBhC,EAAU,SAAQ,aAClBA,EAAU,QAAO,aACjBA,EAAU,QAAO,aACjBA,EAAU,QAAO,OAId7K,EAAaS,SAAS,SACzBoM,GAAmB,gBACnBj3B,EAAI,MAAO,OAAM,aACjBA,EAAI,QAAS,SAAQ,aACrBA,EAAI,QAAS,SAAQ,aACrBA,EAAI,QAAS,SAAQ,aACrBA,EAAI,QAAS,OAAM,aACnBA,EAAI,QAAS,OAAM,aACnBA,EAAI,QAAS,OAAM,OAIhBoqB,EAAaS,SAAS,SACzBoM,GAAmB,gBACnBh3B,EAAI,MAAO,OAAM,aACjBA,EAAI,QAAS,SAAQ,aACrBA,EAAI,QAAS,SAAQ,aACrBA,EAAI,QAAS,SAAQ,aACrBA,EAAI,QAAS,OAAM,aACnBA,EAAI,QAAS,OAAM,aACnBA,EAAI,QAAS,OAAM,OAIhBmqB,EAAaS,SAAS,WACzBoM,GAAmB,gBACnB7B,EAAM,MAAO,OAAM,aACnBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,QAAS,OAAM,aACrBA,EAAM,QAAS,OAAM,aACrBA,EAAM,QAAS,OAAM,OAIlBhL,EAAaS,SAAS,SACzBoM,GAAmB,gBACnB5B,EAAI,QAAS,QAAO,aACpBA,EAAI,OAAQ,SAAQ,aACpBA,EAAI,OAAQ,SAAQ,aACpBA,EAAI,OAAQ,SAAQ,OAIjBjL,EAAaS,SAAS,kBACzBoM,GAAmB,ilBAyBhB7M,EAAaS,SAAS,eACzBoM,GAAmB,kvBA2ChB7M,EAAaS,SAAS,iBACzBoM,GAAmB,4DAEV1B,EAAK,EAAG,EAAG,GAAE,6DAGbC,EAAK,EAAG,EAAG,GAAE,8DApLVp0B,EAuLE,EAvLSgI,EAuLN,EAvLiBuL,EAuLd,EAvLqC,CAAC,EAAG,EAAG,EAAG,GAAGyU,KAAI,SAAA1E,GAAU,kBAAKtjB,EAAC,cAAMgI,EAAIsb,GAAU/P,EAAI,gBAAQ6gB,GAAMp0B,EAAI,GAAKuT,GAAOvL,EAAI,EAAIsb,GAAU/P,EAAMA,GAAK,IAAzF,IAA8F1P,KAAK,QAuLjK,WAMnBmlB,EAAaS,SAAS,UACzBoM,GAAmB,2DAENpzB,KAAKqzB,EAAC,sBAAcrzB,KAAKqzB,EAAC,uBAIpC9M,EAAaS,SAAS,UACzBoM,GAAmB,2DAENpzB,KAAKqzB,EAAC,sBAAcrzB,KAAKqzB,EAAC,wBAIpC9M,EAAaS,SAAS,UACzBoM,GAAmB,sGAOhB7M,EAAaS,SAAS,WACzBoM,GAAmB,iFAMhB7M,EAAaS,SAAS,WACzBoM,GAAmB,iFAMhB7M,EAAaS,SAAS,WACzBoM,GAAmB,qGAQbA,CACR,EAyHA,mCAAwC7M,EAAsB/d,GAG7D,IAAI8qB,EAA4B,GAoKhC,OAjKI/M,EAAaS,SAAS,iBACzBsM,GAA6B,cAC7B1B,EAAY,MAAO,SAAQ,aAC3BA,EAAY,MAAO,QAAO,uCAE1BA,EAAY,MAAO,SAAQ,aAC3BA,EAAY,OAAQ,SAAQ,aAC5BA,EAAY,OAAQ,SAAQ,aAC5BA,EAAY,OAAQ,QAAO,gBAMxBrL,EAAaS,SAAS,SAAYxe,IAAgB,EAAAE,OAAS6d,EAAaS,SAAS,cACpFsM,GAA6B,cAC7BzB,EAAK,MAAO,OAAM,aAClBA,EAAK,QAAS,SAAQ,aACtBA,EAAK,QAAS,SAAQ,aACtBA,EAAK,QAAS,SAAQ,aACtBA,EAAK,QAAS,OAAM,aACpBA,EAAK,QAAS,OAAM,aACpBA,EAAK,QAAS,OAAM,uCAEpBA,EAAK,OAAQ,QAAO,aACpBA,EAAK,QAAS,SAAQ,aACtBA,EAAK,QAAS,SAAQ,aACtBA,EAAK,QAAS,SAAQ,aACtBA,EAAK,QAAS,QAAO,aACrBA,EAAK,QAAS,QAAO,aACrBA,EAAK,QAAS,QAAO,eAIlBtL,EAAaS,SAAS,WACzBsM,GAA6B,cAC7BxB,EAAM,MAAO,OAAM,aACnBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,MAAO,SAAQ,aACrBA,EAAM,MAAO,SAAQ,aACrBA,EAAM,MAAO,SAAQ,uCAErBA,EAAM,OAAQ,QAAO,aACrBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,QAAS,SAAQ,aACvBA,EAAM,OAAQ,SAAQ,aACtBA,EAAM,OAAQ,SAAQ,aACtBA,EAAM,OAAQ,SAAQ,eAKnBvL,EAAaS,SAAS,kBACzBsM,GAA6B,cAC7BvB,EAAa,MAAO,OAAM,aAC1BA,EAAa,QAAS,SAAQ,aAC9BA,EAAa,QAAS,SAAQ,aAC9BA,EAAa,QAAS,SAAQ,aAC9BA,EAAa,QAAS,OAAM,aAC5BA,EAAa,QAAS,OAAM,aAC5BA,EAAa,QAAS,OAAM,uCAE5BA,EAAa,OAAQ,QAAO,aAC5BA,EAAa,QAAS,SAAQ,aAC9BA,EAAa,QAAS,SAAQ,aAC9BA,EAAa,QAAS,SAAQ,aAC9BA,EAAa,QAAS,QAAO,aAC7BA,EAAa,QAAS,QAAO,aAC7BA,EAAa,QAAS,QAAO,eAK1BxL,EAAaS,SAAS,mBACzBsM,GAA6B,cAC7BtB,EAAc,MAAO,OAAM,aAC3BA,EAAc,QAAS,SAAQ,aAC/BA,EAAc,QAAS,SAAQ,aAC/BA,EAAc,QAAS,SAAQ,aAC/BA,EAAc,QAAS,OAAM,aAC7BA,EAAc,QAAS,OAAM,aAC7BA,EAAc,QAAS,OAAM,uCAE7BA,EAAc,OAAQ,QAAO,aAC7BA,EAAc,QAAS,SAAQ,aAC/BA,EAAc,QAAS,SAAQ,aAC/BA,EAAc,QAAS,SAAQ,aAC/BA,EAAc,QAAS,QAAO,aAC9BA,EAAc,QAAS,QAAO,aAC9BA,EAAc,QAAS,QAAO,eAK3BzL,EAAaS,SAAS,eACzBsM,GAA6B,cAC7BrB,EAAU,GAAE,aACZA,EAAU,IAAG,aACbA,EAAU,IAAG,uCAEZ,CAAC,EAAG,GAAI,IAAI1M,KAAI,SAAAgO,GACnB,MAAO,0BACSA,EAAM,sDACEA,EAAM,wBAE9B,IAAGnyB,KAAK,MAAK,eAKRmlB,EAAaS,SAAS,gBACzBsM,GAA6B,cAC7BnB,EAAW,GAAE,aACbA,EAAW,IAAG,aACdA,EAAW,IAAG,uCAEb,CAAC,EAAG,GAAI,IAAI5M,KAAI,SAAAgO,GACnB,MAAO,2BACUA,EAAM,uDACEA,EAAM,wBAE/B,IAAGnyB,KAAK,MAAK,eAKRmlB,EAAaS,SAAS,gBACzBsM,GAA6B,cAC7BlB,EAAW,GAAE,aACbA,EAAW,IAAG,aACdA,EAAW,IAAG,uCAEb,CAAC,EAAG,GAAI,IAAI7M,KAAI,SAAAgO,GACnB,MAAO,2BACUA,EAAM,uDACEA,EAAM,wBAE/B,IAAGnyB,KAAK,MAAK,eAKRmlB,EAAaS,SAAS,gBACzBsM,GAA6B,cAC7BjB,EAAW,GAAE,aACbA,EAAW,IAAG,aACdA,EAAW,IAAG,uCAEb,CAAC,EAAG,GAAI,IAAI9M,KAAI,SAAAgO,GACnB,MAAO,2BACUA,EAAM,+CACEA,EAAM,gBAE/B,IAAGnyB,KAAK,MAAK,eAKLkyB,CACR,C,0WC/vBA,aAkBA,SAASE,EAAaC,GACrB,OAAOA,EAAOruB,QAAQ,sBAAuB,OAC9C,CAMA,SAASsuB,EAAiBnN,EAAsBoN,EAAsB/0B,GAIrE,IAAMg1B,EAAa,IAAInB,OAAO,aAAMe,EAAaG,GAAa,sBAAsB,MAC9EE,EAAwBtN,EAAagM,MAAMqB,GACjD,GAAIC,EAEH,IAAK,IAAIrzB,EAAI,EAAGA,EAAIqzB,EAAsBn2B,OAAQ8C,IAAK,CACtD,IAAMszB,EAAkB,IAAIrB,OAAO,aAAMe,EAAaG,GAAa,wBAAwB,KACrFv4B,EAAQy4B,EAAsBrzB,GAAG+xB,MAAMuB,GAC7C,GAAI14B,GAASA,EAAM,GAAI,CACtB,IAAM24B,EAAe,IAAItB,OAAO,aAAMe,EAAaG,GAAa,oBAAYH,EAAap4B,EAAM,IAAG,SAAS,KAC3GmrB,EAAeA,EAAanhB,QAAQ2uB,EAAc,UAAGJ,EAAY,cAAM/0B,EAAI,YAAIxD,EAAM,GAAE,M,MAEvFgH,QAAQC,KAAK,+CAAwCwxB,EAAsBrzB,GAAE,K,MAI/E4B,QAAQC,KAAK,kDAA2CsxB,EAAY,MAErE,OAAOpN,CACR,CAOA,SAASyN,EAAoBzN,EAAsB0N,EAAqBr1B,GAGvE,IAAMg1B,EAAa,IAAInB,OAAO,UAAGwB,EAAW,iBAAiB,KACvDC,EAAyB3N,EAAagM,MAAMqB,GAClD,GAAIM,EAAwB,CAE3B,IAAMH,EAAe,IAAItB,OAAO,UAAGwB,EAAW,OAAO,KACrD1N,EAAeA,EAAanhB,QAAQ2uB,EAAc,kBAAWn1B,IAE7D,IAAK,IAAI4B,EAAI,EAAGA,EAAI0zB,EAAuBx2B,OAAQ8C,IAAK,CACvD,IAAM2zB,EAAqB,IAAI1B,OAAO,UAAGwB,EAAW,oBAC9CG,EAAWF,EAAuB1zB,GAAG+xB,MAAM4B,GAC7CC,GAAYA,EAAS,GACxB7N,EAAemN,EAAiBnN,EAAc6N,EAAS,GAAIx1B,GAE3DwD,QAAQC,KAAK,uDAAgD6xB,EAAuB1zB,GAAE,K,EAIzF,OAAO+lB,CACR,CAOA,SAAgB8N,EAAmB9N,GAOlC,OAJAA,EAAeyN,EAAoBzN,EAAc,wBAAyB,SAC1EA,EAAeyN,EAAoBzN,EAAc,0BAA2B,QAC5EA,EAAeyN,EAAoBzN,EAAc,0BAA2B,QAC5EA,EAAeyN,EAAoBzN,EAAc,0BAA2B,OAE7E,CA+BA,SAAgB+N,EAAgB/N,EAAsBhZ,GAMrD,IALA,IAAMgnB,EAGD,CAAC,EACFC,EAAc,IACL,CAEZ,IAAMjC,EAAQhM,EAAagM,MAAM,gJACjC,IAAKA,EAAO,CACX,GAAiC,IAA7Bx1B,OAAOmK,KAAKqtB,GAAM72B,OACrB,MAAO,GAUR,IAPA,IAAM+2B,EAAgB13B,OAAOmK,KAAKqtB,GAC5BG,EAAeD,EAAc/2B,OAC7Bi3B,EAGA,IAAI/3B,MAAM43B,GAAanJ,UAAKhkB,GAEzB7G,EAAI,EAAGA,EAAIk0B,EAAcl0B,IAAK,CACtC,IAAM,EAAOi0B,EAAcj0B,GACrB,EAAqB+zB,EAAK,GAAxB,EAAQ,WAAE,EAAI,OACtB,QAA6BltB,IAAzBstB,EAAW,GACd,MAAM,IAAInnB,MAAM,iFAA0ED,EAAW,yDAAiD,EAAQ,MAE/JonB,EAAW,GAAa,CAAEvwB,KAAI,EAAExF,KAAI,E,CAErC,GAAI61B,EAAc/2B,SAAW82B,EAAc,EAC1C,MAAM,IAAIhnB,MAAM,iFAA0ED,EAAW,0FAEtG,IAAS/M,EAAI,EAAGA,GAAKg0B,EAAah0B,IACjC,QAAsB6G,IAAlBstB,EAAWn0B,GACd,MAAM,IAAIgN,MAAM,8CAAuChN,EAAC,2BAAmB+M,EAAW,0FAGxF,OAAOonB,C,CAGR,IAAM,EAAOpC,EAAM,GACb,EAAWqC,SAASrC,EAAM,IAAM,KAChC3zB,EAAO2zB,EAAM,GACnB,IAAK3zB,EACJ,MAAM,IAAI4O,MAAM,6CAAsC+kB,EAAM,GAAE,6BAAqBhlB,EAAW,OAE/F,IAAK,EACJ,MAAM,IAAIC,MAAM,sDAA+C+kB,EAAM,GAAE,6BAAqBhlB,EAAW,OAExG,GAAIgnB,EAAK,IACR,GAAIA,EAAK,GAAM9vB,WAAa,EAC3B,MAAM,IAAI+I,MAAM,6CAAsC,EAAI,oDAA4CD,EAAW,YAG9G,EAAWinB,IAAaA,EAAc,GAC1CD,EAAK,GAAQ,CACZ9vB,SAAQ,EACR7F,KAAI,GAIN2nB,EAAeA,EAAanhB,QAAQmtB,EAAM,GAAI,G,CAEhD,CA3KA,yBAA8BhM,GAC7B,OAAOA,EAAanhB,QAAQ,UAAW,YACxC,EAmEA,uBAgBA,0BAA+BmhB,GAG9B,OADAA,EAAe8N,EADf9N,EAAeA,EAAanhB,QAAQ,uBAAwB,WAG7D,EAQA,2BAAgCmhB,GAG/B,OADAA,EAAe8N,EADf9N,EAAeA,EAAanhB,QAAQ,sBAAuB,WAG5D,EAOA,oBAqEA,4BAAiCmhB,EAAsBhZ,GACtD,IAAMgnB,EAAOD,EAAgB/N,EAAchZ,GAC3C,GAAoB,IAAhBgnB,EAAK72B,OACR,MAAO,CAAC6oB,GAGTA,EAAeA,EAAanhB,QAAQ,mDAAoD,IAIxF,IADA,IAAMyvB,EAA0B,GACvBr0B,EAAI,EAAGs0B,EAAUP,EAAK72B,OAAQ8C,EAAIs0B,EAASt0B,IAAK,CAClD,MAAiB+zB,EAAK/zB,GAApB5B,EAAI,OAAE,EAAI,OAGZm2B,EAAW,IAAItC,OAAO,mFAA4E,EAAI,SAAS,KACjHuC,EAAkBzO,EAAanhB,QAAQ2vB,EAAU,IAErDC,EAAkBA,EAAgB5vB,QAAQ,WAAY,IAQtD,IANA,IAAI6vB,GAAkB,EAKhBpF,EAAQ,IAAI4C,OAAO,aAAM,EAAI,sBAAsB,OAC5C,CACZ,IAAMvlB,EAAS8nB,EAAgBzC,MAAM1C,GACrC,IAAI3iB,IAAUA,EAAO,GAqBd,CACN,IAAK+nB,EAAiB,MAAM,IAAIznB,MAAM,iEAA0DD,EAAW,OAC3G,K,CAtBA0nB,GAAkB,EAClB,IAAIC,EAAS,GACb,OAAQt2B,GACP,IAAK,QACL,IAAK,MACL,IAAK,OACJs2B,EAAS,YACT,MACD,IAAK,OACL,IAAK,QACL,IAAK,QACJA,EAAS,SACT,MACD,IAAK,OACL,IAAK,QACL,IAAK,QACJA,EAAS,MAGXF,EAAkBA,EAAgB5vB,QAAQyqB,EAAO,8BAAuB3iB,EAAO,IAAE,OAAGgoB,EAAM,M,CAM5FL,EAAclpB,KAAKqpB,E,CAEpB,OAAOH,CACR,EAcC,2CAAgDtO,EAAsB/d,EAA0BpE,GAChG,IAAM+wB,EATN,SAA6B5O,GAC7B,QAASA,EAAagM,MAAM,mBAC7B,CAOsB6C,CAAoB7O,GACzC,GAAI/d,IAAgB,EAAAC,OAEf0sB,EACH,MAAM,IAAI3nB,MAAM,8EAAuEpJ,EAAI,oGAG9F,EAMA,wBAA6BmiB,GAC5B,OAAOA,EAAanhB,QAAQ,eAAgB,aAC7C,EAMA,0BAA+BmhB,GAC9B,OAAOA,EAAanhB,QAAQ,sBAAuB,YACpD,EAMA,qBAA0BmhB,GASzB,OADAA,GADAA,GADAA,GADAA,GADAA,GADAA,GADAA,GADAA,EAAeA,EAAanhB,QAAQ,YAAa,QACrBA,QAAQ,aAAc,UACtBA,QAAQ,aAAc,UACtBA,QAAQ,aAAc,UACtBA,QAAQ,YAAa,SACrBA,QAAQ,aAAc,WACtBA,QAAQ,aAAc,WACtBA,QAAQ,aAAc,SAEnD,EAMA,0BAA+BmhB,GAC9B,OAAOA,EAAanhB,QAAQ,YAAa,UAC1C,EAOA,wBAA6BmhB,GAC5B,IAAM8O,EAAa9O,EAAa7oB,OAKhC,OAJA6oB,EAAeA,EAAanhB,QAAQ,yCAA0C,KAC7D1H,SAAW23B,GAC3BjzB,QAAQC,KAAK,yFAEPkkB,CACR,EAMA,0BAA+BA,GAC9B,IAAM8O,EAAa9O,EAAa7oB,OAKhC,OAJA6oB,EAAeA,EAAanhB,QAAQ,gEAAiE,KACpF1H,SAAW23B,GAC3BjzB,QAAQC,KAAK,0FAEPkkB,CACR,EAMA,yBAA8BA,GAI7B,OADAA,GAFAA,EAAeA,EAAanhB,QAAQ,kBAAmB,KAE3BA,QAAQ,gBAAiB,GAEtD,EAMA,kCAAuCmhB,GAGtC,IAAM+O,EAAiD,CAAC,EAClDzF,EAAQ,gFACR0F,EAAWhP,EAAagM,MAAM,IAAIE,OAAO5C,EAAO,MACtD,IAAK0F,GAAgC,IAApBA,EAAS73B,OAAc,MAAO,GAG/C,IAAM83B,EAAe,IAAI/C,OAAO5C,GAShC,OARA0F,EAASpd,SAAQ,SAAAsd,GAChB,IAAMhN,EAAUgN,EAAQlD,MAAMiD,GACzB/M,GAAYA,EAAQ,GAIzB6M,EAAqB7M,EAAQ,KAAM,EAHlCrmB,QAAQC,KAAK,2DAAoDozB,EAAO,MAI1E,IACO14B,OAAOmK,KAAKouB,EACpB,C,q8DCpXA,aAQA,SA6CA,SACA,SAGA,SACA,SAmBM3V,EAAU,CACf+V,oBAAgBruB,EAChBsuB,yBAAqBtuB,EACrBuuB,2BAAuBvuB,EACvBwuB,4BAAwBxuB,EACxByuB,8BAA0BzuB,GAe1B,SAAgB6Z,EAAkBtiB,GAClC,OAAOA,IAAS,EAAA+Z,eAAiB/Z,IAAS,EAAAia,gBAAkBja,IAAS,EAAAma,YACtE,CAMC,SAAgB0W,EAAgB7wB,GAChC,OAAOA,IAAS,EAAA6e,MAAQ7e,IAAS,EAAA8e,OAAS9e,IAAS,EAAAmW,GACpD,CAcA,SAASghB,EAAoC1P,GAG5C,IAFA,IAAI2P,EAAY,GACV9uB,EAAOnK,OAAOmK,KAAKmf,GAChB7lB,EAAI,EAAGA,EAAI0G,EAAKxJ,OAAQ8C,IAAK,CACrC,IAAM+J,EAAMrD,EAAK1G,GAEjB,KAAK,IAAAlE,UAASiO,MAAS,IAAAjO,UAAS+pB,EAAqB9b,IACpD,MAAM,IAAIiD,MAAM,2IAAoIjD,EAAG,qBAAa8b,EAAqB9b,GAAI,qBAAaA,EAAG,MAE9MyrB,GAAa,kBAAWzrB,EAAG,YAAI8b,EAAqB9b,GAAI,K,CAEzD,OAAOyrB,CACR,CAOA,SAAgBtG,EACflnB,EACAG,EACAE,EACAwd,EACAuJ,G,MAEMqG,EAAgBztB,IAAgB,EAAAC,MAAQ,mBAAY,EAAAA,MAAK,MAAO,GAChEytB,EAA6B7P,EAAuB0P,EAAoC1P,GAAwB,GAChH8P,EAA2BJ,IAAmC,MAClE,EAAAzH,qBAAsB,WAAG,IAAAc,iBAAgBzmB,IAC1C,EAAC,EAAA4lB,uBAAwB,WAAG,IAAAa,iBAAgBvmB,I,IAE7C,MAAO,UAAGotB,GAAa,OAAGrG,GAA0B,IAAE,OAAGsG,GAA0B,OAAGC,GAAwB,OAAG,EAAAhH,iBAClH,CAQA,SAAgBvhB,EACfhG,EACAY,EACAG,EACAE,EACA0d,EACA6P,EACA7oB,EACA9F,EACA4e,EACAuJ,EACAyG,QAAA,IAAAA,IAAAA,GAAA,GAGA,IAAM1oB,EAAS/F,EAAG0uB,aAAaF,GAC/B,IAAKzoB,EAEJ,OADAlG,EAAc,6BACP,KAIR,IAAM8uB,EAAe7G,EACpBlnB,EACAG,EACAE,EACAwd,EACAuJ,GAEK4G,EAAmB,UAAGD,GAAY,OAAGhQ,GAM3C,IALA3e,EAAG2e,aAAa5Y,EAAQ6oB,GAGxB5uB,EAAGgG,cAAcD,GAEb0oB,KAGazuB,EAAG6uB,mBAAmB9oB,EAAQ/F,EAAG8uB,gBAKhD,OAFAt0B,QAAQmG,IAAIiuB,EAAiBt3B,MAAM,MAAMqmB,KAAI,SAACoR,EAAMn2B,GAAM,gBAAGA,EAAC,aAAKm2B,EAAT,IAAiBv1B,KAAK,OAChFqG,EAAc,4BAAqB2uB,IAAexuB,EAAGqZ,gBAAkB,WAAa,SAAQ,gCAAwB1T,EAAW,cAAM3F,EAAGgvB,iBAAiBjpB,GAAO,MACzJ,KAGT,OAAOA,CACR,CAOA,SAAgB4T,EACf3Z,EACA0Z,EACAN,EACA5c,EACAqD,GAGA,IAAMsF,EAAUnF,EAAGivB,gBACnB,GAAK9pB,EAAL,CAUA,GALAnF,EAAGkvB,aAAa/pB,EAASuU,GACzB1Z,EAAGkvB,aAAa/pB,EAASiU,GACzBpZ,EAAGmvB,YAAYhqB,GAECnF,EAAGovB,oBAAoBjqB,EAASnF,EAAGqvB,aAMnD,OAAOlqB,EAHNtF,EAAc,sBAAerD,EAAI,6BAAqBwD,EAAGsvB,kBAAkBnqB,I,MAX3EtF,EAAc,oDAA6CrD,EAAI,qCAejE,CAQA,SAAgBkE,EAASV,GAExB,MAA0C,oBAA3BuvB,wBAA0CvvB,aAAcuvB,wBAAqE,oBAAlCC,+BAAiDxvB,aAAcwvB,6BAC1K,CAgCA,SAASC,EAAiBC,EAAkBC,GAC3C,IAAM3vB,EAAKxE,SAASe,cAAc,UAAU6D,WAAW,EAAAG,QACvD,IAAKP,EACJ,MAAM,IAAI4F,MAAM,iCAEjB,IACC,IAAMgqB,EAAK5pB,EACVhG,EACA,EAAAc,MACA,EAAAE,iBACA,EAAAA,iBACA0uB,EACA1vB,EAAGiG,cACH,oBACA,EAAAnG,wBAEK+vB,EAAK7pB,EACVhG,EACA,EAAAc,MACA,EAAAE,iBACA,EAAAA,iBACA2uB,EACA3vB,EAAGqZ,gBACH,oBACA,EAAAvZ,wBAEKqF,EAAUwU,EAAc3Z,EAAI4vB,EAAIC,EAAI,oBAAqB,EAAA/vB,wBAE/DE,EAAGma,cAAchV,GACjBnF,EAAG0Q,aAAakf,GAChB5vB,EAAG0Q,aAAamf,E,CAEf,SACD,OAAO,C,CAER,OAAO,CACR,CAMA,SAAgBtH,IACf,QAAoC9oB,IAAhCsY,EAAQgW,oBAAmC,CAC9C,IAAM+B,EAAgBL,EACrB,kFACA,2CAED1X,EAAQgW,oBAAsB+B,C,CAE/B,OAAO/X,EAAQgW,mBAChB,CAMA,SAAgBvF,IACf,QAAsC/oB,IAAlCsY,EAAQiW,sBAAqC,CAChD,IAAM+B,EAAkBN,EACvB,sDACA,uEAED1X,EAAQiW,sBAAwB+B,C,CAEjC,OAAOhY,EAAQiW,qBAChB,CAOA,SAASgC,EACRxzB,EACAwD,EACA6vB,EACAD,EACAK,GAEA,IAAM9qB,EAAUwU,EAAc3Z,EAAI4vB,EAAIC,EAAIrzB,EAAM,EAAAsD,wBAChD,IAAKqF,EACJ,MAAM,IAAIS,MAAM,gCAEjB,IAAMsqB,EAAmBlwB,EAAGqJ,kBAAkBlE,EAAS,YAMjDlC,EAASjD,EAAGkD,eAClBlD,EAAG0B,WAAW1B,EAAG2B,aAAcsB,GAC/BjD,EAAGmD,WAAWnD,EAAG2B,aAAc,EAAG3B,EAAGoD,aACrCpD,EAAGwJ,wBAAwB0mB,GAC3BlwB,EAAGsJ,oBACF4mB,EACA,EACAlwB,EAAG+Q,eACH,EACA,EACA,GAGD/Q,EAAG8I,SAAS,EAAG,EAAG,EAAG,GACrB9I,EAAG+G,WAAW5B,GAEd8qB,EAAY9qB,GAEZnF,EAAGuK,WACFvK,EAAGyN,OACH,EACA,GAGD,IAAM0iB,EAAQ,IAAIx5B,WAAW,GAW7B,OAVAqJ,EAAG4W,WAAW,EAAG,EAAG,EAAG,EAAG5W,EAAG2V,KAAM3V,EAAG+Q,cAAeof,GAGrDnwB,EAAG2J,yBAAyBumB,GAC5BlwB,EAAGma,cAAchV,GACjBnF,EAAG0Q,aAAakf,GAChB5vB,EAAG0Q,aAAamf,GAChB7vB,EAAGsQ,aAAarN,GAGTktB,CACR,CAgKA,SAASC,EAAiBzR,GAOzB,OALAA,GAAe,IAAA0R,cAAa1R,GAE5BA,GAAe,IAAA2R,gBAAe3R,GAE9BA,GAAe,IAAA4R,eAAc5R,EAE9B,CAOA,SAAS6R,EAAqB7R,GAO7B,OALAA,GAAe,IAAA8R,gBAAe9R,GAE9BA,GAAe,IAAA+R,WAAU/R,GAEzBA,GAAe,IAAAgS,cAAahS,EAE7B,CAqBA,SAAgBxF,EAA6BwF,EAAsBniB,GAKlE,OAJAmiB,EAAe6R,EAAqB7R,GAEpCA,GAAe,IAAAiS,iBAAgBjS,IAExB,IAAAkS,kBAAiBlS,EAAcniB,EACvC,CAyLA,SAASs0B,EACR9wB,EACA+wB,EACAC,EACAC,GAEA,OAAO,IAAI76B,SAAc,SAACC,EAASC,IACjC,SAASoE,IACV,IAAMw2B,EAAMlxB,EAAGmxB,eAAeJ,EAAMC,EAAO,GACvCE,IAAQlxB,EAAGoxB,YAIXF,IAAQlxB,EAAGqxB,gBAIfh7B,IAHE2G,WAAWtC,EAAMu2B,GAJjB36B,GAQD,CACAoE,EACF,GACC,CAED,SAAe42B,EACftxB,EACAlD,EACAmG,EACAsuB,EACAC,G,gGAKA,OAHMT,EAAO/wB,EAAGyxB,UAAUzxB,EAAG0xB,2BAA4B,GACzD1xB,EAAG2xB,QAEH,GAAMb,EAAgB9wB,EAAI+wB,EAAM,EAAG,K,cAAnC,SACA/wB,EAAG4xB,WAAWb,GAEd/wB,EAAG0B,WAAW5E,EAAQmG,GACtBjD,EAAG6xB,iBAAiB/0B,EAAQy0B,EAAeC,GAC3CxxB,EAAG0B,WAAW5E,EAAQ,M,WAjvBvB,uBAA4B9F,GAC3B,OAAOA,IAAS,EAAAuS,OAASvS,IAAS,EAAA0a,UACnC,EAMC,sBAQA,oBAQA,qBAA0B1a,GAC1B,OAAOsiB,EAAkBtiB,IAAS6wB,EAAgB7wB,EACnD,EAyBA,qBAsBA,kBAqDA,kBAiCA,aASA,+BACC,QAA+ByI,IAA3BsY,EAAQ+V,eAA8B,CACzC,IAAM9tB,EAAKxE,SAASe,cAAc,UAAU6D,WAAW,EAAAE,QAEvDyX,EAAQ+V,eAAiBptB,EAASV,E,CAEnC,OAAO+X,EAAQ+V,cAChB,EAMA,uBAA4B9tB,GAC3B,OAAOA,EAAGgW,uBAAuBhW,EAAGgJ,cAAgBhJ,EAAGwY,oBACxD,EAqDA,mCAeA,qCA4EA,6CACC,QAAuC/Y,IAAnCsY,EAAQkW,uBAAsC,CAQjD,IACM,EADSzyB,SAASe,cAAc,UACpB6D,WAAW,SAC7B,IAAK,EACJ,MAAM,IAAIwF,MAAM,iCAGjB,IAAMgqB,EAAK5pB,EAAc,EAAI,EAAAlF,MAAO,EAAAqlB,mBAAoB,EAAAA,mBAAoB,6QASzE,EAAGlgB,cAAe,6BAA8B,EAAAnG,wBACnD,IAAK8vB,EACJ,MAAM,IAAIhqB,MAAM,iCAGjB,IAAMiqB,EAAK7pB,EAAc,EAAI,EAAAlF,MAAO,EAAAqlB,mBAAoB,EAAAA,mBAAoB,+FAKzE,EAAG9M,gBAAiB,6BAA8B,EAAAvZ,wBACrD,IAAK+vB,EACJ,MAAM,IAAIjqB,MAAM,mCAMjB,IAAMpS,EAAQ,WAAK,IAAK,EAClB,EAAQ4E,KAAKiU,KAAK7Y,GAClBymB,EAAkE,KAArD,EAAQ7hB,KAAKiU,KAAK,EAAQ,EAAQ,GAAM,GAAM,IAAa,EAExE8jB,EAAQH,EACb,6BACA,EACAH,EACAD,GACA,SAACzqB,GACA,IAAM2sB,EAAY,EAAGjY,mBAAmB1U,EAAS,KACjD,EAAG4sB,UAAUD,EAAW,EAAO,EAAO,EACvC,IAGKE,EAAmB55B,KAAK+c,IAAIgb,EAAM,GAAKlW,GAAY,GACzDlC,EAAQkW,uBAAyB+D,EAAmB,EAAA7L,mBAAqB,EAAAnlB,gB,CAE1E,OAAO+W,EAAQkW,sBAChB,EAOA,+CACC,QAAyCxuB,IAArCsY,EAAQmW,yBAAwC,CAOnD,IACM,EADS1yB,SAASe,cAAc,UACpB6D,WAAW,SAC7B,IAAK,EACJ,MAAM,IAAIwF,MAAM,iCAGjB,IAAMgqB,EAAK5pB,EAAc,EAAI,EAAAlF,MAAO,EAAAqlB,mBAAoB,EAAAA,mBAAmB,6JAMxE,EAAGlgB,cAAe,+BAAgC,EAAAnG,wBACrD,IAAK8vB,EACJ,MAAM,IAAIhqB,MAAM,iCAGjB,IAAMiqB,EAAK7pB,EAAc,EAAI,EAAAlF,MAAO,EAAAqlB,mBAAoB,EAAAA,mBAAoB,iHAKzE,EAAG9M,gBAAiB,+BAAgC,EAAAvZ,wBACvD,IAAK+vB,EACJ,MAAM,IAAIjqB,MAAM,mCAMjB,IAAMpS,EAAQ,WAAK,IAAK,EAClB,EAAQ4E,KAAKiU,KAAK7Y,GAClBymB,EAAkE,KAArD,EAAQ7hB,KAAKiU,KAAK,EAAQ,EAAQ,GAAM,GAAM,IAAa,EAExE8jB,EAAQH,EACb,+BACA,EACAH,EACAD,GACA,SAACzqB,GACA,IAAM2sB,EAAY,EAAGjY,mBAAmB1U,EAAS,KACjD,EAAG4sB,UAAUD,EAAW,EAAO,EAAO,EACvC,IAGKE,EAAmB55B,KAAK+c,IAAIgb,EAAM,GAAKlW,GAAY,GACzDlC,EAAQmW,yBAA4B8D,EAAmB,EAAA7L,mBAAqB,EAAAnlB,gB,CAE7E,OAAO+W,EAAQmW,wBAChB,EAMA,sBAA2B16B,GAE1B,OAAOA,EAAQ,GAA8B,IAAxBA,EAASA,EAAQ,EACvC,EAMA,oCAAyCsC,GAExC,IADA,IAAM2d,EAAQ,IAAIjQ,aAAa1N,GACtB8C,EAAI,EAAGA,EAAI9C,EAAQ8C,IAC3B6a,EAAM7a,GAAKA,EAEZ,OAAO6a,CACR,EAmDA,iCAaA,kCAAuCkL,EAAsB/d,GAQ5D,OAPA+d,EAAeyR,EAAiBzR,GAE3B4J,MACJ/tB,QAAQC,KAAK,kFAEbkkB,GAAe,IAAAsT,gBAAetT,IAE3B/d,IAAgB,EAAAC,MACZ8d,EApCT,SAAoCA,GAMnC,OALAA,EAAe6R,EAAqB7R,GAEpCA,GAAe,IAAAuT,eAAcvT,IAEd,IAAAwT,gBAAexT,EAE/B,CA+BQyT,CAA2BzT,EACnC,EASA,oCAAyCA,EAAsB/d,EAA0BpE,G,MAYpFoiB,EAEJ,GAbAD,EAAeyR,EAAiBzR,IAChC,IAAA0T,iCAAgC1T,EAAc/d,EAAapE,GAEtDgsB,MACJhuB,QAAQC,KAAK,oFAEbkkB,GAAe,IAAAsT,gBAAetT,IAG/BA,GAAe,IAAA2T,yBAAwB3T,EAAc/d,GAAe+d,EAGjEA,GAAF,GAAoC,IAAA4T,iBAAgB5T,IAAtC,aAAEC,EAAe,kBAC5Bhe,IAAgB,EAAAC,MAAO,CAG1B,IAFA,IAAM2xB,EAAUrZ,EAA6BwF,EAAcniB,GAElD5D,EAAI,EAAG65B,EAAaD,EAAQ18B,OAAQ8C,EAAI65B,EAAY75B,IAE5D45B,EAAQ55B,IAAK,IAAA85B,gBAAeF,EAAQ55B,IAAM45B,EAAQ55B,GAGnD,GADA+lB,EAAe6T,EAAQG,QACnBH,EAAQ18B,OACX,MAAO,CAAE6oB,aAAY,EAAEC,gBAAe,EAAEC,kBAAmB2T,E,CAG7D,MAAO,CAAE7T,aAAY,EAAEC,gBAAe,EACvC,EAMA,uCACCprB,EACAwD,EACA4pB,EACAjb,GAEA,GAAI3O,IAAS,EAAAuS,MAAO,CAEnB,IAAI,IAAAxU,SAAQvB,IACX,IAAK,IAAIoF,EAAI,EAAGA,EAAKpF,EAAmBsC,OAAQ8C,IAC/C,KAAK,IAAAjF,gBAAgBH,EAAmBoF,IACvC,MAAM,IAAIgN,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,qDAIhH,KAAK,IAAAhS,gBAAeH,GACnB,MAAM,IAAIoS,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,gDAGhH,KAAK,IAAA5Q,SAAQvB,IAAyC,IAA9BA,EAAmBsC,OAC1C,OAAO,EAAAyrB,iBAER,GAAmC,IAA9B/tB,EAAmBsC,OACvB,OAAO,EAAA0rB,iBAER,GAAmC,IAA9BhuB,EAAmBsC,OACvB,OAAO,EAAA2rB,iBAER,GAAmC,IAA9BjuB,EAAmBsC,OACvB,OAAO,EAAA4rB,iBAER,MAAM,IAAI9b,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,+C,CACxG,GAAI3O,IAAS,EAAAmW,IAAK,CAExB,IAAI,IAAApY,SAAQvB,IACX,IAASoF,EAAI,EAAGA,EAAKpF,EAAmBsC,OAAQ8C,IAC/C,KAAK,IAAA/E,WAAWL,EAAmBoF,IAClC,MAAM,IAAIgN,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,iDAIhH,KAAK,IAAA9R,WAAUL,GACd,MAAM,IAAIoS,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,4CAGhH,KAAK,IAAA5Q,SAAQvB,IAAyC,IAA9BA,EAAmBsC,OAC1C,OAAO,EAAA6rB,eAER,GAAmC,IAA9BnuB,EAAmBsC,OACvB,OAAO,EAAA8rB,eAER,GAAmC,IAA9BpuB,EAAmBsC,OACvB,OAAO,EAAA+rB,eAER,GAAmC,IAA9BruB,EAAmBsC,OACvB,OAAO,EAAAgsB,eAER,MAAM,IAAIlc,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,2C,CACxG,GAAI3O,IAAS,EAAAgvB,KAAM,CAEzB,IAAI,IAAAjxB,SAAQvB,IACX,IAASoF,EAAI,EAAGA,EAAKpF,EAAmBsC,OAAQ8C,IAC/C,KAAK,IAAAzE,sBAAsBX,EAAmBoF,IAC7C,MAAM,IAAIgN,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,mDAIhH,KAAK,IAAAxR,sBAAqBX,GACzB,MAAM,IAAIoS,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,8CAGhH,KAAK,IAAA5Q,SAAQvB,IAAyC,IAA9BA,EAAmBsC,OAC1C,OAAO,EAAAisB,gBAER,GAAmC,IAA9BvuB,EAAmBsC,OACvB,OAAO,EAAAksB,gBAER,GAAmC,IAA9BxuB,EAAmBsC,OACvB,OAAO,EAAAmsB,gBAER,GAAmC,IAA9BzuB,EAAmBsC,OACvB,OAAO,EAAAosB,gBAER,MAAM,IAAItc,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,6C,CACxG,GAAI3O,IAAS,EAAA+uB,KAAM,CAEzB,IAAI,IAAAhxB,SAAQvB,IACX,IAASoF,EAAI,EAAGA,EAAKpF,EAAoBsC,OAAQ8C,IAChD,KAAK,IAAA1D,WAAW1B,EAAoBoF,IACnC,MAAM,IAAIgN,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,mDAIhH,KAAK,IAAAzQ,WAAU1B,GACd,MAAM,IAAIoS,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,8CAGhH,KAAK,IAAA5Q,SAAQvB,IAAyC,IAA9BA,EAAmBsC,OAC1C,OAAO,EAAAqrB,gBAER,GAAmC,IAA9B3tB,EAAmBsC,OACvB,OAAO,EAAAsrB,gBAER,GAAmC,IAA9B5tB,EAAmBsC,OACvB,OAAO,EAAAurB,gBAER,GAAmC,IAA9B7tB,EAAmBsC,OACvB,OAAO,EAAAwrB,gBAER,MAAM,IAAI1b,MAAM,wBAAiBM,KAAKC,UAAU3S,GAAM,yBAAiBotB,EAAW,yBAAiBjb,EAAW,wB,CAE9G,MAAM,IAAIC,MAAM,wBAAiB5O,EAAI,0BAAkB4pB,EAAW,yBAAiBjb,EAAW,uBAAe,EAAA4D,MAAK,eAAO,EAAA4D,IAAG,eAAO,EAAA4Y,KAAI,KAEzI,EAOA,+BAAoCrf,EAAiB+M,GACpD,OAAOA,EAAMmf,WAAU,SAAAC,GAAQ,OAAAA,IAASnsB,GAAUmsB,EAAuBnsB,QAAUA,CAApD,GAChC,EAwDA,2BACC1G,EACAkP,EAAWC,EACXsW,EAAWtpB,EACX5E,EACAP,EACAw6B,G,gGAQA,OANMl8B,EAAM0K,EAAGkD,eACflD,EAAG0B,WAAW1B,EAAG8yB,kBAAmBx9B,GACpC0K,EAAGmD,WAAWnD,EAAG8yB,kBAAmBtB,EAAUuB,WAAY/yB,EAAGgzB,aAC7DhzB,EAAG4W,WAAW1H,EAAGC,EAAGsW,EAAGtpB,EAAG5E,EAAQP,EAAM,GACxCgJ,EAAG0B,WAAW1B,EAAG8yB,kBAAmB,MAEpC,GAAMxB,EAAsBtxB,EAAIA,EAAG8yB,kBAAmBx9B,EAAK,EAAGk8B,I,OAG9D,OAHA,SAEAxxB,EAAGsQ,aAAahb,GACT,CAAP,EAAOk8B,G,oCCz2BRr8B,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQwjB,WASR,SAAoBuc,EAAUC,KAAeC,GAC3C,OAAO,EAAIC,EAAWC,kBAAiB,EAAIC,EAAaC,4BAA4BN,EAAUC,MAAe,EAAIM,EAAeC,cAAcN,IAChJ,EAVAjgC,EAAQ8lB,WAYR,SAAoBia,EAAUC,EAAY1/B,KAAU2/B,GAClD,OAAO,EAAIG,EAAaI,4BAA4BT,EAAUC,GAAY,EAAIE,EAAWO,oBAAoBngC,OAAW,EAAIggC,EAAeC,cAAcN,GAC3J,EAZA,IAAIK,EAAiB,EAAQ,KAEzBJ,EAAa,EAAQ,KAErBE,EAAe,EAAQ,I,6BCV3Bn+B,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQ0gC,eAAiBA,EAEzB,IAAIJ,EAAiB,EAAQ,KAEzBK,EAAS,EAAQ,KAEjBT,EAAa,EAAQ,KAErBU,EAAM,EAAQ,KAEdC,EAAY,EAAQ,KAEpBT,EAAe,EAAQ,KAEvBU,EAAQ,EAAQ,KAEpB,MACMC,EAAoB,IAAIX,EAAaY,cAE3C,SAASN,EAAe92B,GACtB,OAAO,EAAIw2B,EAAaa,qBAAqBF,EAAmBn3B,MAAY,EAAIw2B,EAAac,mBAAmBt3B,KAAW,EAAI+2B,EAAOQ,sBAAsBv3B,EAC9J,CAEA,SAASw3B,EAAmBx3B,GAC1B,IAAK82B,EAAe92B,GAClB,MAAM,EAAIw2B,EAAaiB,iBAAiBR,EAAUS,kCAEtD,CAEA,SAASC,EAAwB33B,EAAQ6P,GACvC,MAAM+nB,EAAuBd,EAAe92B,GACtC63B,GAAqB,EAAIb,EAAIc,oBAAoB93B,GAEvD,IAAK43B,IAAyBC,EAC5B,MAAM,EAAIrB,EAAaiB,iBAAiBR,EAAUc,oDAGpD,GAAqB,iBAAVloB,EAAoB,CAC7B,IAAI7W,EAEJ,GAAI4+B,EAAsB,CACxB,MAAMI,EAAmBC,EAAoBj4B,GAC7ChH,GAAS,EAAIw9B,EAAa0B,8BAA8BF,EAC1D,MACEh/B,GAAS,EAAIw9B,EAAa0B,8BAA8Bl4B,GAG1D,GAAIhH,EAAS6W,EACX,MAAM,EAAI2mB,EAAaiB,iBAAiBR,EAAUkB,yEAEtD,CAEA,IAAI,EAAInB,EAAIoB,0BAA0Bp4B,GACpC,MAAM,EAAIw2B,EAAaiB,iBAAiBR,EAAUoB,kCAEtD,CAEA,SAASJ,EAAoBK,GAC3B,MAAMN,GAAmB,EAAIxB,EAAa+B,qBAAqBpB,EAAmBmB,GAElF,QAAyB31B,IAArBq1B,EAAgC,CAClC,MAAM7xB,GAAS,EAAIqwB,EAAagC,8BAA8BR,GAE9D,IAAI,EAAId,EAAMuB,kBAAkBtyB,GAC9B,MAAM,EAAIqwB,EAAaiB,iBAAiBR,EAAUyB,2CAGpD,OAAOV,CACT,CAEA,MAAM7xB,EAASmyB,EAAQnyB,OAEvB,IAAI,EAAI+wB,EAAMuB,kBAAkBtyB,GAC9B,MAAM,EAAIqwB,EAAaiB,iBAAiBR,EAAUyB,2CAGpD,MAAMC,GAAS,EAAInC,EAAaoC,kBAAkBC,EAAc,CAAC1yB,EAAQmyB,EAAQlC,WAAYkC,EAAQt/B,QAASs/B,EAAQzuB,aACtH,OAAO,EAAI2sB,EAAa+B,qBAAqBpB,EAAmBwB,EAClE,CAEA,SAASG,EAAYd,GACnB,MAAMh/B,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxDrhB,EAAQ,GAEd,IAAK,IAAI7a,EAAI,EAAGA,EAAI9C,IAAU8C,EAC5B6a,EAAM7a,IAAK,EAAIw6B,EAAWC,iBAAiByB,EAAiBl8B,IAG9D,OAAO6a,CACT,CAEA,MAAMoiB,EAA6B,IAAIvC,EAAawC,cAEpD,IAAK,MAAMnzB,KAAO,EAAI2wB,EAAayC,gBAAgBzC,EAAa0C,qBAAsB,CACpF,GAAIrzB,IAAQ2wB,EAAa2C,kBACvB,SAGF,MAAMC,GAAa,EAAI5C,EAAa6C,iCAAiC7C,EAAa0C,oBAAqBrzB,IAEnG,EAAI2wB,EAAa8C,cAAcF,EAAY,QAAoC,mBAAnBA,EAAWxe,MACzE,EAAI4b,EAAa+C,qBAAqBR,EAA4BK,EAAWxe,IAEjF,CAEA,MAAM4e,GAAU,EAAIhD,EAAaiD,cAAc,CAC7C7e,IAAG,CAAC5a,EAAQ6F,EAAK6zB,KACX,EAAI1C,EAAI2C,+BAA+B9zB,KAAQ,EAAI2wB,EAAa8C,cAAct5B,EAAQ6F,IACjF,EAAIywB,EAAWC,kBAAiB,EAAIC,EAAaoD,YAAY55B,EAAQ6F,KAG1E,EAAI2wB,EAAaqD,qBAAqBd,GAA4B,EAAIvC,EAAasD,iCAAiC95B,EAAQ6F,KACvH,EAAI2wB,EAAaoD,YAAY55B,EAAQ6F,IAGvC,EAAI2wB,EAAaoD,YAAY55B,EAAQ6F,EAAK6zB,GAGnDt8B,IAAG,CAAC4C,EAAQ6F,EAAKnP,EAAOgjC,KAClB,EAAI1C,EAAI2C,+BAA+B9zB,KAAQ,EAAI2wB,EAAa8C,cAAct5B,EAAQ6F,IACjF,EAAI2wB,EAAauD,YAAY/5B,EAAQ6F,GAAK,EAAIywB,EAAWO,oBAAoBngC,KAG/E,EAAI8/B,EAAauD,YAAY/5B,EAAQ6F,EAAKnP,EAAOgjC,GAG1DM,yBAAyBh6B,EAAQ6F,GAC/B,IAAI,EAAImxB,EAAI2C,+BAA+B9zB,KAAQ,EAAI2wB,EAAa8C,cAAct5B,EAAQ6F,GAAM,CAC9F,MAAMuzB,GAAa,EAAI5C,EAAa6C,iCAAiCr5B,EAAQ6F,GAE7E,OADAuzB,EAAW1iC,OAAQ,EAAI4/B,EAAWC,iBAAiB6C,EAAW1iC,OACvD0iC,CACT,CAEA,OAAO,EAAI5C,EAAa6C,iCAAiCr5B,EAAQ6F,EACnE,EAEAvN,eAAc,CAAC0H,EAAQ6F,EAAKuzB,KACtB,EAAIpC,EAAI2C,+BAA+B9zB,KAAQ,EAAI2wB,EAAa8C,cAAct5B,EAAQ6F,KAAQ,EAAI2wB,EAAa8C,cAAcF,EAAY,UAC3IA,EAAW1iC,OAAQ,EAAI4/B,EAAWO,oBAAoBuC,EAAW1iC,QAC1D,EAAI8/B,EAAayD,uBAAuBj6B,EAAQ6F,EAAKuzB,KAGvD,EAAI5C,EAAayD,uBAAuBj6B,EAAQ6F,EAAKuzB,KAKhE,MAAMP,EACJhvB,YAAYvB,EAAO4xB,EAAaxlB,GAC9B,IAAIsjB,EAEJ,GAAIlB,EAAexuB,GACjB0vB,GAAmB,EAAIxB,EAAaoC,kBAAkBpC,EAAa2D,kBAAmB,CAAClC,EAAoB3vB,qBACtG,IAAI,EAAI0uB,EAAI7+B,UAAUmQ,MAAW,EAAI0uB,EAAIoD,eAAe9xB,GAAQ,CACrE,IAAI+xB,EACArhC,EAEJ,IAAI,EAAIg+B,EAAIc,oBAAoBxvB,GAAQ,CACtC+xB,EAAO/xB,EACPtP,GAAS,EAAIw9B,EAAa0B,8BAA8B5vB,GACxD,MAAMnC,GAAS,EAAIqwB,EAAagC,8BAA8BlwB,GACxDgyB,GAAqB,EAAItD,EAAIuD,qBAAqBp0B,GAAkFqwB,EAAagE,mBAArF,EAAItD,EAAMuD,oBAAoBt0B,EAAQqwB,EAAagE,mBAErH,IAAI,EAAItD,EAAMuB,kBAAkBtyB,GAC9B,MAAM,EAAIqwB,EAAaiB,iBAAiBR,EAAUyB,2CAGpD,IAAI,EAAI1B,EAAIoB,0BAA0B9vB,GACpC,MAAM,EAAIkuB,EAAaiB,iBAAiBR,EAAUoB,mCAGpD,MAAMr9B,EAAO,IAAIs/B,EA3JC,EA2JiBthC,GACnCg/B,GAAmB,EAAIxB,EAAaoC,kBAAkBpC,EAAa2D,kBAAmB,CAACn/B,cACzF,KAAO,CACL,MAAM0/B,EAAWpyB,EAAMkuB,EAAamE,gBAEpC,GAAgB,MAAZD,GAAwC,mBAAbA,EAC7B,MAAM,EAAIlE,EAAaiB,iBAAiBR,EAAU2D,mCAGpC,MAAZF,GACE,EAAI1D,EAAI6D,iBAAiBvyB,IAC3B+xB,EAAO/xB,EACPtP,EAASsP,EAAMtP,SAEfqhC,EAAO,IAAI/xB,GACXtP,EAASqhC,EAAKrhC,SAGhBqhC,EAAO/xB,EACPtP,GAAS,EAAIk+B,EAAM4D,UAAUT,EAAKrhC,SAGpCg/B,GAAmB,EAAIxB,EAAaoC,kBAAkBpC,EAAa2D,kBAAmB,CAACnhC,cACzF,CAEA,IAAK,IAAI8C,EAAI,EAAGA,EAAI9C,IAAU8C,EAC5Bk8B,EAAiBl8B,IAAK,EAAIw6B,EAAWO,oBAAoBwD,EAAKv+B,GAElE,MACEk8B,GAAmB,EAAIxB,EAAaoC,kBAAkBpC,EAAa2D,kBAAmBY,sBAGxF,MAAMC,EAAQ,IAAIxE,EAAayE,YAAYjD,EAAkBwB,GAE7D,OADA,EAAIhD,EAAa0E,qBAAqB/D,EAAmB6D,EAAOhD,GACzDgD,CACT,CAEAG,YAAY15B,KAAQ40B,GAClB,MAAM+E,EAAcx4B,KAEpB,KAAK,EAAI4zB,EAAa6E,YAAYD,EAAarE,EAAOuE,OACpD,MAAM,EAAI9E,EAAaiB,iBAAiBR,EAAUsE,oDAGpD,GAAIH,IAAgBvC,EAAc,CAChC,GAAI/B,EAAer1B,IAAwB,IAAhB40B,EAAKr9B,OAAc,CAC5C,MAAMg/B,EAAmBC,EAAoBx2B,GACvC+5B,EAAS,IAAIhF,EAAa2D,mBAAkB,EAAI3D,EAAagC,8BAA8BR,IAAmB,EAAIxB,EAAaiF,kCAAkCzD,IAAmB,EAAIxB,EAAa0B,8BAA8BF,IACzO,OAAO,IAAIa,GAAa,EAAIrC,EAAagC,+BAA8B,EAAIhC,EAAakF,0BAA0BF,IACpH,CAEA,GAAoB,IAAhBnF,EAAKr9B,OACP,OAAO,IAAI6/B,GAAa,EAAIrC,EAAagC,+BAA8B,EAAIhC,EAAamF,iBAAiBl6B,EAAK60B,EAAWO,sBAG3H,MAAM+E,EAAUvF,EAAK,GACfwF,EAAUxF,EAAK,GACrB,OAAO,IAAIwC,GAAa,EAAIrC,EAAagC,+BAA8B,EAAIhC,EAAamF,iBAAiBl6B,GAAK,SAAUkb,KAAQmf,GAC9H,OAAO,EAAIxF,EAAWO,qBAAoB,EAAIL,EAAauF,cAAcH,EAASh5B,KAAM,CAAC+Z,MAAQ,EAAI+Z,EAAeC,cAAcmF,KACpI,GAAGD,IACL,CAEA,IAAIxB,EACArhC,EACJ,MAAM0hC,EAAWj5B,EAAI+0B,EAAamE,gBAElC,GAAgB,MAAZD,GAAwC,mBAAbA,EAC7B,MAAM,EAAIlE,EAAaiB,iBAAiBR,EAAU2D,mCAGpD,GAAgB,MAAZF,GACE,EAAI1D,EAAI6D,iBAAiBp5B,IAC3B44B,EAAO54B,EACPzI,EAASyI,EAAIzI,SACJ,EAAIg+B,EAAIgF,4BAA4Bv6B,IAC7C44B,EAAO54B,EACPzI,GAAS,EAAIw9B,EAAa0B,8BAA8Bz2B,KAExD44B,EAAO,IAAI54B,GACXzI,EAASqhC,EAAKrhC,YAEX,CACL,GAAW,MAAPyI,EACF,MAAM,EAAI+0B,EAAaiB,iBAAiBR,EAAUgF,4CAGpD5B,GAAO,EAAI7D,EAAa0F,cAAcz6B,GACtCzI,GAAS,EAAIk+B,EAAM4D,UAAUT,EAAKrhC,OACpC,CAEA,MAAM2d,EAAQ,IAAIykB,EAAYpiC,GAE9B,GAAoB,IAAhBq9B,EAAKr9B,OACP,IAAK,IAAI8C,EAAI,EAAGA,EAAI9C,IAAU8C,EAC5B6a,EAAM7a,GAAKu+B,EAAKv+B,OAEb,CACL,MAAM8/B,EAAUvF,EAAK,GACfwF,EAAUxF,EAAK,GAErB,IAAK,IAAIv6B,EAAI,EAAGA,EAAI9C,IAAU8C,EAC5B6a,EAAM7a,IAAK,EAAI06B,EAAauF,cAAcH,EAASC,EAAS,CAACxB,EAAKv+B,GAAIA,GAE1E,CAEA,OAAO6a,CACT,CAEAwkB,aAAagB,GACX,MAAMf,EAAcx4B,KAEpB,KAAK,EAAI4zB,EAAa6E,YAAYD,EAAarE,EAAOuE,OACpD,MAAM,EAAI9E,EAAaiB,iBAAiBR,EAAUsE,oDAGpD,MAAMviC,EAASmjC,EAAMnjC,OAErB,GAAIoiC,IAAgBvC,EAAc,CAChC,MAAMmC,EAAQ,IAAInC,EAAa7/B,GACzBg/B,EAAmBC,EAAoB+C,GAE7C,IAAK,IAAIl/B,EAAI,EAAGA,EAAI9C,IAAU8C,EAC5Bk8B,EAAiBl8B,IAAK,EAAIw6B,EAAWO,oBAAoBsF,EAAMrgC,IAGjE,OAAOk/B,CACT,CAEA,MAAMrkB,EAAQ,IAAIykB,EAAYpiC,GAE9B,IAAK,IAAI8C,EAAI,EAAGA,EAAI9C,IAAU8C,EAC5B6a,EAAM7a,GAAKqgC,EAAMrgC,GAGnB,OAAO6a,CACT,CAEAnU,OACEg1B,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MAC7C,OAAO,EAAI4zB,EAAa4F,yBAAyBpE,EACnD,CAEArkB,SACE6jB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MAC7C,OAAO,EAAI8zB,EAAepgB,MAAM,YAC9B,IAAK,MAAMqG,KAAO,EAAI6Z,EAAa6F,2BAA2BrE,SACtD,EAAI1B,EAAWC,iBAAiB5Z,EAE1C,CAJgC,GAKlC,CAEA2f,UACE9E,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MAC7C,OAAO,EAAI8zB,EAAepgB,MAAM,YAC9B,IAAK,MAAOxa,EAAG6gB,KAAQ,EAAI6Z,EAAa+F,4BAA4BvE,QAC5D,CAACl8B,GAAG,EAAIw6B,EAAWC,iBAAiB5Z,GAE9C,CAJgC,GAKlC,CAEA6f,GAAGpkB,GACDof,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxDyE,GAAgB,EAAIvF,EAAMwF,qBAAqBtkB,GAC/Ctf,EAAI2jC,GAAiB,EAAIA,EAAgBzjC,EAASyjC,EAExD,KAAI3jC,EAAI,GAAKA,GAAKE,GAIlB,OAAO,EAAIs9B,EAAWC,iBAAiByB,EAAiBl/B,GAC1D,CAEA+nB,IAAIpO,KAAa4jB,GACfmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GACf+E,GAAc,EAAIlE,EAAMuD,oBAAoBzC,EAAkBa,GAEpE,GAAIuC,IAAgBvC,EAAc,CAChC,MAAMmC,EAAQ,IAAInC,EAAa7/B,GACzB2d,EAAQshB,EAAoB+C,GAElC,IAAK,IAAIl/B,EAAI,EAAGA,EAAI9C,IAAU8C,EAAG,CAC/B,MAAM6gB,GAAM,EAAI2Z,EAAWC,iBAAiByB,EAAiBl8B,IAC7D6a,EAAM7a,IAAK,EAAIw6B,EAAWO,qBAAoB,EAAIL,EAAauF,cAActpB,EAAUopB,EAAS,CAAClf,EAAK7gB,EAAG8G,OAC3G,CAEA,OAAOo4B,CACT,CAEA,MAAMrkB,EAAQ,IAAIykB,EAAYpiC,GAC9B2+B,EAAwBhhB,EAAO3d,GAE/B,IAAK,IAAI8C,EAAI,EAAGA,EAAI9C,IAAU8C,EAAG,CAC/B,MAAM6gB,GAAM,EAAI2Z,EAAWC,iBAAiByB,EAAiBl8B,IAC7D6a,EAAM7a,IAAK,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,CAAClf,EAAK7gB,EAAG8G,MACxE,CAEA,OAAO+T,CACT,CAEA5O,OAAO0K,KAAa4jB,GAClBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GACfsG,EAAO,GAEb,IAAK,IAAI7gC,EAAI,EAAGA,EAAI9C,IAAU8C,EAAG,CAC/B,MAAM6gB,GAAM,EAAI2Z,EAAWC,iBAAiByB,EAAiBl8B,KAEzD,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,CAAClf,EAAK7gB,EAAG8G,SAC7D,EAAI4zB,EAAaoG,oBAAoBD,EAAMhgB,EAE/C,CAEA,MACMhG,EAAQ,KADM,EAAIugB,EAAMuD,oBAAoBzC,EAAkBa,GACtD,CAAgB8D,GAE9B,OADAhF,EAAwBhhB,GACjBA,CACT,CAEAkmB,OAAOpqB,KAAa4jB,GAClBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GAE9D,GAAe,IAAXh/B,GAAgC,IAAhBq9B,EAAKr9B,OACvB,MAAM,EAAIw9B,EAAaiB,iBAAiBR,EAAU6F,6CAGpD,IAAIC,EAAaC,EAEG,IAAhB3G,EAAKr9B,QACP+jC,GAAc,EAAIzG,EAAWC,iBAAiByB,EAAiB,IAC/DgF,EAAQ,IAERD,EAAc1G,EAAK,GACnB2G,EAAQ,GAGV,IAAK,IAAIlhC,EAAIkhC,EAAOlhC,EAAI9C,IAAU8C,EAChCihC,EAActqB,EAASsqB,GAAa,EAAIzG,EAAWC,iBAAiByB,EAAiBl8B,IAAKA,EAAG8G,MAG/F,OAAOm6B,CACT,CAEAE,YAAYxqB,KAAa4jB,GACvBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GAE9D,GAAe,IAAXh/B,GAAgC,IAAhBq9B,EAAKr9B,OACvB,MAAM,EAAIw9B,EAAaiB,iBAAiBR,EAAU6F,6CAGpD,IAAIC,EAAaC,EAEG,IAAhB3G,EAAKr9B,QACP+jC,GAAc,EAAIzG,EAAWC,iBAAiByB,EAAiBh/B,EAAS,IACxEgkC,EAAQhkC,EAAS,IAEjB+jC,EAAc1G,EAAK,GACnB2G,EAAQhkC,EAAS,GAGnB,IAAK,IAAI8C,EAAIkhC,EAAOlhC,GAAK,IAAKA,EAC5BihC,EAActqB,EAASsqB,GAAa,EAAIzG,EAAWC,iBAAiByB,EAAiBl8B,IAAKA,EAAG8G,MAG/F,OAAOm6B,CACT,CAEAtpB,QAAQhB,KAAa4jB,GACnBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GAErB,IAAK,IAAIv6B,EAAI,EAAGA,EAAI9C,IAAU8C,GAC5B,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,EAAC,EAAIvF,EAAWC,iBAAiByB,EAAiBl8B,IAAKA,EAAG8G,MAEhH,CAEA4jB,KAAK/T,KAAa4jB,GAChBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GAErB,IAAK,IAAIv6B,EAAI,EAAGA,EAAI9C,IAAU8C,EAAG,CAC/B,MAAMpF,GAAQ,EAAI4/B,EAAWC,iBAAiByB,EAAiBl8B,IAE/D,IAAI,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,CAACnlC,EAAOoF,EAAG8G,OAC/D,OAAOlM,CAEX,CACF,CAEAo/B,UAAUrjB,KAAa4jB,GACrBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GAErB,IAAK,IAAIv6B,EAAI,EAAGA,EAAI9C,IAAU8C,EAAG,CAC/B,MAAMpF,GAAQ,EAAI4/B,EAAWC,iBAAiByB,EAAiBl8B,IAE/D,IAAI,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,CAACnlC,EAAOoF,EAAG8G,OAC/D,OAAO9G,CAEX,CAEA,OAAQ,CACV,CAEAohC,SAASzqB,KAAa4jB,GACpBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GAErB,IAAK,IAAIv6B,EAAI9C,EAAS,EAAG8C,GAAK,IAAKA,EAAG,CACpC,MAAMpF,GAAQ,EAAI4/B,EAAWC,iBAAiByB,EAAiBl8B,IAE/D,IAAI,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,CAACnlC,EAAOoF,EAAG8G,OAC/D,OAAOlM,CAEX,CACF,CAEAymC,cAAc1qB,KAAa4jB,GACzBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GAErB,IAAK,IAAIv6B,EAAI9C,EAAS,EAAG8C,GAAK,IAAKA,EAAG,CACpC,MAAMpF,GAAQ,EAAI4/B,EAAWC,iBAAiByB,EAAiBl8B,IAE/D,IAAI,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,CAACnlC,EAAOoF,EAAG8G,OAC/D,OAAO9G,CAEX,CAEA,OAAQ,CACV,CAEAshC,MAAM3qB,KAAa4jB,GACjBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GAErB,IAAK,IAAIv6B,EAAI,EAAGA,EAAI9C,IAAU8C,EAC5B,KAAK,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,EAAC,EAAIvF,EAAWC,iBAAiByB,EAAiBl8B,IAAKA,EAAG8G,OAC/G,OAAO,EAIX,OAAO,CACT,CAEAy6B,KAAK5qB,KAAa4jB,GAChBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxD6D,EAAUxF,EAAK,GAErB,IAAK,IAAIv6B,EAAI,EAAGA,EAAI9C,IAAU8C,EAC5B,IAAI,EAAI06B,EAAauF,cAActpB,EAAUopB,EAAS,EAAC,EAAIvF,EAAWC,iBAAiByB,EAAiBl8B,IAAKA,EAAG8G,OAC9G,OAAO,EAIX,OAAO,CACT,CAEAxF,IAAIkL,KAAU+tB,GACZmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC06B,GAAe,EAAIpG,EAAMwF,qBAAqBrG,EAAK,IAEzD,GAAIiH,EAAe,EACjB,MAAM,EAAI9G,EAAa+G,kBAAkBtG,EAAUuG,yBAGrD,GAAa,MAATl1B,EACF,MAAM,EAAIkuB,EAAaiB,iBAAiBR,EAAUgF,4CAGpD,IAAI,EAAIjF,EAAIoB,0BAA0B9vB,GACpC,MAAM,EAAIkuB,EAAaiB,iBAAiBR,EAAUoB,mCAGpD,GAAIvB,EAAexuB,GACjB,OAAO,EAAIkuB,EAAaiH,wBAAwBxF,EAAoBr1B,MAAOq1B,EAAoB3vB,GAAQg1B,GAGzG,IAAI,EAAItG,EAAIc,oBAAoBxvB,GAAQ,CACtC,MAAMnC,GAAS,EAAIqwB,EAAagC,8BAA8BlwB,GAE9D,IAAI,EAAI4uB,EAAMuB,kBAAkBtyB,GAC9B,MAAM,EAAIqwB,EAAaiB,iBAAiBR,EAAUyB,0CAEtD,CAEA,MAAMgF,GAAe,EAAIlH,EAAa0B,8BAA8BF,GAC9Dv2B,GAAM,EAAI+0B,EAAa0F,cAAc5zB,GACrCq1B,GAAY,EAAIzG,EAAM4D,UAAUr5B,EAAIzI,QAE1C,GAAIskC,IAAiB/f,KAAYogB,EAAYL,EAAeI,EAC1D,MAAM,EAAIlH,EAAa+G,kBAAkBtG,EAAUuG,yBAGrD,IAAK,IAAI1hC,EAAI,EAAGA,EAAI6hC,IAAa7hC,EAC/Bk8B,EAAiBl8B,EAAIwhC,IAAgB,EAAIhH,EAAWO,oBAAoBp1B,EAAI3F,GAEhF,CAEA8hC,UACEpG,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MAE7C,OADA,EAAI4zB,EAAaqH,4BAA4B7F,GACtCp1B,IACT,CAEA+jB,KAAKjwB,KAAU2/B,GACbmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MAE7C,OADA,EAAI4zB,EAAasH,yBAAyB9F,GAAkB,EAAI1B,EAAWO,oBAAoBngC,OAAW,EAAIggC,EAAeC,cAAcN,IACpIzzB,IACT,CAEAm7B,WAAW/9B,EAAQg9B,KAAU3G,GAC3BmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MAE7C,OADA,EAAI4zB,EAAawH,+BAA+BhG,EAAkBh4B,EAAQg9B,MAAU,EAAItG,EAAeC,cAAcN,IAC9GzzB,IACT,CAEAq7B,KAAKC,GACH1G,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvCu7B,OAA4Bx7B,IAAdu7B,EAA0BA,EAAYhH,EAAMkH,eAIhE,OAHA,EAAI5H,EAAa6H,yBAAyBrG,GAAkB,CAAC5lB,EAAGC,IACvD8rB,GAAY,EAAI7H,EAAWC,iBAAiBnkB,IAAI,EAAIkkB,EAAWC,iBAAiBlkB,MAElFzP,IACT,CAEAvJ,MAAM2jC,EAAOsB,GACX9G,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvCw4B,GAAc,EAAIlE,EAAMuD,oBAAoBzC,EAAkBa,GAEpE,GAAIuC,IAAgBvC,EAAc,CAChC,MAAM2C,EAAS,IAAIhF,EAAa2D,mBAAkB,EAAI3D,EAAagC,8BAA8BR,IAAmB,EAAIxB,EAAaiF,kCAAkCzD,IAAmB,EAAIxB,EAAa0B,8BAA8BF,IACzO,OAAO,IAAIa,GAAa,EAAIrC,EAAagC,+BAA8B,EAAIhC,EAAakF,0BAA0BF,EAAQwB,EAAOsB,IACnI,CAEA,MAAMtlC,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GACxDuG,GAAgB,EAAIrH,EAAMwF,qBAAqBM,GAC/CwB,OAAsB77B,IAAR27B,EAAoBtlC,GAAS,EAAIk+B,EAAMwF,qBAAqB4B,GAChF,IAAIxlC,EAUA2lC,EAPF3lC,EADEylC,KAAmBhhB,IACjB,EACKghB,EAAgB,EACrBvlC,EAASulC,EAAgB,EAAIvlC,EAASulC,EAAgB,EAEtDvlC,EAASulC,EAAgBvlC,EAASulC,EAMtCE,EADED,KAAiBjhB,IACX,EACCihB,EAAc,EACfxlC,EAASwlC,EAAc,EAAIxlC,EAASwlC,EAAc,EAElDxlC,EAASwlC,EAAcxlC,EAASwlC,EAG1C,MAAM3uB,EAAQ4uB,EAAQ3lC,EAAI,EAAI2lC,EAAQ3lC,EAAI,EACpC6d,EAAQ,IAAIykB,EAAYvrB,GAG9B,GAFA8nB,EAAwBhhB,EAAO9G,GAEjB,IAAVA,EACF,OAAO8G,EAGT,MAAMxQ,GAAS,EAAIqwB,EAAagC,8BAA8BR,GAE9D,IAAI,EAAId,EAAMuB,kBAAkBtyB,GAC9B,MAAM,EAAIqwB,EAAaiB,iBAAiBR,EAAUyB,2CAGpD,IAAI7/B,EAAI,EAER,KAAOC,EAAI2lC,GACT9nB,EAAM9d,IAAK,EAAIy9B,EAAWC,iBAAiByB,EAAiBl/B,MAC1DA,IACAD,EAGJ,OAAO8d,CACT,CAEA+nB,SAASC,EAAOL,GACd9G,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvCw4B,GAAc,EAAIlE,EAAMuD,oBAAoBzC,EAAkBa,GAC9D2C,EAAS,IAAIhF,EAAa2D,mBAAkB,EAAI3D,EAAagC,8BAA8BR,IAAmB,EAAIxB,EAAaiF,kCAAkCzD,IAAmB,EAAIxB,EAAa0B,8BAA8BF,IACnO4G,GAAiB,EAAIpI,EAAaqI,6BAA6BrD,EAAQmD,EAAOL,GAC9E3nB,EAAQ,IAAIykB,GAAY,EAAI5E,EAAagC,8BAA8BoG,IAAiB,EAAIpI,EAAaiF,kCAAkCmD,IAAiB,EAAIpI,EAAa0B,8BAA8B0G,IAEjN,OADAjH,EAAwBhhB,GACjBA,CACT,CAEA9b,QAAQikC,KAAYzI,GAClBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GAC9D,IAAIx7B,GAAO,EAAI06B,EAAMwF,qBAAqBrG,EAAK,IAE/C,GAAI75B,IAAS+gB,IACX,OAAQ,EAGN/gB,EAAO,IACTA,GAAQxD,EAEJwD,EAAO,IACTA,EAAO,IAIX,IAAK,IAAIV,EAAIU,EAAMV,EAAI9C,IAAU8C,EAC/B,IAAI,EAAI06B,EAAa8C,cAActB,EAAkBl8B,KAAM,EAAIw6B,EAAWC,iBAAiByB,EAAiBl8B,MAAQgjC,EAClH,OAAOhjC,EAIX,OAAQ,CACV,CAEAijC,YAAYD,KAAYzI,GACtBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GAC9D,IAAIx7B,EAAO65B,EAAKr9B,QAAU,GAAI,EAAIk+B,EAAMwF,qBAAqBrG,EAAK,IAAMr9B,EAAS,EAEjF,GAAIwD,KAAU+gB,IACZ,OAAQ,EAGN/gB,GAAQ,EACVA,EAAOA,EAAOxD,EAAS,EAAIwD,EAAOxD,EAAS,EAE3CwD,GAAQxD,EAGV,IAAK,IAAI8C,EAAIU,EAAMV,GAAK,IAAKA,EAC3B,IAAI,EAAI06B,EAAa8C,cAActB,EAAkBl8B,KAAM,EAAIw6B,EAAWC,iBAAiByB,EAAiBl8B,MAAQgjC,EAClH,OAAOhjC,EAIX,OAAQ,CACV,CAEAwmB,SAASwc,KAAYzI,GACnBmB,EAAmB50B,MACnB,MAAMo1B,EAAmBC,EAAoBr1B,MACvC5J,GAAS,EAAIw9B,EAAa0B,8BAA8BF,GAC9D,IAAIx7B,GAAO,EAAI06B,EAAMwF,qBAAqBrG,EAAK,IAE/C,GAAI75B,IAAS+gB,IACX,OAAO,EAGL/gB,EAAO,IACTA,GAAQxD,EAEJwD,EAAO,IACTA,EAAO,IAIX,MAAM5F,GAAQ,EAAI4/B,EAAawI,aAAaF,GAE5C,IAAK,IAAIhjC,EAAIU,EAAMV,EAAI9C,IAAU8C,EAAG,CAClC,MAAMpF,GAAQ,EAAI4/B,EAAWC,iBAAiByB,EAAiBl8B,IAE/D,GAAIlF,IAAS,EAAI4/B,EAAawI,aAAatoC,GACzC,OAAO,EAGT,GAAIA,IAAUooC,EACZ,OAAO,CAEX,CAEA,OAAO,CACT,CAEApiC,KAAKuiC,GACHzH,EAAmB50B,MACnB,MACM+T,EAAQmiB,EADWb,EAAoBr1B,OAE7C,OAAO,EAAI4zB,EAAa0I,oBAAoBvoB,EAAOsoB,EACrD,CAEAE,kBAAkB9I,GAChBmB,EAAmB50B,MACnB,MACM+T,EAAQmiB,EADWb,EAAoBr1B,OAE7C,OAAO,EAAI4zB,EAAa4I,8BAA8BzoB,MAAU,EAAI+f,EAAeC,cAAcN,GACnG,CAEkB8C,IAAb3C,EAAa2C,qBAChB,GAAIrC,EAAel0B,MACjB,MAAO,cAEX,EAIFxM,EAAQyiC,aAAeA,GACvB,EAAIrC,EAAa6I,sBAAsBxG,EAAc,oBAAqB,CACxEniC,MAzxBwB,KA2xB1B,EAAI8/B,EAAa6I,sBAAsBxG,EAAc9B,EAAOuE,MAAO,CAAC,IACpE,EAAI9E,EAAa8I,uBAAuBzG,EAAcrC,EAAa+I,YACnE,MAAMC,EAAwB3G,EAAaz5B,WAC3C,EAAIo3B,EAAa6I,sBAAsBG,EAAuB,oBAAqB,CACjF9oC,MA/xBwB,KAiyB1B,EAAI8/B,EAAa6I,sBAAsBG,EAAuBhJ,EAAamE,eAAgB,CACzFjkC,MAAO8oC,EAAsB7rB,OAC7B8rB,UAAU,EACVC,cAAc,KAEhB,EAAIlJ,EAAa8I,uBAAuBE,EAAuBhJ,EAAa0C,oB,6BCzzB5E7gC,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQugC,aAoBR,SAAsBhgB,GACpB,GAAIA,EAAM6f,EAAamE,kBAAoBnE,EAAamJ,mCACtD,OAAOhpB,EAGT,MAAMipB,GAAO,EAAIpJ,EAAaqJ,cAAcC,GAE5C,OADA,EAAItJ,EAAa0E,qBAAqB6E,EAAgBH,GAAM,EAAIpJ,EAAawJ,8BAA8BrpB,IACpGipB,CACT,EA3BAxpC,EAAQkgB,KAiDR,SAAc2pB,GACZ,MAAMC,GAAQ,EAAI1J,EAAaqJ,cAAcM,GAE7C,OADA,EAAI3J,EAAa0E,qBAAqBkF,EAAYF,EAAOD,GAClDC,CACT,EAnDA,IAAI1J,EAAe,EAAQ,KAE3B,MAAMuJ,EAAiB,IAAIvJ,EAAaY,cAClC0I,GAAwB,EAAItJ,EAAaqJ,cAAc,KAAM,CACjEQ,KAAM,CACJ3pC,MAAO,WACL,MAAM4pC,GAAgB,EAAI9J,EAAa+B,qBAAqBwH,EAAgBn9B,MAC5E,OAAO,EAAI4zB,EAAa+J,4BAA4BD,EACtD,GAEF,CAAC9J,EAAamE,gBAAiB,CAC7BjkC,MAAO,WACL,OAAOkM,IACT,KAcJ,MAAMw9B,EAAa,IAAI5J,EAAaY,cAC9B+I,GAA8B,EAAI3J,EAAaqJ,cAAcrJ,EAAagK,kBAAmB,CACjGH,KAAM,CACJ3pC,MAAO,WACL,MAAMupC,GAAY,EAAIzJ,EAAa+B,qBAAqB6H,EAAYx9B,MACpE,OAAO,EAAI4zB,EAAaiK,wBAAwBR,EAClD,EACAR,UAAU,EACVC,cAAc,KAIlB,IAAK,MAAM75B,KAAO,EAAI2wB,EAAayC,gBAAgBzC,EAAakK,wBAClD,SAAR76B,IAIJ,EAAI2wB,EAAa6I,sBAAsBc,EAA6Bt6B,GAAK,EAAI2wB,EAAa6C,iCAAiC7C,EAAakK,uBAAwB76B,G,6BClDlKxN,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQmhC,qBAWR,SAA8Bv3B,GAC5B,KAAK,EAAIg3B,EAAI2J,cAAc3gC,GACzB,OAAO,EAGT,MAAMZ,GAAY,EAAIo3B,EAAaoK,uBAAuB5gC,GAE1D,KAAK,EAAIg3B,EAAI2J,cAAcvhC,GACzB,OAAO,EAGT,MAAMyK,EAAczK,EAAUyK,YAE9B,QAAoBlH,IAAhBkH,EACF,OAAO,EAGT,KAAK,EAAImtB,EAAI7+B,UAAU0R,GACrB,MAAM,EAAI2sB,EAAaiB,iBAAiBR,EAAU4J,iDAGpD,OAAO,EAAIrK,EAAa6E,YAAYxxB,EAAayxB,EACnD,EA/BA,IAAItE,EAAM,EAAQ,KAEdC,EAAY,EAAQ,KAEpBT,EAAe,EAAQ,KAE3B,MAAM8E,GAAQ,EAAI9E,EAAasK,WAAW,oBAC1C1qC,EAAQklC,MAAQA,C,6BCZhBjjC,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQmgC,gBA0FR,SAAyBwK,GACvB,MAAMlgC,EAAIkgC,GAAe,GAEzB,OADAC,EAAW,GAAKC,EAAcC,EAAYrgC,IAAoB,KAAdkgC,IAAwBI,EAActgC,GAC/EugC,EAAU,EACnB,EA7FAhrC,EAAQygC,mBAyCR,SAA4BwK,GAC1BD,EAAU,GAAKC,EACf,MAAMviC,EAAIkiC,EAAW,GACfziC,EAAIO,GAAK,GAAK,IACpB,OAAOwiC,EAAU/iC,KAAW,QAAJO,IAAmByiC,EAAWhjC,GACxD,EA5CA,IAAIi4B,EAAe,EAAQ,KAE3B,MAAMrwB,EAAS,IAAIqwB,EAAagE,kBAAkB,GAC5C4G,EAAY,IAAI5K,EAAagL,mBAAmBr7B,GAChD66B,EAAa,IAAIxK,EAAaiL,kBAAkBt7B,GAChDm7B,EAAY,IAAI9K,EAAaiL,kBAAkB,KAC/CF,EAAa,IAAI/K,EAAaiL,kBAAkB,KAEtD,IAAK,IAAI3lC,EAAI,EAAGA,EAAI,MAAOA,EAAG,CAC5B,MAAMyC,EAAIzC,EAAI,IAEVyC,GAAK,IACP+iC,EAAUxlC,GAAK,EACfwlC,EAAc,IAAJxlC,GAAa,MACvBylC,EAAWzlC,GAAK,GAChBylC,EAAe,IAAJzlC,GAAa,IACfyC,GAAK,IACd+iC,EAAUxlC,GAAK,OAAWyC,EAAI,GAC9B+iC,EAAc,IAAJxlC,GAAa,OAAWyC,EAAI,GAAK,MAC3CgjC,EAAWzlC,IAAMyC,EAAI,EACrBgjC,EAAe,IAAJzlC,IAAcyC,EAAI,GACpBA,GAAK,IACd+iC,EAAUxlC,GAAKyC,EAAI,IAAM,GACzB+iC,EAAc,IAAJxlC,GAAayC,EAAI,IAAM,GAAK,MACtCgjC,EAAWzlC,GAAK,GAChBylC,EAAe,IAAJzlC,GAAa,IACfyC,EAAI,KACb+iC,EAAUxlC,GAAK,MACfwlC,EAAc,IAAJxlC,GAAa,MACvBylC,EAAWzlC,GAAK,GAChBylC,EAAe,IAAJzlC,GAAa,KAExBwlC,EAAUxlC,GAAK,MACfwlC,EAAc,IAAJxlC,GAAa,MACvBylC,EAAWzlC,GAAK,GAChBylC,EAAe,IAAJzlC,GAAa,GAE5B,CASA,MAAMmlC,EAAgB,IAAIzK,EAAaiL,kBAAkB,MACnDN,EAAgB,IAAI3K,EAAaiL,kBAAkB,IACnDP,EAAc,IAAI1K,EAAaiL,kBAAkB,IAEvD,IAAK,IAAI3lC,EAAI,EAAGA,EAAI,OAAQA,EAAG,CAC7B,IAAI+E,EAAI/E,GAAK,GACTyC,EAAI,EAER,KAA4B,IAAhB,QAAJsC,IACNA,IAAM,EACNtC,GAAK,QAGPsC,IAAK,QACLtC,GAAK,UACL0iC,EAAcnlC,GAAK+E,EAAItC,CACzB,CAEA,IAAK,IAAIzC,EAAI,KAAMA,EAAI,OAAQA,EAC7BmlC,EAAcnlC,GAAK,WAAcA,EAAI,MAAQ,IAG/C,IAAK,IAAIA,EAAI,EAAGA,EAAI,KAAMA,EACxBqlC,EAAcrlC,GAAKA,GAAK,GAG1BqlC,EAAc,IAAM,WACpBA,EAAc,IAAM,WAEpB,IAAK,IAAIrlC,EAAI,GAAIA,EAAI,KAAMA,EACzBqlC,EAAcrlC,GAAK,YAAcA,EAAI,IAAM,IAG7CqlC,EAAc,IAAM,WAEpB,IAAK,IAAIrlC,EAAI,EAAGA,EAAI,KAAMA,EACd,KAANA,IACFolC,EAAYplC,GAAK,K,6BCzFrBzD,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQgkC,cA6BR,SAAuB1jC,GACrB,IAEE,OADA,EAAI8/B,EAAakL,mCAAmChrC,IAC7C,CAGT,CAFE,MAAO6H,GACP,OAAO,CACT,CACF,EAnCAnI,EAAQujC,8BA8ER,SAAuCjjC,GACrC,GAAqB,iBAAVA,EACT,OAAO,EAGT,MAAMirC,GAAUjrC,EAEhB,GAAIA,IAAUirC,EAAS,GACrB,OAAO,EAGT,KAAK,EAAInL,EAAaoL,gBAAgBD,GACpC,OAAO,EAGT,OAAOA,KAAW,EAAInL,EAAaqL,WAAWF,EAChD,EA7FAvrC,EAAQgiC,yBAsBR,SAAkC1hC,GAChC,MAAMorC,GAAiB,EAAItL,EAAauL,yCAAyCrrC,GACjF,MAA0B,kBAAnBorC,GAAyD,mBAAnBA,CAC/C,EAxBA1rC,EAAQ0hC,mBAAqBA,EAC7B1hC,EAAQ+B,SAQR,SAAkBzB,GAChB,OAAiB,OAAVA,GAAmC,iBAAVA,GAAuC,mBAAVA,CAC/D,EATAN,EAAQuqC,aAWR,SAAsBjqC,GACpB,OAAiB,OAAVA,GAAmC,iBAAVA,CAClC,EAZAN,EAAQykC,gBA6CR,SAAyBnkC,GACvB,KAAK,EAAI8/B,EAAawL,cAActrC,GAClC,OAAO,EAGT,GAAIA,EAAM8/B,EAAamE,kBAAoBnE,EAAamJ,mCACtD,OAAO,EAKT,MAAoD,mBAFnCjpC,EAAM8/B,EAAamE,kBAEpBnE,EAAa2C,kBAC/B,EAxDA/iC,EAAQ4lC,2BA0DR,SAAoCtlC,GAClC,IAAKohC,EAAmBphC,GACtB,OAAO,EAGT,GAAIA,EAAM8/B,EAAamE,kBAAoBnE,EAAayL,wCACtD,OAAO,EAKT,MAAoD,mBAFnCvrC,EAAM8/B,EAAamE,kBAEpBnE,EAAa2C,kBAC/B,EArEA/iC,EAAQmkC,oBA8BR,SAA6B7jC,GAC3B,GAA6C,OAAzC8/B,EAAa0L,wBACf,OAAO,EAGT,IAEE,OADA,EAAI1L,EAAa2L,yCAAyCzrC,IACnD,CAGT,CAFE,MAAO6H,GACP,OAAO,CACT,CACF,EAvCA,IAAIi4B,EAAe,EAAQ,KAU3B,SAASsB,EAAmBphC,GAC1B,YAA4EiM,KAArE,EAAI6zB,EAAauL,yCAAyCrrC,EACnE,C,2BCzBA2B,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAGTN,EAAQgsC,sBADsB,wBAG9BhsC,EAAQshC,kCADkC,oCAG1CthC,EAAQmlC,mDADmD,qDAG3DnlC,EAAQyqC,gDADgD,kDAGxDzqC,EAAQ2hC,mDADmD,sDAG3D3hC,EAAQ+hC,yEADyE,2EAGjF/hC,EAAQsiC,0CAD0C,4CAGlDtiC,EAAQ6lC,2CAD2C,6CAGnD7lC,EAAQiiC,kCADkC,8DAG1CjiC,EAAQwkC,kCADkC,sCAG1CxkC,EAAQ0mC,4CAD4C,8CAGpD1mC,EAAQonC,wBADwB,yB,6BCzBhCnlC,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAGT,IAAIugC,EAAY,EAAQ,KAExB,SAASoL,EAAYriC,GACnB,MAAO,CAAC67B,KAAYC,IACXC,EAAa/7B,EAAQ67B,EAASC,EAEzC,CAEA,SAASwG,EAAkBtiC,EAAQ6F,GACjC,OAAOw8B,EAAYhJ,EAAgCr5B,EAAQ6F,GAAK+U,IAClE,CAEA,MACEve,MAAO0/B,EACPwG,UAAW3J,EACXtgC,eAAgB2hC,EAChBrf,IAAKgf,EACLI,yBAA0BX,EAC1BmJ,eAAgB5B,EAChB6B,IAAKpH,EACLqH,QAASzJ,EACT77B,IAAK28B,EACL4I,eAAgBrD,GACdsD,QACJxsC,EAAQkpC,sBAAwBA,EAChClpC,EAAQ2jC,WAAaA,EACrB3jC,EAAQ6iC,eAAiBA,EACzB7iC,EAAQilC,WAAaA,EACrBjlC,EAAQwqC,sBAAwBA,EAChCxqC,EAAQijC,gCAAkCA,EAC1CjjC,EAAQwjC,WAAaA,EACrBxjC,EAAQ6jC,sBAAwBA,EAChC7jC,EAAQwiC,iBAAmBA,EAC3BxiC,EAAQ2lC,aAAeA,EACvB,MAAMd,EAAc4H,MACpBzsC,EAAQ6kC,YAAcA,EACtB,MACE6H,iBAAkBA,EAClBhsC,SAAU8qC,EACVhrC,MAAOooC,GACLroC,OACJP,EAAQ4oC,YAAcA,EACtB5oC,EAAQwrC,eAAiBA,EACzBxrC,EAAQ0sC,iBAAmBA,EAC3B,MACEpI,SAAUC,EACVoI,QAASC,EACTC,YAAa9J,EACb+J,IAAKpC,GACHqC,OACJ/sC,EAAQ0qC,UAAYA,EACpB1qC,EAAQ+iC,kBAAoBA,EAC5B/iC,EAAQ4sC,cAAgBA,EACxB5sC,EAAQukC,eAAiBA,EACzB,MAAMuB,EAAe7jC,OACrBjC,EAAQ8lC,aAAeA,EACvB,MACEkH,OAAQvD,EACRvnC,eAAgB+mC,EAChBgE,OAAQ5J,EACR6J,GAAIC,GACFrH,EACJ9lC,EAAQmtC,SAAWA,EACnBntC,EAAQqjC,aAAeA,EACvBrjC,EAAQipC,qBAAuBA,EAC/BjpC,EAAQypC,aAAeA,EACvB,MAAM2D,EAAkBtH,EAAa98B,UAC/B06B,EAAkC0J,EAAgBC,iBAAmBpB,EAAYmB,EAAgBC,kBAAoB,CAACC,EAAQ79B,KAClI,GAAc,MAAV69B,EACF,MAAMjM,GAAgBR,EAAUgF,4CAGlC,IAAIj8B,EAASk8B,EAAawH,GAE1B,EAAG,CACD,MAAMtK,EAAaC,EAAgCr5B,EAAQ6F,GAE3D,QAAmBlD,IAAfy2B,EACF,OAAIE,EAAaF,EAAY,OACpBA,EAAWxe,SAGpB,CAEJ,OAAsD,QAA5C5a,EAAS4gC,EAAsB5gC,IAAkB,EAE7D5J,EAAQ0jC,gCAAkCA,EAC1C,MAAMR,EAAe4C,EAAayH,QAAUtB,EAAYmB,EAAgBI,gBACxExtC,EAAQkjC,aAAeA,EACvB,MAAMuK,EAAc3rC,MACd8pC,EAAe6B,EAAY5rC,QACjC7B,EAAQ4rC,aAAeA,EACvB,MAAM8B,EAAiBD,EAAYzkC,UAC7B8/B,EAAqBmD,EAAYyB,EAAepnC,MACtDtG,EAAQ8oC,mBAAqBA,EAC7B,MAAMtC,EAAqByF,EAAYyB,EAAe78B,MACtD7Q,EAAQwmC,mBAAqBA,EAC7B,MAAMwC,EAA+BiD,EAAYyB,EAAe3E,gBAChE/oC,EAAQgpC,6BAA+BA,EACvC,MAAMO,EAAqCmE,EAAenJ,GAC1DvkC,EAAQupC,mCAAqCA,EAC7C,MAAMK,EAA+BqC,EAAY1C,GACjDvpC,EAAQ4pC,6BAA+BA,EACvC,MAAM6B,EAAYvmC,KAAKkxB,MACvBp2B,EAAQyrC,UAAYA,EACpB,MAAMrH,EAAoB1iC,YAC1B1B,EAAQokC,kBAAoBA,EAC5B,MAAMlD,EAAoBkD,EAAkBziC,OAC5C3B,EAAQkhC,kBAAoBA,EAC5B,MAAMyM,EAAuBvJ,EAAkBp7B,UACzC4kC,EAA4B3B,EAAY0B,EAAqB1qC,OACnEjD,EAAQ4tC,0BAA4BA,EACpC,MAAMtC,EAAoCY,EAAkByB,EAAsB,cAClF3tC,EAAQsrC,kCAAoCA,EAC5C,MAAMQ,EAAuD,oBAAtB+B,kBAAoCA,kBAAoB,KAC/F7tC,EAAQ8rC,wBAA0BA,EAClC,MAAMC,EAA0CD,GAA2BI,EAAkBJ,EAAwB9iC,UAAW,cAChIhJ,EAAQ+rC,wCAA0CA,EAClD,MAAM5C,EAAaqB,EAAsB/mC,YACzCzD,EAAQmpC,WAAaA,EACrB,MAAM2E,EAAiB3E,EAAW/iC,KAC5B08B,EAAsBqG,EAAWngC,UACvChJ,EAAQ8iC,oBAAsBA,EAC9B,MAAM+I,EAA0C/I,EAAoByB,GACpEvkC,EAAQ6rC,wCAA0CA,EAClD,MAAM7F,EAA0BiG,EAAYnJ,EAAoB12B,MAChEpM,EAAQgmC,wBAA0BA,EAClC,MAAMC,EAA4BgG,EAAYnJ,EAAoBvlB,QAClEvd,EAAQimC,0BAA4BA,EACpC,MAAME,GAA6B8F,EAAYnJ,EAAoBoD,SACnElmC,EAAQmmC,2BAA6BA,GACrC,MAAMkB,GAAyB4E,EAAYnJ,EAAoB97B,KAC/DhH,EAAQqnC,uBAAyBA,GACjC,MAAMI,GAA6BwE,EAAYnJ,EAAoB0E,SACnExnC,EAAQynC,2BAA6BA,GACrC,MAAMC,GAA0BuE,EAAYnJ,EAAoBvS,MAChEvwB,EAAQ0nC,wBAA0BA,GAClC,MAAME,GAAgCqE,EAAYnJ,EAAoB6E,YACtE3nC,EAAQ4nC,8BAAgCA,GACxC,MAAMK,GAA0BgE,EAAYnJ,EAAoB+E,MAChE7nC,EAAQioC,wBAA0BA,GAClC,MAAM3C,GAA2B2G,EAAYnJ,EAAoB7/B,OACjEjD,EAAQslC,yBAA2BA,GACnC,MAAMmD,GAA8BwD,EAAYnJ,EAAoBwF,UACpEtoC,EAAQyoC,4BAA8BA,GACtC,MAAMrG,GAA+B8J,EAAkBpJ,EAAqB,UAC5E9iC,EAAQoiC,6BAA+BA,GACvC,MAAMiD,GAAmC6G,EAAkBpJ,EAAqB,cAChF9iC,EAAQqlC,iCAAmCA,GAC3C,MAAMvD,GAA+BoK,EAAkBpJ,EAAqB,UAC5E9iC,EAAQ8hC,6BAA+BA,GACvC,MAAM6J,GAA0CO,EAAkBpJ,EAAqBC,GACvF/iC,EAAQ2rC,wCAA0CA,GAClD,MAAM5H,GAAoBjmB,YAC1B9d,EAAQ+jC,kBAAoBA,GAM5B/jC,EAAQulC,gBAJgB,IAAIG,IACnBC,EAAamI,EAAgB/J,GAAmB2B,GAIzD,MAAM2F,GAAoBztB,YAC1B5d,EAAQqrC,kBAAoBA,GAC5B,MAAMD,GAAqB96B,aAC3BtQ,EAAQorC,mBAAqBA,GAC7B,MAAMd,GAAyBE,EAAsB,GAAGjG,MACxDvkC,EAAQsqC,uBAAyBA,GACjC,MAAMH,GAA6B8B,EAAY3B,GAAuBL,MACtEjqC,EAAQmqC,2BAA6BA,GACrC,MAAME,GAAyB4B,EAAY,YAAc,CAAd,GAAkBhC,MAC7DjqC,EAAQqqC,uBAAyBA,GACjC,MAAMD,GAAoBI,EAAsBF,IAChDtqC,EAAQoqC,kBAAoBA,GAC5B,MAAM2D,GAAoBnsC,SAASoH,UAC7Bq3B,GAA6B4L,EAAY8B,GAAkBC,WACjEhuC,EAAQqgC,2BAA6BA,GACrC,MAAMG,GAA6ByL,EAAY8B,GAAkBE,WACjEjuC,EAAQwgC,2BAA6BA,GACrC,MAAMa,GAAkB6M,UACxBluC,EAAQqhC,gBAAkBA,GAC1B,MAAM8F,GAAmBgH,WACzBnuC,EAAQmnC,iBAAmBA,GAC3B,MAAMvE,GAAgBwL,QACtBpuC,EAAQ4iC,cAAgBA,GACxB,MAAMyL,GAAmBzL,GAAc55B,UACjCm6B,GAAsB8I,EAAYoC,GAAiBC,KACzDtuC,EAAQmjC,oBAAsBA,GAC9B,MAAMM,GAAsBwI,EAAYoC,GAAiBhC,KACzDrsC,EAAQyjC,oBAAsBA,GAC9B,MAAMzC,GAAgB9qB,QACtBlW,EAAQghC,cAAgBA,GACxB,MAAMuN,GAAmBvN,GAAch4B,UACjCm5B,GAAsB8J,EAAYsC,GAAiB/pB,KACzDxkB,EAAQmiC,oBAAsBA,GAC9B,MAAMlB,GAAsBgL,EAAYsC,GAAiBlC,KACzDrsC,EAAQihC,oBAAsBA,GAC9B,MAAM6D,GAAsBmH,EAAYsC,GAAiBvnC,KACzDhH,EAAQ8kC,oBAAsBA,E,6BCzM9B7iC,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQqiC,iBAwDR,SAA0BtyB,GACxB,IAAI,EAAI6wB,EAAIuD,qBAAqBp0B,GAC/B,OAAO,EAGT,IAEE,OADA,EAAIqwB,EAAawN,2BAA2B79B,EAAQ,EAAG,IAChD,CACI,CAAX,MAAO5H,GAAI,CAEb,OAAO,CACT,EAlEAnI,EAAQqkC,mBA+BR,SAA4Bz6B,EAAQ4kC,GAClC,KAAK,EAAI5N,EAAI7+B,UAAU6H,GACrB,MAAM,EAAIw2B,EAAaiB,iBAAiBR,EAAUmL,uBAGpD,MAAMv4B,EAAc7J,EAAO6J,YAE3B,QAAoBlH,IAAhBkH,EACF,OAAO+6B,EAGT,KAAK,EAAI5N,EAAI7+B,UAAU0R,GACrB,MAAM,EAAI2sB,EAAaiB,iBAAiBR,EAAU4J,iDAGpD,MAAMkC,EAAUl5B,EAAY2sB,EAAawM,eAEzC,GAAe,MAAXD,EACF,OAAO6B,EAGT,OAAO7B,CACT,EApDA3sC,EAAQsmC,oBAAsBA,EAC9BtmC,EAAQ0kC,SAmBR,SAAkB96B,GAChB,MAAMhH,EAAS0jC,EAAoB18B,GAEnC,GAAIhH,EAAS,EACX,OAAO,EAGT,OAAOA,EAASw9B,EAAasM,iBAAmB9pC,EAASw9B,EAAasM,gBACxE,EA1BA1sC,EAAQgoC,eAiER,SAAwBhsB,EAAGC,GACzB,MAAMwyB,GAAS,EAAIrO,EAAawI,aAAa5sB,GACvC0yB,GAAS,EAAItO,EAAawI,aAAa3sB,GAE7C,GAAIwyB,GAAUC,EACZ,OAAO,EAGT,GAAID,EACF,OAAO,EAGT,GAAIC,EACF,OAAQ,EAGV,GAAI1yB,EAAIC,EACN,OAAQ,EAGV,GAAID,EAAIC,EACN,OAAO,EAGT,GAAU,IAAND,GAAiB,IAANC,EAAS,CACtB,MAAM0yB,GAAc,EAAIvO,EAAa+M,UAAUnxB,EAAG,GAC5C4yB,GAAc,EAAIxO,EAAa+M,UAAUlxB,EAAG,GAElD,IAAK0yB,GAAeC,EAClB,OAAQ,EAGV,GAAID,IAAgBC,EAClB,OAAO,CAEX,CAEA,OAAO,CACT,EArGA,IAAIhO,EAAM,EAAQ,KAEdC,EAAY,EAAQ,KAEpBT,EAAe,EAAQ,KAE3B,SAASkG,EAAoB18B,GAC3B,MAAM2hC,GAAU3hC,EAEhB,OAAI,EAAIw2B,EAAawI,aAAa2C,IAAsB,IAAXA,EACpC,GAGF,EAAInL,EAAaqL,WAAWF,EACrC,C,6BCvBAtpC,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQ6uC,QAMR,SAAiB7yB,GACf,MAAMuvB,GAAUvvB,EAEhB,KAAK,EAAIokB,EAAaoL,gBAAgBD,IAAsB,IAAXA,EAC/C,OAAOA,EAGT,MAAMuD,GAAM,EAAI5O,EAAWO,oBAAoB8K,GAC/C,OAAO,EAAIrL,EAAWC,iBAAiB2O,EACzC,EAbA,IAAI5O,EAAa,EAAQ,KAErBE,EAAe,EAAQ,I,6BCP3Bn+B,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAGT,IAAIyuC,EAAgB,EAAQ,KAE5B/uC,EAAQyiC,aAAesM,EAActM,aACrCziC,EAAQ0gC,eAAiBqO,EAAcrO,eAEvC,IAAIsO,EAAgB,EAAQ,KAE5BhvC,EAAQyB,aAAeutC,EAAcvtC,aAErC,IAAIwtC,EAAY,EAAQ,KAExBjvC,EAAQwjB,WAAayrB,EAAUzrB,WAC/BxjB,EAAQ8lB,WAAampB,EAAUnpB,WAE/B,IAAIopB,EAAW,EAAQ,KAEvBlvC,EAAQ6uC,QAAUK,EAASL,O,6BCpB3B5sC,OAAOC,eAAelC,EAAS,aAAc,CAC3CM,OAAO,IAETN,EAAQyB,aAMR,SAAsBmI,GACpB,OAAO,EAAIg3B,EAAIc,oBAAoB93B,KAAW,EAAImlC,EAAcrO,gBAAgB92B,EAClF,EANA,IAAImlC,EAAgB,EAAQ,KAExBnO,EAAM,EAAQ,I,GCRduO,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB9iC,IAAjB+iC,EACH,OAAOA,EAAatvC,QAGrB,IAAIC,EAASkvC,EAAyBE,GAAY,CAGjDrvC,QAAS,CAAC,GAOX,OAHAuvC,EAAoBF,GAAUG,KAAKvvC,EAAOD,QAASC,EAAQA,EAAOD,QAASovC,GAGpEnvC,EAAOD,OACf,C,OCtBAovC,EAAoBvnC,EAAI,WACvB,GAA0B,iBAAf4nC,WAAyB,OAAOA,WAC3C,IACC,OAAOjjC,MAAQ,IAAIkjC,SAAS,cAAb,EAGhB,CAFE,MAAOvnC,GACR,GAAsB,iBAAXM,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCGE2mC,EAAoB,I","sources":["webpack://GPUIO/webpack/universalModuleDefinition","webpack://GPUIO/./node_modules/@amandaghassaei/type-checks/dist/type-checks.js","webpack://GPUIO/./node_modules/changedpi/dist/index.js","webpack://GPUIO/./node_modules/file-saver/dist/FileSaver.min.js","webpack://GPUIO/./src/GPUComposer.ts","webpack://GPUIO/./src/GPUIndexBuffer.ts","webpack://GPUIO/./src/GPULayer.ts","webpack://GPUIO/./src/GPULayerHelpers.ts","webpack://GPUIO/./src/GPUProgram.ts","webpack://GPUIO/./src/Programs.ts","webpack://GPUIO/./src/Vector4.ts","webpack://GPUIO/./src/checks.ts","webpack://GPUIO/./src/constants.ts","webpack://GPUIO/./src/conversions.ts","webpack://GPUIO/./src/extensions.ts","webpack://GPUIO/./src/framebuffers.ts","webpack://GPUIO/./src/glsl/common/precision.ts","webpack://GPUIO/./src/glsl/vertex/DefaultVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/LayerLinesVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/LayerMeshVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/LayerPointsVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/LayerVectorFieldVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/SegmentVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/VertexShaderHelpers.ts","webpack://GPUIO/./src/index.ts","webpack://GPUIO/./src/polyfills.ts","webpack://GPUIO/./src/regex.ts","webpack://GPUIO/./src/utils.ts","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/DataView.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/Float16Array.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/_util/arrayIterator.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/_util/brand.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/_util/converter.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/_util/is.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/_util/messages.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/_util/primordials.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/_util/spec.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/hfround.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/index.cjs","webpack://GPUIO/./node_modules/@petamoriken/float16/lib/isTypedArray.cjs","webpack://GPUIO/webpack/bootstrap","webpack://GPUIO/webpack/runtime/global","webpack://GPUIO/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GPUIO\"] = factory();\n\telse\n\t\troot[\"GPUIO\"] = factory();\n})(self, () => {\nreturn ","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TypeChecks = {}));\n})(this, (function (exports) { 'use strict';\n\n\t/**\n\t * Checks if value is a number (including Infinity).\n\t */\n\tfunction isNumber(value) {\n\t    return !Number.isNaN(value) && typeof value === 'number';\n\t}\n\t/**\n\t * Checks if value is finite number.\n\t */\n\tfunction isFiniteNumber(value) {\n\t    return isNumber(value) && Number.isFinite(value);\n\t}\n\t/**\n\t * Checks if value is integer.\n\t */\n\tfunction isInteger(value) {\n\t    return isFiniteNumber(value) && (value % 1 === 0);\n\t}\n\t/**\n\t * Checks if value is positive number (> 0).\n\t */\n\tfunction isPositiveNumber(value) {\n\t    return isNumber(value) && value > 0;\n\t}\n\t/**\n\t * Checks if value is positive integer (> 0).\n\t */\n\tfunction isPositiveInteger(value) {\n\t    return isInteger(value) && value > 0;\n\t}\n\t/**\n\t * Checks if value is negative number (< 0).\n\t */\n\tfunction isNegativeNumber(value) {\n\t    return isNumber(value) && value < 0;\n\t}\n\t/**\n\t * Checks if value is negative integer (< 0).\n\t */\n\tfunction isNegativeInteger(value) {\n\t    return isInteger(value) && value < 0;\n\t}\n\t/**\n\t * Checks if value is non-negative number (>= 0).\n\t */\n\tfunction isNonNegativeNumber(value) {\n\t    return isNumber(value) && value >= 0;\n\t}\n\t/**\n\t * Checks if value is non-negative integer (>= 0).\n\t */\n\tfunction isNonNegativeInteger(value) {\n\t    return isInteger(value) && value >= 0;\n\t}\n\t/**\n\t * Checks if value is non-positive number (<= 0).\n\t */\n\tfunction isNonPositiveNumber(value) {\n\t    return isNumber(value) && value <= 0;\n\t}\n\t/**\n\t * Checks if value is non-positive integer (<= 0).\n\t */\n\tfunction isNonPositiveInteger(value) {\n\t    return isInteger(value) && value <= 0;\n\t}\n\t/**\n\t * Checks if value is number in range [min, max].\n\t */\n\tfunction isNumberInRange(value, min, max) {\n\t    return isNumber(value) && value >= min && value <= max;\n\t}\n\t/**\n\t * Checks if value is integer in range [min, max].\n\t */\n\tfunction isIntegerInRange(value, min, max) {\n\t    return isInteger(value) && value >= min && value <= max;\n\t}\n\t/**\n\t * Checks if value is string.\n\t */\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t/**\n\t * Checks if value is TypedArray.\n\t */\n\tfunction isTypedArray(value) {\n\t    return ArrayBuffer.isView(value) && !(value instanceof DataView);\n\t}\n\t/**\n\t * Checks if value is Array or TypedArray.\n\t */\n\tfunction isArray(value) {\n\t    return Array.isArray(value) || isTypedArray(value);\n\t}\n\t/**\n\t * Checks if value is Javascript object.\n\t */\n\tfunction isObject(value) {\n\t    return typeof value === 'object' && !isArray(value) && value !== null && !(value instanceof ArrayBuffer) && !(value instanceof DataView);\n\t}\n\t/**\n\t * Checks if value is boolean.\n\t */\n\tfunction isBoolean(value) {\n\t    return typeof value === 'boolean';\n\t}\n\n\texports.isArray = isArray;\n\texports.isBoolean = isBoolean;\n\texports.isFiniteNumber = isFiniteNumber;\n\texports.isInteger = isInteger;\n\texports.isIntegerInRange = isIntegerInRange;\n\texports.isNegativeInteger = isNegativeInteger;\n\texports.isNegativeNumber = isNegativeNumber;\n\texports.isNonNegativeInteger = isNonNegativeInteger;\n\texports.isNonNegativeNumber = isNonNegativeNumber;\n\texports.isNonPositiveInteger = isNonPositiveInteger;\n\texports.isNonPositiveNumber = isNonPositiveNumber;\n\texports.isNumber = isNumber;\n\texports.isNumberInRange = isNumberInRange;\n\texports.isObject = isObject;\n\texports.isPositiveInteger = isPositiveInteger;\n\texports.isPositiveNumber = isPositiveNumber;\n\texports.isString = isString;\n\texports.isTypedArray = isTypedArray;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=type-checks.js.map\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.changeDpiBlob = changeDpiBlob;\nexports.changeDpiDataUrl = changeDpiDataUrl;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction createPngDataTable() {\n  /* Table of CRCs of all 8-bit messages. */\n  var crcTable = new Int32Array(256);\n  for (var n = 0; n < 256; n++) {\n    var c = n;\n    for (var k = 0; k < 8; k++) {\n      c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n    }\n    crcTable[n] = c;\n  }\n  return crcTable;\n}\n\nfunction calcCrc(buf) {\n  var c = -1;\n  if (!pngDataTable) pngDataTable = createPngDataTable();\n  for (var n = 0; n < buf.length; n++) {\n    c = pngDataTable[(c ^ buf[n]) & 0xFF] ^ c >>> 8;\n  }\n  return c ^ -1;\n}\n\nvar pngDataTable = void 0;\n\nvar PNG = 'image/png';\nvar JPEG = 'image/jpeg';\n\n// those are 3 possible signature of the physBlock in base64.\n// the pHYs signature block is preceed by the 4 bytes of lenght. The length of\n// the block is always 9 bytes. So a phys block has always this signature:\n// 0 0 0 9 p H Y s.\n// However the data64 encoding aligns we will always find one of those 3 strings.\n// this allow us to find this particular occurence of the pHYs block without\n// converting from b64 back to string\nvar b64PhysSignature1 = 'AAlwSFlz';\nvar b64PhysSignature2 = 'AAAJcEhZ';\nvar b64PhysSignature3 = 'AAAACXBI';\n\nvar _P = 'p'.charCodeAt(0);\nvar _H = 'H'.charCodeAt(0);\nvar _Y = 'Y'.charCodeAt(0);\nvar _S = 's'.charCodeAt(0);\n\nfunction changeDpiBlob(blob, dpi) {\n  // 33 bytes are ok for pngs and jpegs\n  // to contain the information.\n  var headerChunk = blob.slice(0, 33);\n  return new Promise(function (resolve, reject) {\n    var fileReader = new FileReader();\n    fileReader.onload = function () {\n      var dataArray = new Uint8Array(fileReader.result);\n      var tail = blob.slice(33);\n      var changedArray = changeDpiOnArray(dataArray, dpi, blob.type);\n      resolve(new Blob([changedArray, tail], { type: blob.type }));\n    };\n    fileReader.readAsArrayBuffer(headerChunk);\n  });\n}\n\nfunction changeDpiDataUrl(base64Image, dpi) {\n  var dataSplitted = base64Image.split(',');\n  var format = dataSplitted[0];\n  var body = dataSplitted[1];\n  var type = void 0;\n  var headerLength = void 0;\n  var overwritepHYs = false;\n  if (format.indexOf(PNG) !== -1) {\n    type = PNG;\n    var b64Index = detectPhysChunkFromDataUrl(body);\n    // 28 bytes in dataUrl are 21bytes, length of phys chunk with everything inside.\n    if (b64Index >= 0) {\n      headerLength = Math.ceil((b64Index + 28) / 3) * 4;\n      overwritepHYs = true;\n    } else {\n      headerLength = 33 / 3 * 4;\n    }\n  }\n  if (format.indexOf(JPEG) !== -1) {\n    type = JPEG;\n    headerLength = 18 / 3 * 4;\n  }\n  // 33 bytes are ok for pngs and jpegs\n  // to contain the information.\n  var stringHeader = body.substring(0, headerLength);\n  var restOfData = body.substring(headerLength);\n  var headerBytes = atob(stringHeader);\n  var dataArray = new Uint8Array(headerBytes.length);\n  for (var i = 0; i < dataArray.length; i++) {\n    dataArray[i] = headerBytes.charCodeAt(i);\n  }\n  var finalArray = changeDpiOnArray(dataArray, dpi, type, overwritepHYs);\n  var base64Header = btoa(String.fromCharCode.apply(String, _toConsumableArray(finalArray)));\n  return [format, ',', base64Header, restOfData].join('');\n}\n\nfunction detectPhysChunkFromDataUrl(data) {\n  var b64index = data.indexOf(b64PhysSignature1);\n  if (b64index === -1) {\n    b64index = data.indexOf(b64PhysSignature2);\n  }\n  if (b64index === -1) {\n    b64index = data.indexOf(b64PhysSignature3);\n  }\n  // if b64index === -1 chunk is not found\n  return b64index;\n}\n\nfunction searchStartOfPhys(data) {\n  var length = data.length - 1;\n  // we check from the end since we cut the string in proximity of the header\n  // the header is within 21 bytes from the end.\n  for (var i = length; i >= 4; i--) {\n    if (data[i - 4] === 9 && data[i - 3] === _P && data[i - 2] === _H && data[i - 1] === _Y && data[i] === _S) {\n      return i - 3;\n    }\n  }\n}\n\nfunction changeDpiOnArray(dataArray, dpi, format, overwritepHYs) {\n  if (format === JPEG) {\n    dataArray[13] = 1; // 1 pixel per inch or 2 pixel per cm\n    dataArray[14] = dpi >> 8; // dpiX high byte\n    dataArray[15] = dpi & 0xff; // dpiX low byte\n    dataArray[16] = dpi >> 8; // dpiY high byte\n    dataArray[17] = dpi & 0xff; // dpiY low byte\n    return dataArray;\n  }\n  if (format === PNG) {\n    var physChunk = new Uint8Array(13);\n    // chunk header pHYs\n    // 9 bytes of data\n    // 4 bytes of crc\n    // this multiplication is because the standard is dpi per meter.\n    dpi *= 39.3701;\n    physChunk[0] = _P;\n    physChunk[1] = _H;\n    physChunk[2] = _Y;\n    physChunk[3] = _S;\n    physChunk[4] = dpi >>> 24; // dpiX highest byte\n    physChunk[5] = dpi >>> 16; // dpiX veryhigh byte\n    physChunk[6] = dpi >>> 8; // dpiX high byte\n    physChunk[7] = dpi & 0xff; // dpiX low byte\n    physChunk[8] = physChunk[4]; // dpiY highest byte\n    physChunk[9] = physChunk[5]; // dpiY veryhigh byte\n    physChunk[10] = physChunk[6]; // dpiY high byte\n    physChunk[11] = physChunk[7]; // dpiY low byte\n    physChunk[12] = 1; // dot per meter....\n\n    var crc = calcCrc(physChunk);\n\n    var crcChunk = new Uint8Array(4);\n    crcChunk[0] = crc >>> 24;\n    crcChunk[1] = crc >>> 16;\n    crcChunk[2] = crc >>> 8;\n    crcChunk[3] = crc & 0xff;\n\n    if (overwritepHYs) {\n      var startingIndex = searchStartOfPhys(dataArray);\n      dataArray.set(physChunk, startingIndex);\n      dataArray.set(crcChunk, startingIndex + 13);\n      return dataArray;\n    } else {\n      // i need to give back an array of data that is divisible by 3 so that\n      // dataurl encoding gives me integers, for luck this chunk is 17 + 4 = 21\n      // if it was we could add a text chunk contaning some info, untill desired\n      // length is met.\n\n      // chunk structur 4 bytes for length is 9\n      var chunkLength = new Uint8Array(4);\n      chunkLength[0] = 0;\n      chunkLength[1] = 0;\n      chunkLength[2] = 0;\n      chunkLength[3] = 9;\n\n      var finalHeader = new Uint8Array(54);\n      finalHeader.set(dataArray, 0);\n      finalHeader.set(chunkLength, 33);\n      finalHeader.set(physChunk, 37);\n      finalHeader.set(crcChunk, 50);\n      return finalHeader;\n    }\n  }\n}","(function(a,b){if(\"function\"==typeof define&&define.amd)define([],b);else if(\"undefined\"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof global&&global.global===global?global:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,\"undefined\"!=typeof module&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map","// @ts-ignore\nimport { changeDpiBlob } from 'changedpi';\nimport { isArray, isFiniteNumber, isPositiveInteger } from '@amandaghassaei/type-checks';\nimport { GPULayer } from './GPULayer';\nimport './GPULayerHelpers';\nimport {\n\tGPULayerType,\n\tFLOAT,\n\tINT,\n\tGLSLVersion,\n\tGLSL1,\n\tGLSL3,\n\tWEBGL2,\n\tWEBGL1,\n\tEXPERIMENTAL_WEBGL,\n\tPROGRAM_NAME_INTERNAL,\n\tCompileTimeConstants,\n\tDEFAULT_PROGRAM_NAME,\n\tSEGMENT_PROGRAM_NAME,\n\tLAYER_POINTS_PROGRAM_NAME,\n\tLAYER_VECTOR_FIELD_PROGRAM_NAME,\n\tLAYER_LINES_PROGRAM_NAME,\n\tErrorCallback,\n\tDEFAULT_CIRCLE_NUM_SEGMENTS,\n\tUINT,\n\tGLSLPrecision,\n\tPRECISION_HIGH_P,\n\tDEFAULT_ERROR_CALLBACK,\n\tGPULayerState,\n\tGPUIO_VS_POSITION_W_ACCUM,\n\tGPUIO_VS_WRAP_X,\n\tGPUIO_VS_WRAP_Y,\n\tMAX_FLOAT_INT,\n\tEXPERIMENTAL_WEBGL2,\n\tBoundaryEdge,\n\tBOUNDARY_LEFT,\n\tBOUNDARY_RIGHT,\n\tBOUNDARY_TOP,\n\tBOUNDARY_BOTTOM,\n\tLAYER_MESH_PROGRAM_NAME,\n} from './constants';\nimport { GPUProgram } from './GPUProgram';\n// Just importing the types here.\n// This repo does not depend on three, only @types/three is installed as dev dependency.\nimport type {\n\tWebGLRenderer,\n\tVector4,\n\tWebGL1Renderer,\n} from 'three';\nimport * as ThreejsUtils from './Vector4';\nimport {\n\tisWebGL2,\n\tinitSequentialFloatArray,\n\tpreprocessVertexShader,\n\tcompileShader,\n\tindexOfLayerInArray,\n} from './utils';\nimport { DEFAULT_VERT_SHADER_SOURCE } from './glsl/vertex/DefaultVertexShader';\nimport { LAYER_LINES_VERTEX_SHADER_SOURCE } from './glsl/vertex/LayerLinesVertexShader';\nimport { SEGMENT_VERTEX_SHADER_SOURCE } from './glsl/vertex/SegmentVertexShader';\nimport { LAYER_POINTS_VERTEX_SHADER_SOURCE } from './glsl/vertex/LayerPointsVertexShader';\nimport { LAYER_VECTOR_FIELD_VERTEX_SHADER_SOURCE } from './glsl/vertex/LayerVectorFieldVertexShader';\nimport { LAYER_MESH_VERTEX_SHADER_SOURCE } from './glsl/vertex/LayerMeshVertexShader';\nimport { uniformTypeForType } from './conversions';\nimport {\n\tcopyProgram,\n\tsetValueProgram,\n} from './Programs';\nimport { checkRequiredKeys, checkValidKeys, isValidClearValue } from './checks';\nimport { bindFrameBuffer } from './framebuffers';\nimport { getExtension, OES_VERTEX_ARRAY_OBJECT } from './extensions';\nimport { GPUIndexBuffer } from './GPUIndexBuffer';\n\nexport class GPUComposer {\n\t/**\n\t * The WebGL context associated with this GPUComposer.\n\t */\n\treadonly gl!: WebGLRenderingContext | WebGL2RenderingContext;\n\t/**\n\t * The GLSL version being used by the GPUComposer.\n\t */\n\treadonly glslVersion!: GLSLVersion;\n\t/**\n\t * Flag for WebGL version.\n\t */\n\treadonly isWebGL2!: boolean;\n\t/**\n\t * The global integer precision to apply to shader programs.\n\t */\n\treadonly intPrecision!: GLSLPrecision;\n\t/**\n\t * The global float precision to apply to shader programs.\n\t */\n\treadonly floatPrecision!: GLSLPrecision;\n\t/**\n\t * Store the width and height of the current canvas at full res.\n\t */\n\tprivate _width!: number;\n\tprivate _height!: number;\n\n\t/**\n\t * @private\n\t */\n\treadonly _errorCallback: ErrorCallback;\n\tprivate _errorState = false;\n\n\t// Save threejs renderer if passed in.\n\t/**\n\t * @private\n\t */\n\treadonly _threeRenderer?: WebGLRenderer | WebGL1Renderer;\n\t\n\t/**\n\t * Precomputed vertex buffers (inited as needed).\n\t */\n\tprivate _quadPositionsBuffer?: WebGLBuffer;\n\tprivate _boundaryPositionsBuffer?: WebGLBuffer;\n\t// Cache multiple circle positions buffers for various num segments, use numSegments as key.\n\tprivate _circlePositionsBuffer: { [key: number]: WebGLBuffer } = {};\n\tprivate _pointIndexArray?: Float32Array;\n\tprivate _pointIndexBuffer?: WebGLBuffer;\n\tprivate _meshIndexArray?: Float32Array;\n\tprivate _meshIndexBuffer?: WebGLBuffer;\n\tprivate _vectorFieldIndexArray?: Float32Array;\n\tprivate _vectorFieldIndexBuffer?: WebGLBuffer;\n\tprivate _indexedLinesIndexBuffer?: WebGLBuffer;\n\t/**\n\t * Cache vertex shader attribute locations.\n\t */\n\tprivate _vertexAttributeLocations: {[key: string]: WeakMap<WebGLProgram, number>} = {};\n\tprivate _enabledVertexAttributes: {[key: number]: boolean} = {};;\n\n\t// Keep track of all GL extensions that have been loaded.\n\t/**\n\t * @private\n\t */\n\treadonly _extensions: { [key: string]: any } = {};\n\n\t// Value to set when clear() is called, defaults to zero.\n\t// Access with GPUComposer.clearValue.\n\tprivate _clearValue: number | number[] = 0;\n\tprivate _clearValueVec4? : number[];\n\n\t/**\n\t * Cache some generic programs for copying data.\n\t * These are needed for rendering partial screen geometries.\n\t */\n\tprivate readonly _copyPrograms: {\n\t\t[FLOAT]?: GPUProgram,\n\t\t[INT]?: GPUProgram,\n\t\t[UINT]?: GPUProgram,\n\t} = {};\n\n\t// Other util programs.\n\t/**\n\t * Cache some generic programs for setting value from uniform.\n\t * These are used by GOUComposer.clear() and GPULayer.clear(), among other things\n\t */\n\tprivate readonly _setValuePrograms: {\n\t\t[FLOAT]?: GPUProgram,\n\t\t[INT]?: GPUProgram,\n\t\t[UINT]?: GPUProgram,\n\t} = {};\n\tprivate _wrappedLineColorProgram?: GPUProgram; // We only need a FLOAT version of this.\n\n\t/**\n\t * Vertex shaders are shared across all GPUProgram instances.\n\t * @private\n\t */\n\treadonly _vertexShaders: {[key in PROGRAM_NAME_INTERNAL]: {\n\t\tsrc: string,\n\t\tcompiledShaders: { [key: string]: WebGLShader },\n\t}} = {\n\t\t[DEFAULT_PROGRAM_NAME]: {\n\t\t\tsrc: DEFAULT_VERT_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[SEGMENT_PROGRAM_NAME]: {\n\t\t\tsrc: SEGMENT_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[LAYER_POINTS_PROGRAM_NAME]: {\n\t\t\tsrc: LAYER_POINTS_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[LAYER_VECTOR_FIELD_PROGRAM_NAME]: {\n\t\t\tsrc: LAYER_VECTOR_FIELD_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[LAYER_LINES_PROGRAM_NAME]: {\n\t\t\tsrc: LAYER_LINES_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[LAYER_MESH_PROGRAM_NAME]: {\n\t\t\tsrc: LAYER_MESH_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t};\n\n\t/**\n\t * Flag to set GPUComposer for verbose logging, defaults to false.\n\t */\n\tverboseLogging = false;\n\n\t/**\n\t * Variables for tracking fps of GPUComposer with tick().\n\t */\n\tprivate _lastTickTime?: number;\n\tprivate _lastTickFPS?: number\n\tprivate _numTicks = 0;\n\n\t/**\n\t * Create a GPUComposer from an existing THREE.WebGLRenderer that shares a single WebGL context.\n\t * @param renderer - Threejs WebGLRenderer.\n\t * @param params - GPUComposer parameters.\n\t * @param params.glslVersion - Set the GLSL version to use, defaults to GLSL3 for WebGL2 contexts.\n\t * @param params.intPrecision - Set the global integer precision in shader programs.\n\t * @param params.floatPrecision - Set the global float precision in shader programs.\n\t * @param params.clearValue - Value to write to canvas when GPUComposer.clear() is called.\n\t * @param params.verboseLogging - Set the verbosity of GPUComposer logging (defaults to false).\n\t * @param params.errorCallback - Custom error handler, defaults to throwing an Error with message.\n\t * @returns \n\t */\n\t static initWithThreeRenderer(\n\t\trenderer: WebGLRenderer| WebGL1Renderer,\n\t\tparams?: {\n\t\t\tglslVersion?: GLSLVersion,\n\t\t\tintPrecision?: GLSLPrecision,\n\t\t\tfloatPrecision?: GLSLPrecision,\n\t\t\tclearValue?: number | number[],\n\t\t\tverboseLogging?: boolean,\n\t\t\terrorCallback?: ErrorCallback,\n\t\t},\n\t) {\n\t\tconst composer = new GPUComposer(\n\t\t\t{\n\t\t\t\tfloatPrecision: renderer.capabilities.precision as GLSLPrecision,\n\t\t\t\tintPrecision: renderer.capabilities.precision as GLSLPrecision,\n\t\t\t\t...params,\n\t\t\t\tcanvas: renderer.domElement,\n\t\t\t\tcontext: renderer.getContext(),\n\t\t\t},\n\t\t);\n\t\t// Attach renderer.\n\t\t// @ts-ignore\n\t\tcomposer._threeRenderer = renderer;\n\t\treturn composer;\n\t}\n\n\t/**\n\t * Create a GPUComposer.\n\t * @param params - GPUComposer parameters.\n\t * @param params.canvas - HTMLCanvasElement associated with this GPUComposer (you must add to DOM yourself).\n\t * @param params.context - Pass in a WebGL context for the GPUComposer to user.\n\t * @param params.contextID - Set the contextID to use when initing a new WebGL context.\n\t * @param params.contextAttributes - Options to pass to WebGL context on initialization (see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext for more information).\n\t * @param params.glslVersion - Set the GLSL version to use, defaults to GLSL3 for WebGL2 contexts.\n\t * @param params.intPrecision - Set the global integer precision in shader programs.\n\t * @param params.floatPrecision - Set the global float precision in shader programs.\n\t * @param params.clearValue - Value to write to canvas when GPUComposer.clear() is called.\n\t * @param params.verboseLogging - Set the verbosity of GPUComposer logging (defaults to false).\n\t * @param params.errorCallback - Custom error handler, defaults to throwing an Error with message.\n\t */\n\tconstructor(\n\t\tparams: {\n\t\t\tcanvas: HTMLCanvasElement,\n\t\t\tcontext?: WebGLRenderingContext | WebGL2RenderingContext,\n\t\t\tcontextID?: typeof WEBGL2 | typeof WEBGL1 | typeof EXPERIMENTAL_WEBGL | typeof EXPERIMENTAL_WEBGL2 | string,\n\t\t\tcontextAttributes?: {\n\t\t\t\t[key: string]: any,\n\t\t\t},\n\t\t\tglslVersion?: GLSLVersion,\n\t\t\tintPrecision?: GLSLPrecision,\n\t\t\tfloatPrecision?: GLSLPrecision,\n\t\t\tclearValue?: number | number[],\n\t\t\tverboseLogging?: boolean,\n\t\t\t// Optionally pass in an error callback in case we want to handle errors related to webgl support.\n\t\t\t// e.g. throw up a modal telling user this will not work on their device.\n\t\t\terrorCallback?: ErrorCallback,\n\t\t},\n\t) {\n\t\t// Check params.\n\t\tconst validKeys = ['canvas', 'context', 'contextID', 'contextAttributes', 'glslVersion', 'intPrecision', 'floatPrecision', 'clearValue', 'verboseLogging', 'errorCallback'];\n\t\tconst requiredKeys = ['canvas'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer(params)');\n\n\t\tif (params.verboseLogging !== undefined) this.verboseLogging = params.verboseLogging;\n\n\t\t// Save callback in case we run into an error.\n\t\tconst self = this;\n\t\tthis._errorCallback = (message: string) => {\n\t\t\tif (self._errorState) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself._errorState = true;\n\t\t\tparams.errorCallback ? params.errorCallback(message) : DEFAULT_ERROR_CALLBACK(message);\n\t\t}\n\n\t\tconst { canvas } = params;\n\t\tlet gl = params.context;\n\n\t\t// Init GL.\n\t\tif (!gl) {\n\t\t\t// Init a gl context if not passed in.\n\t\t\tif (params.contextID) {\n\t\t\t\tconst _gl = canvas.getContext(params.contextID, params.contextAttributes) as WebGLRenderingContext | null;\n\t\t\t\tif (!_gl) {\n\t\t\t\t\tconsole.warn(`Unable to initialize WebGL context with contextID: ${params.contextID}.`);\n\t\t\t\t} else {\n\t\t\t\t\tgl = _gl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!gl) {\n\t\t\t\tconst _gl = canvas.getContext(WEBGL2, params.contextAttributes)  as WebGL2RenderingContext | null\n\t\t\t\t\t|| canvas.getContext(WEBGL1, params.contextAttributes)  as WebGLRenderingContext | null\n\t\t\t\t\t|| canvas.getContext(EXPERIMENTAL_WEBGL2, params.contextAttributes)  as WebGLRenderingContext | null\n\t\t\t\t\t|| canvas.getContext(EXPERIMENTAL_WEBGL, params.contextAttributes)  as WebGLRenderingContext | null;\n\t\t\t\tif (_gl) {\n\t\t\t\t\tgl = _gl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!gl) {\n\t\t\t\tthis._errorCallback('Unable to initialize WebGL context.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.isWebGL2 = isWebGL2(gl);\n\t\tif (this.isWebGL2) {\n\t\t\tif (this.verboseLogging) console.log('Using WebGL 2.0 context.');\n\t\t} else {\n\t\t\tif (this.verboseLogging) console.log('Using WebGL 1.0 context.');\n\t\t}\n\t\tthis.gl = gl;\n\n\t\t// Save glsl version, default to 3 if using webgl2 context.\n\t\tlet glslVersion = params.glslVersion || (this.isWebGL2 ? GLSL3 : GLSL1);\n\t\tif (!this.isWebGL2 && glslVersion === GLSL3) {\n\t\t\tconsole.warn('GLSL3.x is incompatible with WebGL1.0 contexts, falling back to GLSL1.');\n\t\t\tglslVersion = GLSL1; // Fall back to GLSL1 in these cases.\n\t\t}\n\t\tthis.glslVersion = glslVersion;\n\n\t\t// Set default int/float precision.\n\t\tthis.intPrecision = params.intPrecision || PRECISION_HIGH_P;\n\t\tthis.floatPrecision = params.floatPrecision || PRECISION_HIGH_P;\n\n\t\t// GL setup.\n\t\t// Disable depth testing globally.\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\t// Set unpack alignment to 1 so we can have textures of arbitrary dimensions.\n\t\t// https://stackoverflow.com/questions/51582282/error-when-creating-textures-in-webgl-with-the-rgb-format\n\t\tgl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n\t\t// Unbind active buffer.\n\t\tif (this.isWebGL2) (gl as WebGL2RenderingContext).bindVertexArray(null);\n\t\telse {\n\t\t\tconst ext = getExtension(this, OES_VERTEX_ARRAY_OBJECT, true);\n\t\t\text.bindVertexArrayOES(null)\n\t\t}\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n\t\tif (params.clearValue !== undefined) {\n\t\t\tthis.clearValue = params.clearValue;\n\t\t}\n\n\t\t// Canvas setup.\n\t\tthis.resize([canvas.clientWidth, canvas.clientHeight]);\n\n\t\tif (this.verboseLogging) {\n\t\t\t// Log number of textures available.\n\t\t\tconsole.log(`${this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS)} textures max.`);\n\t\t}\n\t}\n\n\tget canvas() {\n\t\treturn this.gl.canvas as HTMLCanvasElement;\n\t}\n\n\t/**\n\t * Gets (and caches) generic set value programs for several input types.\n\t * Used for GPUComposer.clear() and GPULayer.clear(), among other things.\n\t * @private\n\t */\n\t_setValueProgramForType(type: GPULayerType) {\n\t\tconst { _setValuePrograms } = this;\n\t\tconst key = uniformTypeForType(type, this.glslVersion);\n\t\tif (_setValuePrograms[key] === undefined) {\n\t\t\t_setValuePrograms[key] = setValueProgram(this, { type, value: [0, 0, 0, 0] });\n\t\t}\n\t\treturn _setValuePrograms[key]!;\n\t}\n\t/**\n\t * Gets (and caches) generic copy programs for several input types.\n\t * Used for partial rendering to output, among other things.\n\t * @private\n\t */\n\t_copyProgramForType(type: GPULayerType) {\n\t\tconst { _copyPrograms } = this;\n\t\tconst key = uniformTypeForType(type, this.glslVersion);\n\t\tif (_copyPrograms[key] === undefined) {\n\t\t\t_copyPrograms[key] = copyProgram(this, { type });\n\t\t}\n\t\treturn _copyPrograms[key]!;\n\t}\n\t// /**\n\t//  * Gets (and caches) a generic color program for wrapped line segment rendering.\n\t//  * @private\n\t//  */\n\t// private _getWrappedLineColorProgram() {\n\t// \tif (this._wrappedLineColorProgram === undefined) {\n\t// \t\tthis._wrappedLineColorProgram = wrappedLineColorProgram({ composer: this });\n\t// \t}\n\t// \treturn this._wrappedLineColorProgram;\n\t// }\n\n\t/**\n\t * Init a buffer for vertex shader attributes.\n\t * @private\n\t */\n\tprivate _initVertexBuffer(\n\t\tdata: Float32Array,\n\t) {\n\t\tconst { _errorCallback, gl, isWebGL2 } = this;\n\t\t// Unbind any  VAOs.\n\t\tif (isWebGL2) (gl as WebGL2RenderingContext).bindVertexArray(null);\n\t\telse {\n\t\t\tconst ext = getExtension(this, OES_VERTEX_ARRAY_OBJECT, true);\n\t\t\text.bindVertexArrayOES(null)\n\t\t}\n\t\tconst buffer = gl.createBuffer();\n\t\tif (!buffer) {\n\t\t\t_errorCallback('Unable to allocate gl buffer.');\n\t\t\treturn;\n\t\t}\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t// Add buffer data.\n\t\tgl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\t\treturn buffer;\n\t}\n\t/**\n\t * Get (and cache) positions buffer for rendering full screen quads.\n\t * @private\n\t */\n\t_getQuadPositionsBuffer() {\n\t\tif (this._quadPositionsBuffer === undefined) {\n\t\t\tconst fsQuadPositions = new Float32Array([ -1, -1, 1, -1, -1, 1, 1, 1 ]);\n\t\t\tthis._quadPositionsBuffer = this._initVertexBuffer(fsQuadPositions)!;\n\t\t}\n\t\treturn this._quadPositionsBuffer!;\n\t}\n\t/**\n\t * Get (and cache) positions buffer for rendering lines on boundary.\n\t * @private\n\t */\n\tprivate _getBoundaryPositionsBuffer() {\n\t\tif (this._boundaryPositionsBuffer === undefined) {\n\t\t\tconst boundaryPositions = new Float32Array([ -1, -1, 1, -1, 1, 1, -1, 1, -1, -1 ]);\n\t\t\tthis._boundaryPositionsBuffer = this._initVertexBuffer(boundaryPositions)!;\n\t\t}\n\t\treturn this._boundaryPositionsBuffer!;\n\t}\n\t/**\n\t * Get (and cache) positions buffer for rendering circle with various numbers of segments.\n\t * @private\n\t */\n\tprivate _getCirclePositionsBuffer(numSegments: number) {\n\t\tconst { _circlePositionsBuffer } = this;\n\t\tif (_circlePositionsBuffer[numSegments] == undefined) {\n\t\t\tconst unitCirclePoints = [0, 0];\n\t\t\tfor (let i = 0; i < numSegments; i++) {\n\t\t\t\tunitCirclePoints.push(\n\t\t\t\t\tMath.cos(2 * Math.PI * i / numSegments),\n\t\t\t\t\tMath.sin(2 * Math.PI * i / numSegments),\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Add one more point to close the loop on the triangle fan.\n\t\t\tunitCirclePoints.push(\n\t\t\t\tMath.cos(0),\n\t\t\t\tMath.sin(0),\n\t\t\t);\n\t\t\tconst circlePositions = new Float32Array(unitCirclePoints);\n\t\t\tconst buffer = this._initVertexBuffer(circlePositions)!;\n\t\t\t_circlePositionsBuffer[numSegments] = buffer;\n\t\t}\n\t\treturn _circlePositionsBuffer[numSegments];\n\t}\n\n\t/**\n\t * Used internally, see GPULayer.clone() for public API.\n\t * @private\n\t */\n\t_cloneGPULayer(gpuLayer: GPULayer, name?: string) {\n\t\tconst dimensions = gpuLayer.is1D() ? gpuLayer.length : [gpuLayer.width, gpuLayer.height];\n\n\t\tconst clone = new GPULayer(this, {\n\t\t\tname: name || `${gpuLayer.name}-clone`,\n\t\t\tdimensions,\n\t\t\ttype: gpuLayer.type,\n\t\t\tnumComponents: gpuLayer.numComponents,\n\t\t\tfilter: gpuLayer.filter,\n\t\t\twrapX: gpuLayer.wrapX,\n\t\t\twrapY: gpuLayer.wrapY,\n\t\t\tnumBuffers: gpuLayer.numBuffers,\n\t\t\tclearValue: gpuLayer.clearValue,\n\t\t});\n\n\t\t// Copy current state with several draw calls.\n\t\tconst copyProgram = this._copyProgramForType(gpuLayer.type);\n\t\t// Set bufferIndex = gpuLayer.numBuffers - 1.\n\t\tfor (let i = 0; i < gpuLayer.numBuffers - 1; i++ ){\n\t\t\tclone.incrementBufferIndex();\n\t\t}\n\t\tfor (let i = 0; i < gpuLayer.numBuffers; i++) {\n\t\t\tthis.step({\n\t\t\t\tprogram: copyProgram,\n\t\t\t\tinput: gpuLayer.getStateAtIndex(i),\n\t\t\t\toutput: clone,\n\t\t\t});\n\t\t}\n\t\t// Increment clone's buffer index until it is identical to the original layer.\n\t\tfor (let i = -1; i < gpuLayer.bufferIndex; i++ ){\n\t\t\tclone.incrementBufferIndex();\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Gets (and caches) vertex shaders based on shader source code and compile time constants.\n\t * Tries to minimize the number of new vertex shaders that must be compiled.\n\t * @private\n\t */\n\t _getVertexShader(\n\t\tname: PROGRAM_NAME_INTERNAL,\n\t\tvertexID: string,\n\t\tvertexCompileConstants: CompileTimeConstants,\n\t\tprogramName: string,\n\t) {\n\t\tconst {\n\t\t\t_errorCallback,\n\t\t\t_vertexShaders,\n\t\t\tgl,\n\t\t\tglslVersion,\n\t\t\tintPrecision,\n\t\t\tfloatPrecision,\n\t\t} = this;\n\t\tconst { compiledShaders, src } = _vertexShaders[name];\n\t\tif (vertexID === '') vertexID = '_default';\n\t\tif (compiledShaders[vertexID] === undefined) {\n\t\t\t// Compile a vertex shader (this only happens once for each possible vertex shader across all GPUPrograms).\n\t\t\tif (src === '') {\n\t\t\t\tthrow new Error(`Error compiling GPUProgram \"${programName}\": no source for vertex shader with name \"${name}\".`);\n\t\t\t}\n\t\t\tconst preprocessedSrc = preprocessVertexShader(src, glslVersion);\n\t\t\tconst shader = compileShader(\n\t\t\t\tgl,\n\t\t\t\tglslVersion,\n\t\t\t\tintPrecision,\n\t\t\t\tfloatPrecision,\n\t\t\t\tpreprocessedSrc,\n\t\t\t\tgl.VERTEX_SHADER,\n\t\t\t\tprogramName,\n\t\t\t\t_errorCallback,\n\t\t\t\tvertexCompileConstants,\n\t\t\t\tundefined,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t\tif (!shader) {\n\t\t\t\t_errorCallback(`Unable to compile \"${name}${vertexID}\" vertex shader for GPUProgram \"${programName}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Save the results so this does not have to be repeated.\n\t\t\tcompiledShaders[vertexID] = shader;\n\t\t}\n\t\treturn compiledShaders[vertexID];\n\t}\n\n\t/**\n\t * Notify the GPUComposer that the canvas should change size.\n\t * @param dimensions - The new [width, height] to resize to.\n\t */\n\tresize(dimensions: [number, number]) {\n\t\tconst { canvas } = this;\n\t\tconst [width, height] = dimensions;\n\t\tif (!isPositiveInteger(width) || !isPositiveInteger(height)) {\n\t\t\tif (!isArray(dimensions)) throw new Error(`Invalid dimensions parameter supplied to GPUComposer.resize(), expected dimensions array of length 2, got: ${JSON.stringify(dimensions)}`);\n\t\t\telse throw new Error(`Invalid dimensions parameter supplied to GPUComposer.resize(), expected positive integers, got: ${width}, ${height}`);\n\t\t}\n\t\t// Set correct canvas pixel size.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/By_example/Canvas_size_and_WebGL\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\t// Save dimensions.\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t};\n\n\t/**\n\t * Set inputs and outputs in preparation for draw call.\n\t * @private\n\t */\n\tprivate _drawSetup(\n\t\tgpuProgram: GPUProgram,\n\t\tprogramName: PROGRAM_NAME_INTERNAL,\n\t\tvertexCompileConstants: CompileTimeConstants,\n\t\tfullscreenRender: boolean,\n\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\toutput?: GPULayer | GPULayer[],\n\t) {\n\t\tconst { gl } = this;\n\n\t\t// CAUTION: the order of these next few lines is important.\n\n\t\t// Get a shallow copy of current textures.\n\t\t// This line must come before this._setOutputLayer() as it depends on current internal state.\n\t\tconst inputTextures: GPULayerState[] = [];\n\t\tif (input) {\n\t\t\tif ((input as GPULayerState).layer) {\n\t\t\t\tinputTextures.push(input as GPULayerState);\n\t\t\t} else if (input.constructor === GPULayer) {\n\t\t\t\tinputTextures.push((input as GPULayer).currentState);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < (input as (GPULayer | GPULayerState)[]).length; i++) {\n\t\t\t\t\tconst layer = (input as (GPULayer | GPULayerState)[])[i];\n\t\t\t\t\tinputTextures.push((layer as GPULayer).currentState ? (layer as GPULayer).currentState : layer as GPULayerState);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst program = gpuProgram._getProgramWithName(programName, vertexCompileConstants, inputTextures)!;\n\n\t\t// Set output framebuffer.\n\t\t// This may modify WebGL internal state.\n\t\tthis._setOutputLayer(gpuProgram.name, fullscreenRender, input, output);\n\n\t\t// Set current program.\n\t\t// Must do this before calling gpuProgram._setInternalFragmentUniforms(program, inputTextures);\n\t\tgl.useProgram(program);\n\n\t\t// Set input textures.\n\t\tfor (let i = 0; i < inputTextures.length; i++) {\n\t\t\tgl.activeTexture(gl.TEXTURE0 + i);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, inputTextures[i].texture);\n\t\t}\n\t\tgpuProgram._setInternalFragmentUniforms(program, inputTextures);\n\t\treturn program;\n\t}\n\t/**\n\t * Set blend mode for draw call.\n\t * @private\n\t */\n\tprivate _setBlendMode(blendAlpha?: boolean) {\n\t\tconst { gl } = this;\n\t\tif (blendAlpha) {\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\t}\n\t}\n\t/**\n\t * Add GPULayer to inputs if needed.\n\t * @private\n\t */\n\tprivate _addLayerToInputs(\n\t\tlayer: GPULayer,\n\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t) {\n\t\t// Add layer to end of input if needed.\n\t\t// Do this with no mutations.\n\t\tif (input === undefined) {\n\t\t\treturn [layer];\n\t\t}\n\t\tif (isArray(input)) {\n\t\t\t// Return input with layer added if needed.\n\t\t\tif (indexOfLayerInArray(layer, (input as (GPULayer | GPULayerState)[])) >= 0) {\n\t\t\t\treturn input  as (GPULayer | GPULayerState)[];\n\t\t\t}\n\t\t\treturn [...(input as (GPULayer | GPULayerState)[]), layer];\n\t\t}\n\t\tif (input === layer || (input as GPULayerState).layer === layer) {\n\t\t\treturn [input as GPULayerState];\n\t\t}\n\t\treturn [(input as GPULayer | GPULayerState), layer];\n\t}\n\t/**\n\t * Copy data from input to output.\n\t * This is used when rendering to part of output state (not fullscreen quad).\n\t * @private\n\t */\n\tprivate _passThroughLayerDataFromInputToOutput(state: GPULayer) {\n\t\t// TODO: figure out the fastest way to copy a texture.\n\t\tconst copyProgram = this._copyProgramForType(state._internalType);\n\t\tthis.step({\n\t\t\tprogram: copyProgram,\n\t\t\tinput: state,\n\t\t\toutput: state,\n\t\t});\n\t}\n\t/**\n\t * Set output for draw command.\n\t * @private\n\t */\n\tprivate _setOutputLayer(\n\t\tprogramName: string,\n\t\tfullscreenRender: boolean,\n\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t) {\n\t\tconst { gl, isWebGL2 } = this;\n\n\t\t// Render to screen.\n\t\tif (!output) {\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t\t\t// Resize viewport.\n\t\t\tconst { _width, _height } = this;\n\t\t\tgl.viewport(0, 0, _width, _height);\n\t\t\treturn;\n\t\t}\n\n\t\tconst outputArray = (isArray(output) ? output : [output]) as GPULayer[];\n\n\t\tfor (let i = 0, numOutputs = outputArray.length; i < numOutputs; i++) {\n\t\t\tconst outputLayer = outputArray[i];\n\t\t\t// Check if output is same as one of input layers.\n\t\t\tif (input && ((input === output || (input as GPULayerState).layer === output) ||\n\t\t\t\t(isArray(input) && indexOfLayerInArray(outputLayer, input as (GPULayer | GPULayerState)[]) >= 0))) {\n\t\t\t\tif (outputLayer.numBuffers === 1) {\n\t\t\t\t\tthrow new Error(`Cannot use same buffer \"${outputLayer.name}\" for input and output of a program. Try increasing the number of buffers in your output layer to at least 2 so you can render to nextState using currentState as an input.`);\n\t\t\t\t}\n\t\t\t\tif (fullscreenRender) {\n\t\t\t\t\t// Render and increment buffer.\n\t\t\t\t\toutputLayer._prepareForWrite(true);\n\t\t\t\t} else {\n\t\t\t\t\t// Pass input texture through to output.\n\t\t\t\t\tthis._passThroughLayerDataFromInputToOutput(outputLayer);\n\t\t\t\t\t// Render to output without incrementing buffer.\n\t\t\t\t\toutputLayer._prepareForWrite(false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fullscreenRender) {\n\t\t\t\t\t// Render and increment buffer.\n\t\t\t\t\toutputLayer._prepareForWrite(true);\n\t\t\t\t} else {\n\t\t\t\t\t// If we are doing a sneaky thing with a swapped texture and are\n\t\t\t\t\t// only rendering part of the screen, we may need to add a copy operation.\n\t\t\t\t\tif (outputLayer._usingTextureOverrideForCurrentBuffer()) {\n\t\t\t\t\t\tthis._passThroughLayerDataFromInputToOutput(outputLayer);\n\t\t\t\t\t}\n\t\t\t\t\toutputLayer._prepareForWrite(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Bind framebuffer.\n\t\tconst layer0 = outputArray[0];\n\t\tlet additionalTextures: WebGLTexture[] | undefined = undefined;\n\t\tconst drawBuffers = [gl.COLOR_ATTACHMENT0];\n\t\tif (outputArray.length > 1) {\n\t\t\tadditionalTextures = [];\n\t\t\tfor (let i = 1, numOutputs = outputArray.length; i < numOutputs; i++) {\n\t\t\t\tadditionalTextures.push(outputArray[i]._currentTexture);\n\t\t\t\tdrawBuffers.push(gl.COLOR_ATTACHMENT0 + i);\n\t\t\t}\n\t\t}\n\t\tbindFrameBuffer(this, layer0, layer0._currentTexture, additionalTextures);\n\t\t// Tell WebGL to draw to output textures.\n\t\tif (isWebGL2) {\n\t\t\t(gl as WebGL2RenderingContext).drawBuffers(drawBuffers);\n\t\t}\n\t\t// Resize viewport.\n\t\tconst { width, height } = this._widthHeightForOutput(programName, output);\n\t\tgl.viewport(0, 0, width, height);\n\t};\n\t/**\n\t * Set vertex shader attribute.\n\t * @private\n\t */\n\tprivate _setVertexAttribute(program: WebGLProgram, name: string, size: number, programName: string) {\n\t\tconst { gl, _vertexAttributeLocations, _enabledVertexAttributes } = this;\n\t\t// Enable vertex attribute array.\n\t\tlet locations = _vertexAttributeLocations[name];\n\t\tlet location;\n\t\tif (!locations) {\n\t\t\tlocations = new WeakMap<WebGLProgram, number>();\n\t\t\t_vertexAttributeLocations[name] = locations;\n\t\t} else {\n\t\t// \tlocation = locations.get(program);\n\t\t}\n\t\tif (location === undefined) {\n\t\t\tlocation = gl.getAttribLocation(program, name);\n\t\t\tif (location < 0) {\n\t\t\t\tthrow new Error(`Unable to find vertex attribute \"${name}\" in program \"${programName}\".`);\n\t\t\t}\n\t\t\t// Cache attribute location.\n\t\t\tlocations.set(program, location);\n\t\t}\n\n\t\t// INT types not supported for attributes in WebGL1.\n\t\t// We're only really using INT vertex attributes for WebGL1 cases anyway,\n\t\t// because WebGL1 does not support gl_VertexID.\n\t\t// Use FLOAT rather than SHORT bc FLOAT covers more INT range.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\t\tgl.vertexAttribPointer(location, size, gl.FLOAT, false, 0, 0);\n\t\t// Enable the attribute.\n\t\tgl.enableVertexAttribArray(location);\n\t\t_enabledVertexAttributes[location] = true;\n\t}\n\tprivate _disableVertexAttributes() {\n\t\tconst { _enabledVertexAttributes, gl } = this;\n\t\tconst locations = Object.keys(_enabledVertexAttributes) as any as number[];\n\t\tfor (let i = 0, numAttributes = locations.length; i < numAttributes; i++) {\n\t\t\tconst location = locations[i];\n\t\t\tif (_enabledVertexAttributes[location]) {\n\t\t\t\tgl.disableVertexAttribArray(location);\n\t\t\t\tdelete _enabledVertexAttributes[location];\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Set vertex shader position attribute.\n\t * @private\n\t */\n\t_setPositionAttribute(program: WebGLProgram, programName: string) {\n\t\tthis._setVertexAttribute(program, 'a_gpuio_position', 2, programName);\n\t}\n\t/**\n\t * Set vertex shader index attribute.\n\t * @private\n\t */\n\tprivate _setIndexAttribute(program: WebGLProgram, programName: string) {\n\t\tthis._setVertexAttribute(program, 'a_gpuio_index', 1, programName);\n\t}\n\t/**\n\t * Set vertex shader uv attribute.\n\t * @private\n\t */\n\tprivate _setUVAttribute(program: WebGLProgram, programName: string) {\n\t\tthis._setVertexAttribute(program, 'a_gpuio_uv', 2, programName);\n\t}\n\n\tprivate _widthHeightForOutput(programName: string, output?: GPULayer | GPULayer[]) {\n\t\tif (isArray(output)) {\n\t\t\t// Check that all outputs have the same size.\n\t\t\tconst firstOutput = (output as GPULayer[])[0];\n\t\t\tconst width = firstOutput ? firstOutput.width : this._width;\n\t\t\tconst height = firstOutput ? firstOutput.height : this._height;\n\t\t\tfor (let i = 1, numOutputs = (output as GPULayer[]).length; i < numOutputs; i++) {\n\t\t\t\tconst nextOutput = (output as GPULayer[])[i];\n\t\t\t\tif (nextOutput.width !== width || nextOutput.height !== height) {\n\t\t\t\t\tthrow new Error(`Output GPULayers must have the same dimensions, got dimensions [${width}, ${height}] and [${nextOutput.width}, ${nextOutput.height}] for program \"${programName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { width, height };\n\t\t}\n\t\tconst width = output ? (output as GPULayer).width : this._width;\n\t\tconst height = output ? (output as GPULayer).height : this._height;\n\t\treturn { width, height};\n\t}\n\n\t/**\n\t * Call stepping/drawing function once for each output.\n\t * This is required when attempting to draw to multiple outputs using GLSL1.\n\t */\n\tprivate _iterateOverOutputsIfNeeded(params: any, methodName: string) {\n\t\tif (params.output && isArray(params.output) && this.glslVersion === GLSL1) {\n\t\t\tfor (let i = 0, numOutputs = (params.output as GPULayer[]).length; i < numOutputs; i++) {\n\t\t\t\t(this[methodName as keyof this] as any)({\n\t\t\t\t\t...params,\n\t\t\t\t\tprogram: i === 0 ? params.program : params.program._childPrograms![i - 1],\n\t\t\t\t\toutput: (params.output as GPULayer[])[i],\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate _drawFinish(params: {\n\t\tblendAlpha?: boolean,\n\t}) {\n\t\tconst { gl } = this;\n\t\t// Reset WebGL state.\n\t\tif (params.blendAlpha) gl.disable(gl.BLEND);\n\t\t// this._disableVertexAttributes();\n\t}\n\n\t/**\n\t * Step GPUProgram entire fullscreen quad.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstep(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\t// Check params.\n\t\tconst validKeys = ['program', 'input', 'output', 'blendAlpha'];\n\t\tconst requiredKeys = ['program'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.step(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.step(params)');\n\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'step')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, {}, true, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1, 1], FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [0, 0], FLOAT);\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getQuadPositionsBuffer());\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t\tthis._drawFinish(params)\n\t}\n\n\t/**\n\t * Step GPUProgram only for a 1px strip of pixels along the boundary.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.edges - Specify which edges to step, defaults to stepping entire boundary.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstepBoundary(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t\t\tedges?: BoundaryEdge | BoundaryEdge[];\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\t// Check params.\n\t\tconst validKeys = ['program', 'input', 'output', 'edges', 'blendAlpha'];\n\t\tconst requiredKeys = ['program'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.stepBoundary(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.stepBoundary(params)');\n\t\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepBoundary')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\tconst { width, height } = this._widthHeightForOutput(program.name, output);\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\t// Frame needs to be offset and scaled so that all four sides are in viewport.\n\t\tconst onePx = [ 1 / width, 1 / height];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 - onePx[0], 1 - onePx[1]], FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', onePx, FLOAT);\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getBoundaryPositionsBuffer());\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tif (params.edges) {\n\t\t\tlet { edges } = params;\n\t\t\tif (!isArray(edges)) edges = [edges as BoundaryEdge];\n\t\t\tfor (let i = 0, numEdges = edges.length; i < numEdges; i++) {\n\t\t\t\t// TODO: do this in one draw call.\n\t\t\t\tconst edge = edges[i];\n\t\t\t\tif (edge === BOUNDARY_LEFT) {\n\t\t\t\t\tgl.drawArrays(gl.LINES, 3, 2);\n\t\t\t\t}\n\t\t\t\tif (edge === BOUNDARY_RIGHT) {\n\t\t\t\t\tgl.drawArrays(gl.LINES, 1, 2);\n\t\t\t\t}\n\t\t\t\tif (edge === BOUNDARY_TOP) {\n\t\t\t\t\tgl.drawArrays(gl.LINES, 2, 2);\n\t\t\t\t}\n\t\t\t\tif (edge === BOUNDARY_BOTTOM) {\n\t\t\t\t\tgl.drawArrays(gl.LINES, 0, 2);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgl.drawArrays(gl.LINE_LOOP, 0, 4);\n\t\t}\n\t\tthis._drawFinish(params);\n\t}\n\n\t/**\n\t * Step GPUProgram for all but a 1px strip of pixels along the boundary.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstepNonBoundary(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\t// Check params.\n\t\tconst validKeys = ['program', 'input', 'output', 'blendAlpha'];\n\t\tconst requiredKeys = ['program'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.stepNonBoundary(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.stepNonBoundary(params)');\n\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepNonBoundary')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\tconst { width, height } = this._widthHeightForOutput(program.name, output);\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tconst onePx = [ 1 / width, 1 / height];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 - 2 * onePx[0], 1 - 2 * onePx[1]], FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', onePx, FLOAT);\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getQuadPositionsBuffer());\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\t\t\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t\tthis._drawFinish(params);\n\t}\n\n\t/**\n\t * Step GPUProgram inside a circular spot.  This is useful for touch interactions.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.position - Position of center of circle.\n\t * @param params.diameter - Circle diameter in pixels.\n\t * @param params.useOutputScale - If true position and diameter are scaled relative to the output dimensions, else they are scaled relative to the current canvas size, defaults to false.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.numSegments - Number of segments in circle, defaults to 18.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstepCircle(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tposition: number[], // Position is in units of pixels.\n\t\t\tdiameter: number, // Diameter is in units of pixels.\n\t\t\tuseOutputScale?: boolean,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t\t\tnumSegments?: number,\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\t// Check params.\n\t\tconst validKeys = ['program', 'position', 'diameter', 'useOutputScale', 'input', 'output', 'numSegments', 'blendAlpha'];\n\t\tconst requiredKeys = ['program', 'position', 'diameter'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.stepCircle(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.stepCircle(params)');\n\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepCircle')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, position, diameter, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\tlet width = this._width;\n\t\tlet height = this._height;\n\t\tif (params.useOutputScale) {\n\t\t\t({ width, height } = this._widthHeightForOutput(program.name, output));\n\t\t}\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [diameter / width, diameter / height], FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [2 * position[0] / width - 1, 2 * position[1] / height - 1], FLOAT);\n\t\tconst numSegments = params.numSegments ? params.numSegments : DEFAULT_CIRCLE_NUM_SEGMENTS;\n\t\tif (numSegments < 3) {\n\t\t\tthrow new Error(`numSegments for GPUComposer.stepCircle must be greater than 2, got ${numSegments}.`);\n\t\t}\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getCirclePositionsBuffer(numSegments));\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\t\t\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.TRIANGLE_FAN, 0, numSegments + 2);\t\n\t\tthis._drawFinish(params);\n\t}\n\n\t/**\n\t * Step GPUProgram inside a line segment (rounded end caps available).\n\t * This is useful for touch interactions during pointermove.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.position1 - Position of one end of segment.\n\t * @param params.position2 - Position of the other end of segment.\n\t * @param params.thickness - Thickness in pixels.\n\t * @param params.useOutputScale - If true position and thickness are scaled relative to the output dimensions, else they are scaled relative to the current canvas size, defaults to false.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.endCaps - Flag to draw with rounded end caps, defaults to false.\n\t * @param params.numCapSegments - Number of segments in rounded end caps, defaults to 9, must be divisible by 3.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstepSegment(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tposition1: number[], \n\t\t\tposition2: number[],\n\t\t\tthickness: number,\n\t\t\tuseOutputScale?: boolean,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tendCaps?: boolean,\n\t\t\tnumCapSegments?: number,\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\t// Check params.\n\t\tconst validKeys = ['program', 'position1', 'position2', 'thickness', 'useOutputScale', 'input', 'output', 'endCaps', 'numCapSegments', 'blendAlpha'];\n\t\tconst requiredKeys = ['program', 'position1', 'position2', 'thickness'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.stepSegment(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.stepSegment(params)');\n\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepSegment')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, position1, position2, thickness, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\tlet width = this._width;\n\t\tlet height = this._height;\n\t\tif (params.useOutputScale) {\n\t\t\t({ width, height } = this._widthHeightForOutput(program.name, output));\n\t\t}\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, SEGMENT_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_halfThickness', thickness / 2, FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [2 / width, 2 / height], FLOAT);\n\t\tconst diffX = position1[0] - position2[0];\n\t\tconst diffY = position1[1] - position2[1];\n\t\tconst angle = Math.atan2(diffY, diffX);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_rotation', angle, FLOAT);\n\t\tconst centerX = (position1[0] + position2[0]) / 2;\n\t\tconst centerY = (position1[1] + position2[1]) / 2;\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [2 * centerX / width - 1, 2 * centerY / height - 1], FLOAT);\n\t\tconst length = Math.sqrt(diffX * diffX + diffY * diffY);\n\t\t\n\t\tconst numSegments = params.numCapSegments ? params.numCapSegments * 2 : DEFAULT_CIRCLE_NUM_SEGMENTS;\n\t\tif (params.endCaps) {\n\t\t\tif (numSegments < 6 || numSegments % 6 !== 0) {\n\t\t\t\tthrow new Error(`numCapSegments for GPUComposer.stepSegment must be divisible by 3, got ${numSegments / 2}.`);\n\t\t\t}\n\t\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_length', length, FLOAT);\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getCirclePositionsBuffer(numSegments));\n\t\t} else {\n\t\t\t// u_gpuio_length + thickness = length, bc we are stretching a square of size thickness into a rectangle.\n\t\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_length', length - thickness, FLOAT);\n\t\t\t// Use a rectangle in case of no caps.\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getQuadPositionsBuffer());\n\t\t}\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\t\t\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tif (params.endCaps) {\n\t\t\tgl.drawArrays(gl.TRIANGLE_FAN, 0, numSegments + 2);\n\t\t} else {\n\t\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t\t}\n\t\tthis._drawFinish(params);\n\t}\n\n\t/**\n\t * Step GPUProgram inside a rectangle.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.position - Position of one top corner of rectangle.\n\t * @param params.size - Width and height of rectangle.\n\t * @param params.useOutputScale - If true position and size are scaled relative to the output dimensions, else they are scaled relative to the current canvas size, defaults to false.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\t stepRect(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tposition: number[],\n\t\t\tsize: number[],\n\t\t\tuseOutputScale?: boolean,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\t// Check params.\n\t\tconst validKeys = ['program', 'position', 'size', 'useOutputScale', 'input', 'output', 'blendAlpha'];\n\t\tconst requiredKeys = ['program', 'position', 'size'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.stepRect(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.stepRect(params)');\n\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepRect')) return;\n\t\tconst position1 = [params.position[0], params.position[1] + params.size[1] / 2];\n\t\tconst position2 = [params.position[0] + params.size[0], position1[1]];\n\t\tthis.stepSegment({\n\t\t\tprogram: params.program,\n\t\t\tposition1,\n\t\t\tposition2,\n\t\t\tthickness: params.size[1],\n\t\t\tuseOutputScale: params.useOutputScale,\n\t\t\tinput: params.input,\n\t\t\toutput: params.output,\n\t\t\tendCaps: false,\n\t\t\tblendAlpha: params.blendAlpha,\n\t\t});\n\t}\n\n\t// stepPolyline(\n\t// \tparams: {\n\t// \t\tprogram: GPUProgram,\n\t// \t\tpositions: number[][],\n\t// \t\tthickness: number, // Thickness of line is in units of pixels.\n\t// \t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t// \t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t// \t\tcloseLoop?: boolean,\n\t// \t\tincludeUVs?: boolean,\n\t// \t\tincludeNormals?: boolean,\n\t// \t\tblendAlpha?: boolean,\n\t// \t},\n\t// ) {\n\n\t// // Check params.\n\t// const validKeys = ['program', 'positions', 'thickness', 'input', 'output', 'closeLoop', 'includeUVs', 'includeNormals', 'blendAlpha'];\n\t// const requiredKeys = ['program', 'positions', 'thickness'];\n\t// const keys = Object.keys(params);\n\t// checkValidKeys(keys, validKeys, 'GPUComposer.stepPolyline(params)');\n\t// checkRequiredKeys(keys, requiredKeys, 'GPUComposer.stepPolyline(params)');\n\n\t// \tif (this._iterateOverOutputsIfNeeded(params, 'stepPolyline')) return;\n\t// \tconst { gl, _width, _height, _errorState } = this;\n\t// \tconst { program, input, output } = params;\n\n\t// \tif (_errorState) return;\n\n\t// \tconst vertices = params.positions;\n\t// \tconst closeLoop = !!params.closeLoop;\n\t\t\n\t// \t// Offset vertices.\n\t// \tconst halfThickness = params.thickness / 2;\n\t// \tconst numPositions = closeLoop ? vertices.length * 4 + 2 : (vertices.length - 1) * 4;\n\t// \tconst positions = new Float32Array(2 * numPositions);\n\t// \tconst uvs = params.includeUVs ? new Float32Array(2 * numPositions) : undefined;\n\t// \tconst normals = params.includeNormals ? new Float32Array(2 * numPositions) : undefined;\n\n\t// \t// tmp arrays.\n\t// \tconst s1 = [0, 0];\n\t// \tconst s2 = [0, 0];\n\t// \tconst n1 = [0, 0];\n\t// \tconst n2 = [0, 0];\n\t// \tconst n3 = [0, 0];\n\t// \tfor (let i = 0; i < vertices.length; i++) {\n\t// \t\tif (!closeLoop && i === vertices.length - 1) continue;\n\t// \t\t// Vertices on this segment.\n\t// \t\tconst v1 = vertices[i];\n\t// \t\tconst v2 = vertices[(i + 1) % vertices.length];\n\t// \t\ts1[0] = v2[0] - v1[0];\n\t// \t\ts1[1] = v2[1] - v1[1];\n\t// \t\tconst length1 = Math.sqrt(s1[0] * s1[0] + s1[1] * s1[1]);\n\t// \t\tn1[0] = s1[1] / length1;\n\t// \t\tn1[1] = - s1[0] / length1;\n\n\t// \t\tconst index = i * 4 + 2;\n\n\t// \t\tif (!closeLoop && i === 0) {\n\t// \t\t\t// Add starting points to positions array.\n\t// \t\t\tpositions[0] = v1[0] + n1[0] * halfThickness;\n\t// \t\t\tpositions[1] = v1[1] + n1[1] * halfThickness;\n\t// \t\t\tpositions[2] = v1[0] - n1[0] * halfThickness;\n\t// \t\t\tpositions[3] = v1[1] - n1[1] * halfThickness;\n\t// \t\t\tif (uvs) {\n\t// \t\t\t\tuvs[0] = 0;\n\t// \t\t\t\tuvs[1] = 1;\n\t// \t\t\t\tuvs[2] = 0;\n\t// \t\t\t\tuvs[3] = 0;\n\t// \t\t\t}\n\t// \t\t\tif (normals) {\n\t// \t\t\t\tnormals[0] = n1[0];\n\t// \t\t\t\tnormals[1] = n1[1];\n\t// \t\t\t\tnormals[2] = n1[0];\n\t// \t\t\t\tnormals[3] = n1[1];\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t\tconst u = (i + 1) / (vertices.length - 1);\n\n\t// \t\t// Offset from v2.\n\t// \t\tpositions[2 * index] = v2[0] + n1[0] * halfThickness;\n\t// \t\tpositions[2 * index + 1] = v2[1] + n1[1] * halfThickness;\n\t// \t\tpositions[2 * index + 2] = v2[0] - n1[0] * halfThickness;\n\t// \t\tpositions[2 * index + 3] = v2[1] - n1[1] * halfThickness;\n\t// \t\tif (uvs) {\n\t// \t\t\tuvs[2 * index] = u;\n\t// \t\t\tuvs[2 * index + 1] = 1;\n\t// \t\t\tuvs[2 * index + 2] = u;\n\t// \t\t\tuvs[2 * index + 3] = 0;\n\t// \t\t}\n\t// \t\tif (normals) {\n\t// \t\t\tnormals[2 * index] = n1[0];\n\t// \t\t\tnormals[2 * index + 1] = n1[1];\n\t// \t\t\tnormals[2 * index + 2] = n1[0];\n\t// \t\t\tnormals[2 * index + 3] = n1[1];\n\t// \t\t}\n\n\t// \t\tif ((i < vertices.length - 2) || closeLoop) {\n\t// \t\t\t// Vertices on next segment.\n\t// \t\t\tconst v3 = vertices[(i + 1) % vertices.length];\n\t// \t\t\tconst v4 = vertices[(i + 2) % vertices.length];\n\t// \t\t\ts2[0] = v4[0] - v3[0];\n\t// \t\t\ts2[1] = v4[1] - v3[1];\n\t// \t\t\tconst length2 = Math.sqrt(s2[0] * s2[0] + s2[1] * s2[1]);\n\t// \t\t\tn2[0] = s2[1] / length2;\n\t// \t\t\tn2[1] = - s2[0] / length2;\n\n\t// \t\t\t// Offset from v3\n\t// \t\t\tpositions[2 * ((index + 2) % (4 * vertices.length))] = v3[0] + n2[0] * halfThickness;\n\t// \t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 1] = v3[1] + n2[1] * halfThickness;\n\t// \t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 2] = v3[0] - n2[0] * halfThickness;\n\t// \t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 3] = v3[1] - n2[1] * halfThickness;\n\t// \t\t\tif (uvs) {\n\t// \t\t\t\tuvs[2 * ((index + 2) % (4 * vertices.length))] = u;\n\t// \t\t\t\tuvs[2 * ((index + 2) % (4 * vertices.length)) + 1] = 1;\n\t// \t\t\t\tuvs[2 * ((index + 2) % (4 * vertices.length)) + 2] = u;\n\t// \t\t\t\tuvs[2 * ((index + 2) % (4 * vertices.length)) + 3] = 0;\n\t// \t\t\t}\n\t// \t\t\tif (normals) {\n\t// \t\t\t\tnormals[2 * ((index + 2) % (4 * vertices.length))] = n2[0];\n\t// \t\t\t\tnormals[2 * ((index + 2) % (4 * vertices.length)) + 1] = n2[1];\n\t// \t\t\t\tnormals[2 * ((index + 2) % (4 * vertices.length)) + 2] = n2[0];\n\t// \t\t\t\tnormals[2 * ((index + 2) % (4 * vertices.length)) + 3] = n2[1];\n\t// \t\t\t}\n\n\t// \t\t\t// Check the angle between adjacent segments.\n\t// \t\t\tconst cross = n1[0] * n2[1] - n1[1] * n2[0];\n\t// \t\t\tif (Math.abs(cross) < 1e-6) continue;\n\t// \t\t\tn3[0] = n1[0] + n2[0];\n\t// \t\t\tn3[1] = n1[1] + n2[1];\n\t// \t\t\tconst length3 = Math.sqrt(n3[0] * n3[0] + n3[1] * n3[1]);\n\t// \t\t\tn3[0] /= length3;\n\t// \t\t\tn3[1] /= length3;\n\t// \t\t\t// Make adjustments to positions.\n\t// \t\t\tconst angle = Math.acos(n1[0] * n2[0] + n1[1] * n2[1]);\n\t// \t\t\tconst offset = halfThickness / Math.cos(angle / 2);\n\t// \t\t\tif (cross < 0) {\n\t// \t\t\t\tpositions[2 * index] = v2[0] + n3[0] * offset;\n\t// \t\t\t\tpositions[2 * index + 1] = v2[1] + n3[1] * offset;\n\t// \t\t\t\tpositions[2 * ((index + 2) % (4 * vertices.length))] = positions[2 * index];\n\t// \t\t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 1] = positions[2 * index + 1];\n\t// \t\t\t} else {\n\t// \t\t\t\tpositions[2 * index + 2] = v2[0] - n3[0] * offset;\n\t// \t\t\t\tpositions[2 * index + 3] = v2[1] - n3[1] * offset;\n\t// \t\t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 2] = positions[2 * index + 2];\n\t// \t\t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 3] = positions[2 * index + 3];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \tif (closeLoop) {\n\t// \t\t// Duplicate starting points to end of positions array.\n\t// \t\tpositions[vertices.length * 8] = positions[0];\n\t// \t\tpositions[vertices.length * 8 + 1] = positions[1];\n\t// \t\tpositions[vertices.length * 8 + 2] = positions[2];\n\t// \t\tpositions[vertices.length * 8 + 3] = positions[3];\n\t// \t\tif (uvs) {\n\t// \t\t\tuvs[vertices.length * 8] = uvs[0];\n\t// \t\t\tuvs[vertices.length * 8 + 1] = uvs[1];\n\t// \t\t\tuvs[vertices.length * 8 + 2] = uvs[2];\n\t// \t\t\tuvs[vertices.length * 8 + 3] = uvs[3];\n\t// \t\t}\n\t// \t\tif (normals) {\n\t// \t\t\tnormals[vertices.length * 8] = normals[0];\n\t// \t\t\tnormals[vertices.length * 8 + 1] = normals[1];\n\t// \t\t\tnormals[vertices.length * 8 + 2] = normals[2];\n\t// \t\t\tnormals[vertices.length * 8 + 3] = normals[3];\n\t// \t\t}\n\t// \t}\n\n\t// \tconst vertexShaderOptions: CompileTimeConstants = {};\n\t// \tif (uvs) vertexShaderOptions[GPUIO_VS_UV_ATTRIBUTE] = '1';\n\t// \tif (normals) vertexShaderOptions[GPUIO_VS_NORMAL_ATTRIBUTE] = '1';\n\n\t// \t// Do setup - this must come first.\n\t// \tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t// \t// Update uniforms and buffers.\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [2 / _width, 2 / _height], FLOAT);\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [-1, -1], FLOAT);\n\t// \t// Init positions buffer.\n\t// \tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(positions)!);\n\t// \tthis._setPositionAttribute(glProgram, program.name);\n\t// \tif (uvs) {\n\t// \t\t// Init uv buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(uvs)!);\n\t// \t\tthis._setUVAttribute(glProgram, program.name);\n\t// \t}\n\t// \tif (normals) {\n\t// \t\t// Init normals buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(normals)!);\n\t// \t\tthis._setVertexAttribute(glProgram, 'a_gpuio_normal', 2, program.name);\n\t// \t}\n\n\t// \t// Draw.\n\t// \tthis._setBlendMode(params.blendAlpha);\n\t// \tgl.drawArrays(gl.TRIANGLE_STRIP, 0, numPositions);\n\t// \tthis._drawFinish();\n\t// }\n\n\t// stepTriangleStrip(\n\t// \tparams: {\n\t// \t\tprogram: GPUProgram,\n\t// \t\tpositions: Float32Array,\n\t// \t\tnormals?: Float32Array,\n\t// \t\tuvs?: Float32Array,\n\t// \t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t// \t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t// \t\tcount?: number,\n\t// \t\tblendAlpha?: boolean,\n\t// \t},\n\t// ) {\n\t// \tif (this._iterateOverOutputsIfNeeded(params, 'stepTriangleStrip')) return;\n\t// \tconst { gl, _width, _height, _errorState } = this;\n\t// \tconst { program, input, output, positions, uvs, normals } = params;\n\n\t// \tif (_errorState) return;\n\n\t// \tconst vertexShaderOptions: CompileTimeConstants = {};\n\t// \tif (uvs) vertexShaderOptions[GPUIO_VS_UV_ATTRIBUTE] = '1';\n\t// \tif (normals) vertexShaderOptions[GPUIO_VS_NORMAL_ATTRIBUTE] = '1';\n\n\t// \t// Do setup - this must come first.\n\t// \tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t// \t// Update uniforms and buffers.\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [2 / _width, 2 / _height], FLOAT);\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [-1, -1], FLOAT);\n\t// \t// Init positions buffer.\n\t// \tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(positions)!);\n\t// \tthis._setPositionAttribute(glProgram, program.name);\n\t// \tif (uvs) {\n\t// \t\t// Init uv buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(uvs)!);\n\t// \t\tthis._setUVAttribute(glProgram, program.name);\n\t// \t}\n\t// \tif (normals) {\n\t// \t\t// Init normals buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(normals)!);\n\t// \t\tthis._setVertexAttribute(glProgram, 'a_gpuio_normal', 2, program.name);\n\t// \t}\n\n\t// \tconst count = params.count ? params.count : positions.length / 2;\n\n\t// \t// Draw.\n\t// \tthis._setBlendMode(params.blendAlpha);\n\t// \tgl.drawArrays(gl.TRIANGLE_STRIP, 0, count);\n\t// \tthis._drawFinish();\n\t// }\n\n\t// stepLines(params: {\n\t// \tprogram: GPUProgram,\n\t// \tpositions: Float32Array,\n\t// \tindices?: Uint16Array | Uint32Array | Int16Array | Int32Array,\n\t// \tnormals?: Float32Array,\n\t// \tuvs?: Float32Array,\n\t// \tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t// \toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t// \tcount?: number,\n\t// \tcloseLoop?: boolean,\n\t// \tblendAlpha?: boolean,\n\t// }) {\n\t// \tconst { gl, _width, _height, _errorState } = this;\n\t// \tconst { indices, uvs, normals, input, output, program } = params;\n\n\t// \tif (_errorState) return;\n\n\t// \t// Check that params are valid.\n\t// \tif (params.closeLoop && indices) {\n\t// \t\tthrow new Error(`GPUComposer.stepLines() can't be called with closeLoop == true and indices.`);\n\t// \t}\n\n\t// \tconst vertexShaderOptions: CompileTimeConstants = {};\n\t// \tif (uvs) vertexShaderOptions[GPUIO_VS_UV_ATTRIBUTE] = '1';\n\t// \tif (normals) vertexShaderOptions[GPUIO_VS_NORMAL_ATTRIBUTE] = '1';\n\n\t// \t// Do setup - this must come first.\n\t// \tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t// \tconst count = params.count ? params.count : (indices ? indices.length : (params.positions.length / 2));\n\n\t// \t// Update uniforms and buffers.\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [2 / _width, 2 / _height], FLOAT);\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [-1, -1], FLOAT);\n\t// \tif (indices) {\n\t// \t\t// Reorder positions array to match indices.\n\t// \t\tconst positions = new Float32Array(2 * count);\n\t// \t\tfor (let i = 0; i < count; i++) {\n\t// \t\t\tconst index = indices[i];\n\t// \t\t\tpositions[2 * i] = params.positions[2 * index];\n\t// \t\t\tpositions[2 * i + 1] = params.positions[2 * index + 1];\n\t// \t\t}\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(positions)!);\n\t// \t} else {\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(params.positions)!);\n\t// \t}\n\t// \tthis._setPositionAttribute(glProgram, program.name);\n\t// \tif (uvs) {\n\t// \t\t// Init uv buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(uvs)!);\n\t// \t\tthis._setUVAttribute(glProgram, program.name);\n\t// \t}\n\t// \tif (normals) {\n\t// \t\t// Init normals buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(normals)!);\n\t// \t\tthis._setVertexAttribute(glProgram, 'a_gpuio_normal', 2, program.name);\n\t// \t}\n\n\t// \t// Draw.\n\t// \tthis._setBlendMode(params.blendAlpha);\n\t// \tif (params.indices) {\n\t// \t\tgl.drawArrays(gl.LINES, 0, count);\n\t// \t} else {\n\t// \t\tif (params.closeLoop) {\n\t// \t\t\tgl.drawArrays(gl.LINE_LOOP, 0, count);\n\t// \t\t} else {\n\t// \t\t\tgl.drawArrays(gl.LINE_STRIP, 0, count);\n\t// \t\t}\n\t// \t}\n\t// \tthis._drawFinish(params);\n\t// }\n\n\t/**\n\t * Draw the contents of a GPULayer as points.  This assumes the components of the GPULayer have the form [xPosition, yPosition] or [xPosition, yPosition, xOffset, yOffset].\n\t * @param params - Draw parameters.\n\t * @param params.layer - GPULayer containing position data.\n\t * @param params.program - GPUProgram to run, defaults to drawing points in red.\n\t * @param params.input - Input GPULayers for GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.pointSize - Pixel size of points.\n\t * @param params.useOutputScale - If true position and pointSize are scaled relative to the output dimensions, else they are scaled relative to the current canvas size, defaults to false.\n\t * @param params.count - How many points to draw, defaults to positions.length.\n\t * @param params.color - (If no program passed in) RGB color in range [0, 1] to draw points.\n\t * @param params.wrapX - Wrap points positions in X, defaults to false.\n\t * @param params.wrapY - Wrap points positions in Y, defaults to false.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tdrawLayerAsPoints(\n\t\tparams: {\n\t\t\tlayer: GPULayer, // Positions in units of pixels.\n\t\t\tprogram?: GPUProgram,\n\t\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tpointSize?: number,\n\t\t\tuseOutputScale?: boolean,\n\t\t\tcount?: number,\n\t\t\tcolor?: number[],\n\t\t\twrapX?: boolean,\n\t\t\twrapY?: boolean,\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tconst validKeys = ['layer', 'program', 'input', 'output', 'pointSize', 'useOutputScale', 'count', 'color', 'wrapX', 'wrapY', 'blendAlpha'];\n\t\tconst requiredKeys = ['layer'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.drawLayerAsPoints(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.drawLayerAsPoints(params)');\n\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'drawLayerAsPoints')) return;\n\t\tconst { gl, _pointIndexArray, glslVersion, _errorState } = this;\n\t\tconst { layer, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\t// Check that numPoints is valid.\n\t\tif (layer.numComponents !== 2 && layer.numComponents !== 4) {\n\t\t\tthrow new Error(`GPUComposer.drawLayerAsPoints() must be passed a layer parameter with either 2 or 4 components, got layer \"${layer.name}\" with ${layer.numComponents} components.`);\n\t\t}\n\t\tconst { length } = layer;\n\t\tconst count = params.count || length;\n\t\tif (count > length) {\n\t\t\tthrow new Error(`Invalid count ${count} for layer parameter of length ${length}.`);\n\t\t}\n\t\tif (glslVersion === GLSL1 && count > MAX_FLOAT_INT) {\n\t\t\tconsole.warn(`Points positions array length: ${count} is longer than what is supported by GLSL1 : ${MAX_FLOAT_INT}.`);\n\t\t}\n\n\t\tlet program = params.program;\n\t\tif (program === undefined) {\n\t\t\tprogram = this._setValueProgramForType(FLOAT);\n\t\t\tconst color = params.color || [1, 0, 0]; // Default of red.\n\t\t\tif (color.length !== 3) throw new Error(`Color parameter must have length 3, got ${JSON.stringify(color)}.`);\n\t\t\tprogram.setUniform('u_value', [...color, 1], FLOAT);\n\t\t}\n\n\t\t// Add positions to end of input if needed.\n\t\tconst input = this._addLayerToInputs(layer, params.input);\n\n\t\tconst vertexShaderOptions: CompileTimeConstants = {};\n\t\t// Tell whether we are using an absolute position (2 components),\n\t\t// or position with accumulation buffer (4 components, better floating pt accuracy).\n\t\tif (layer.numComponents === 4) vertexShaderOptions[GPUIO_VS_POSITION_W_ACCUM] = '1';\n\t\tif (params.wrapX) vertexShaderOptions[GPUIO_VS_WRAP_X] = '1';\n\t\tif (params.wrapY) vertexShaderOptions[GPUIO_VS_WRAP_Y] = '1';\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, LAYER_POINTS_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_positions', indexOfLayerInArray(layer, input), INT);\n\t\tlet width = this._width;\n\t\tlet height = this._height;\n\t\tif (params.useOutputScale) {\n\t\t\t({ width, height } = this._widthHeightForOutput(program.name, output));\n\t\t}\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 / width, 1 / height], FLOAT);\n\t\t// Set default pointSize.\n\t\tconst pointSize = params.pointSize || 1;\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_pointSize', pointSize, FLOAT);\n\t\tconst positionLayerDimensions = [layer.width, layer.height];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_positionsDimensions', positionLayerDimensions, FLOAT);\n\t\t// We get this for free in GLSL3 with gl_VertexID.\n\t\tif (glslVersion === GLSL1) {\n\t\t\tif (this._pointIndexBuffer === undefined || (_pointIndexArray && _pointIndexArray.length < count)) {\n\t\t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t\t\t\tconst indices = initSequentialFloatArray(length);\n\t\t\t\tthis._pointIndexArray = indices;\n\t\t\t\tthis._pointIndexBuffer = this._initVertexBuffer(indices);\n\t\t\t}\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._pointIndexBuffer!);\n\t\t\tthis._setIndexAttribute(glProgram, program.name);\n\t\t}\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.POINTS, 0, count);\n\t\tthis._drawFinish(params);\n\t}\n\n\t// drawLayerAsLines(\n\t// \tparams: {\n\t// \t\tpositions: GPULayer,\n\t// \t\tindices?: Float32Array | Uint16Array | Uint32Array | Int16Array | Int32Array,\n\t// \t\tprogram?: GPUProgram,\n\t// \t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t// \t\toutput?: GPULayer | GPULayer[],\n\t// \t\tcount?: number,\n\t// \t\tcolor?: number[]\n\t// \t\twrapX?: boolean,\n\t// \t\twrapY?: boolean,\n\t// \t\tcloseLoop?: boolean,\n\t// \t\tblendAlpha?: boolean,\n\t// \t},\n\t// ) {\n\t// const validKeys = ['positions', 'indices', 'program', 'input', 'output', 'count', 'color', 'wrapX', 'wrapY', 'closeLoop', 'blendAlpha'];\n\t// const requiredKeys = ['positions'];\n\t// const keys = Object.keys(params);\n\t// checkValidKeys(keys, validKeys, 'GPUComposer.drawLayerAsLines(params)');\n\t// checkRequiredKeys(keys, requiredKeys, 'GPUComposer.drawLayerAsLines(params)');\n\t// \tif (this._iterateOverOutputsIfNeeded(params, 'drawLayerAsLines')) return;\n\t// \tconst { gl, _width, _height, glslVersion, _errorState } = this;\n\t// \tconst { positions, output } = params;\n\n\t// \tif (_errorState) return;\n\n\t// \t// Check that positions is valid.\n\t// \tif (positions.numComponents !== 2 && positions.numComponents !== 4) {\n\t// \t\tthrow new Error(`GPUComposer.drawLayerAsLines() must be passed a position GPULayer with either 2 or 4 components, got position GPULayer \"${positions.name}\" with ${positions.numComponents} components.`)\n\t// \t}\n\t// \t// Check that params are valid.\n\t// \tif (params.closeLoop && params.indices) {\n\t// \t\tthrow new Error(`GPUComposer.drawLayerAsLines() can't be called with closeLoop == true and indices.`);\n\t// \t}\n\n\t// \tlet program = params.program;\n\t// \tif (program === undefined) {\n\t// \t\tprogram = params.wrapX || params.wrapY ? this._getWrappedLineColorProgram() : this._setValueProgramForType(FLOAT);;\n\t// \t\tconst color = params.color || [1, 0, 0]; // Default to red.\n\t//\t\tif (color.length !== 3) throw new Error(`color parameter must have length 3, got ${JSON.stringify(color)}.`);\n\t// \t\tprogram.setUniform('u_value', [...color, 1], FLOAT);\n\t// \t}\n\n\t// \t// Add positionLayer to end of input if needed.\n\t// \tconst input = this._addLayerToInputs(positions, params.input);\n\n\t// \tconst vertexShaderOptions: CompileTimeConstants = {};\n\t// \t// Tell whether we are using an absolute position (2 components),\n\t// \t// or position with accumulation buffer (4 components, better floating pt accuracy).\n\t// \tif (positions.numComponents === 4) vertexShaderOptions[GPUIO_VS_POSITION_W_ACCUM] = '1';\n\t// \tif (params.wrapX) vertexShaderOptions[GPUIO_VS_WRAP_X] = '1';\n\t// \tif (params.wrapY) vertexShaderOptions[GPUIO_VS_WRAP_Y] = '1';\n\t// \tvertexShaderOptions[GPUIO_VS_INDEXED_POSITIONS] = params.indices ? '1': '0';\n\n\t// \t// Do setup - this must come first.\n\t// \tconst glProgram = this._drawSetup(program, LAYER_LINES_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t// \tconst count = params.count ? params.count : (params.indices ? params.indices.length : positions.length);\n\n\t// \t// Update uniforms and buffers.\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_positions', indexOfLayerInArray(positions, input), INT);\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 / _width, 1 / _height], FLOAT);\n\t// \tconst positionLayerDimensions = [positions.width, positions.height];\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_positionsDimensions', positionLayerDimensions, FLOAT);\n\t// \t// Only pass in indices if we are using indexed pts or GLSL1, otherwise we get this for free from gl_VertexID.\n\t// \tif (params.indices || glslVersion === GLSL1) {\n\t// \t\t// TODO: cache indexArray if no indices passed in.\n\t// \t\tconst indices = params.indices ? params.indices : initSequentialFloatArray(count);\n\t// \t\tif (this._indexedLinesIndexBuffer === undefined) {\n\t// \t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t// \t\t\tlet floatArray: Float32Array;\n\t// \t\t\tif (indices.constructor !== Float32Array) {\n\t// \t\t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t// \t\t\t\tfloatArray = new Float32Array(indices.length);\n\t// \t\t\t\tfor (let i = 0; i < count; i++) {\n\t// \t\t\t\t\tfloatArray[i] = indices[i];\n\t// \t\t\t\t}\n\t// \t\t\t\tconsole.warn(`Converting indices array of type ${indices.constructor} to Float32Array in GPUComposer.drawIndexedLines for WebGL compatibility, you may want to use a Float32Array to store this information so the conversion is not required.`);\n\t// \t\t\t} else {\n\t// \t\t\t\tfloatArray = indices as Float32Array;\n\t// \t\t\t}\n\t// \t\t\tthis._indexedLinesIndexBuffer = this._initVertexBuffer(floatArray);\n\t// \t\t} else {\n\t// \t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._indexedLinesIndexBuffer!);\n\t// \t\t\t// Copy buffer data.\n\t// \t\t\tgl.bufferData(gl.ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n\t// \t\t}\n\t// \t\tthis._setIndexAttribute(glProgram, program.name);\n\t// \t}\n\n\t// \t// Draw.\n\t// \tthis._setBlendMode(params.blendAlpha);\n\t// \tif (params.indices) {\n\t// \t\tgl.drawArrays(gl.LINES, 0, count);\n\t// \t} else {\n\t// \t\tif (params.closeLoop) {\n\t// \t\t\tgl.drawArrays(gl.LINE_LOOP, 0, count);\n\t// \t\t} else {\n\t// \t\t\tgl.drawArrays(gl.LINE_STRIP, 0, count);\n\t// \t\t}\n\t// \t}\n\t// \tthis._drawFinish(params);\n\t// }\n\n\t/**\n\t * Draw the contents of a 2 component GPULayer as a vector field.\n\t * @param params - Draw parameters.\n\t * @param params.layer - GPULayer containing vector data.\n\t * @param params.program - GPUProgram to run, defaults to drawing vector lines in red.\n\t * @param params.input - Input GPULayers for GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.vectorSpacing - Spacing between vectors, defaults to drawing a vector every 10 pixels.\n\t * @param params.vectorScale - Scale factor to apply to vector lengths.\n\t * @param params.color - (If no program passed in) RGB color in range [0, 1] to draw points.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tdrawLayerAsVectorField(\n\t\tparams: {\n\t\t\tlayer: GPULayer,\n\t\t\tprogram?: GPUProgram,\n\t\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tvectorSpacing?: number,\n\t\t\tvectorScale?: number,\n\t\t\tcolor?: number[],\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tconst validKeys = ['layer', 'program', 'input', 'output', 'vectorSpacing', 'vectorScale', 'color', 'blendAlpha'];\n\t\tconst requiredKeys = ['layer'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.drawLayerAsVectorField(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.drawLayerAsVectorField(params)');\n\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'drawLayerAsVectorField')) return;\n\t\tconst { gl, _vectorFieldIndexArray, _width, _height, glslVersion, _errorState } = this;\n\t\tconst { layer, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\t// Check that field is valid.\n\t\tif (layer.numComponents !== 2) {\n\t\t\tthrow new Error(`GPUComposer.drawLayerAsVectorField() must be passed a fieldLayer with 2 components, got fieldLayer \"${layer.name}\" with ${layer.numComponents} components.`);\n\t\t}\n\t\t// Check aspect ratio.\n\t\t// const dimensions = [vectorLayer.width, vectorLayer.height];\n\t\t// if (Math.abs(dimensions[0] / dimensions[1] - width / height) > 0.01) {\n\t\t// \tthrow new Error(`Invalid aspect ratio ${(dimensions[0] / dimensions[1]).toFixed(3)} vector GPULayer with dimensions [${dimensions[0]}, ${dimensions[1]}], expected ${(width / height).toFixed(3)}.`);\n\t\t// }\n\n\t\tlet program = params.program;\n\t\tif (program === undefined) {\n\t\t\tprogram = this._setValueProgramForType(FLOAT);;\n\t\t\tconst color = params.color || [1, 0, 0]; // Default to red.\n\t\t\tif (color.length !== 3) throw new Error(`color parameter must have length 3, got ${JSON.stringify(color)}.`);\n\t\t\tprogram.setUniform('u_value', [...color, 1], FLOAT);\n\t\t}\n\n\t\t// Add data to end of input if needed.\n\t\tconst input = this._addLayerToInputs(layer, params.input);\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, LAYER_VECTOR_FIELD_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_vectors', indexOfLayerInArray(layer, input), INT);\n\t\t// Set default scale.\n\t\tconst vectorScale = params.vectorScale || 1;\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [vectorScale / _width, vectorScale / _height], FLOAT);\n\t\tconst vectorSpacing = params.vectorSpacing || 10;\n\t\tconst spacedDimensions = [Math.floor(_width / vectorSpacing), Math.floor(_height / vectorSpacing)];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_dimensions', spacedDimensions, FLOAT);\n\t\tconst length = 2 * spacedDimensions[0] * spacedDimensions[1];\n\t\t// We get this for free in GLSL3 with gl_VertexID.\n\t\tif (glslVersion === GLSL1) {\n\t\t\tif (this._vectorFieldIndexBuffer === undefined || (_vectorFieldIndexArray && _vectorFieldIndexArray.length < length)) {\n\t\t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t\t\t\tconst indices = initSequentialFloatArray(length);\n\t\t\t\tthis._vectorFieldIndexArray = indices;\n\t\t\t\tthis._vectorFieldIndexBuffer = this._initVertexBuffer(indices);\n\t\t\t}\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._vectorFieldIndexBuffer!);\n\t\t\tthis._setIndexAttribute(glProgram, program.name);\n\t\t}\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.LINES, 0, length);\n\t\tthis._drawFinish(params);\n\t}\n\n\t/**\n\t * Draw 2D mesh to screen.\n\t * @param params - Draw parameters.\n\t * @param params.layer - GPULayer containing vector data.\n\t * @param params.indices - GPUIndexBuffer containing mesh index data.\n\t * @param params.program - GPUProgram to run, defaults to drawing vector lines in red.\n\t * @param params.input - Input GPULayers for GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.useOutputScale - If true positions are scaled relative to the output dimensions, else they are scaled relative to the current canvas size, defaults to false.\n\t * @param params.color - (If no program passed in) RGB color in range [0, 1] to draw points.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\t drawLayerAsMesh(\n\t\tparams: {\n\t\t\tlayer: GPULayer,\n\t\t\tindices?: GPUIndexBuffer,\n\t\t\tprogram?: GPUProgram,\n\t\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tuseOutputScale?: boolean,\n\t\t\tcolor?: number[],\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tconst validKeys = ['layer', 'indices', 'program', 'input', 'output', 'useOutputScale', 'color', 'blendAlpha'];\n\t\tconst requiredKeys = ['layer'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.drawLayerAsMesh(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer.drawLayerAsMesh(params)');\n\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'drawLayerAsMesh')) return;\n\t\tconst { gl, _width, _height, glslVersion, _errorState, _meshIndexBuffer, _meshIndexArray } = this;\n\t\tconst { layer, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\t// Check that layer is valid.\n\t\tif (layer.numComponents !== 2 && layer.numComponents !== 4) {\n\t\t\tthrow new Error(`GPUComposer.drawLayerAsMesh() must be passed a layer parameter with either 2 or 4 components, got position GPULayer \"${layer.name}\" with ${layer.numComponents} components.`);\n\t\t}\n\n\t\tconst positionsCount = layer.is1D() ? layer.length : layer.width * layer.height;\n\t\tif (glslVersion === GLSL1 && positionsCount > MAX_FLOAT_INT) {\n\t\t\tconsole.warn(`Mesh positions array length: ${positionsCount} is longer than what is supported by GLSL1 : ${MAX_FLOAT_INT}.`);\n\t\t}\n\n\t\tlet program = params.program;\n\t\tif (program === undefined) {\n\t\t\tprogram = this._setValueProgramForType(FLOAT);\n\t\t\tconst color = params.color || [1, 0, 0]; // Default of red.\n\t\t\tif (color.length !== 3) throw new Error(`Color parameter must have length 3, got ${JSON.stringify(color)}.`);\n\t\t\tprogram.setUniform('u_value', [...color, 1], FLOAT);\n\t\t}\n\n\t\t// Add positions to end of input if needed.\n\t\tconst input = this._addLayerToInputs(layer, params.input);\n\n\t\tconst vertexShaderOptions: CompileTimeConstants = {};\n\t\t// Tell whether we are using an absolute position (2 components),\n\t\t// or position with accumulation buffer (4 components, better floating pt accuracy).\n\t\tif (layer.numComponents === 4) vertexShaderOptions[GPUIO_VS_POSITION_W_ACCUM] = '1';\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, LAYER_MESH_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_positions', indexOfLayerInArray(layer, input), INT);\n\t\tlet width = _width;\n\t\tlet height = _height;\n\t\tif (params.useOutputScale) {\n\t\t\t({ width, height } = this._widthHeightForOutput(program.name, output));\n\t\t}\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 / width, 1 / height], FLOAT);\n\t\tconst positionLayerDimensions = [layer.width, layer.height];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_positionsDimensions', positionLayerDimensions, FLOAT);\n\t\t// We get this for free in GLSL3 with gl_VertexID.\n\t\tif (glslVersion === GLSL1) {\n\t\t\tif (_meshIndexBuffer === undefined || (_meshIndexArray && _meshIndexArray.length < positionsCount)) {\n\t\t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t\t\t\tconst indices = initSequentialFloatArray(positionsCount);\n\t\t\t\tthis._meshIndexArray = indices;\n\t\t\t\tthis._meshIndexBuffer = this._initVertexBuffer(indices);\n\t\t\t}\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._meshIndexBuffer!);\n\t\t\tthis._setIndexAttribute(glProgram, program.name);\n\t\t}\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tif (params.indices) {\n\t\t\tconst { glType, count, buffer } = params.indices;\n\t\t\t// https://webglfundamentals.org/webgl/lessons/webgl-indexed-vertices.html\n\t\t\t// Make index buffer the current ELEMENT_ARRAY_BUFFER.\n\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n\t\t\tconst offset = 0;\n\t\t\tgl.drawElements(gl.TRIANGLES, count, glType, offset);\n\t\t} else {\n\t\t\t// We are assuming that positions are already grouped into triangles.\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, positionsCount);\n\t\t}\n\t\tthis._drawFinish(params);\n\t}\n\n\t/**\n\t * Set the clearValue of the GPUComposer, which is applied during GPUComposer.clear().\n\t */\n\tset clearValue(clearValue: number | number[]) {\n\t\tconst type = FLOAT;\n\t\tconst numComponents = 4;\n\t\tif (!isValidClearValue(clearValue, numComponents, type)) {\n\t\t\tthrow new Error(`Invalid clearValue: ${JSON.stringify(clearValue)} for GPUComposer, expected ${type} or array of ${type} of length ${numComponents}.`);\n\t\t}\n\t\t// Make deep copy if needed.\n\t\tthis._clearValue = isArray(clearValue) ? (clearValue as number[]).slice() : clearValue;\n\t\tthis._clearValueVec4 = undefined;\n\t}\n\n\t/**\n\t * Get the clearValue of the GPUComposer.\n\t */\n\tget clearValue() {\n\t\treturn this._clearValue;\n\t}\n\n\t/**\n\t * Get the clearValue of the GPUComposer as a vec4, pad with zeros as needed.\n\t */\n\tprivate get clearValueVec4() {\n\t\tlet { _clearValueVec4 } = this;\n\t\tif (!_clearValueVec4) {\n\t\t\tconst { clearValue } = this;\n\t\t\t_clearValueVec4 = [];\n\t\t\tif (isFiniteNumber(clearValue)) {\n\t\t\t\t_clearValueVec4.push(clearValue as number, clearValue as number, clearValue as number, clearValue as number);\n\t\t\t} else {\n\t\t\t\t_clearValueVec4.push(...clearValue as number[]);\n\t\t\t\tfor (let j = _clearValueVec4.length; j < 4; j++) {\n\t\t\t\t\t_clearValueVec4.push(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clearValueVec4 = _clearValueVec4;\n\t\t}\n\t\treturn _clearValueVec4;\n\t}\n\n\t/**\n\t * Clear all data in canvas to GPUComposer.clearValue.\n\t */\n\tclear() {\n\t\tconst { verboseLogging, clearValueVec4 } = this;\n\t\tif (verboseLogging) console.log(`Clearing GPUComoser.`);\n\t\tconst program = this._setValueProgramForType(FLOAT);\n\t\tprogram.setUniform('u_value', clearValueVec4);\n\t\t// Write clear value to canvas.\n\t\tthis.step({\n\t\t\tprogram,\n\t\t});\n\t}\n\n\t/**\n\t * If this GPUComposer has been inited via GPUComposer.initWithThreeRenderer(), call undoThreeState() in render loop before performing any gpu-io step or draw functions.\n\t */\n\tundoThreeState() {\n\t\tconst { gl, _threeRenderer, isWebGL2 } = this;\n\t\tif (!_threeRenderer) {\n\t\t\tthrow new Error(`Can't call undoThreeState() on a GPUComposer that was not inited with GPUComposer.initWithThreeRenderer().`);\n\t\t}\n\t\t\n\t\t// Disable blend mode.\n\t\tgl.disable(gl.BLEND);\n\n\t\t// Unbind VAO for threejs compatibility.\n\t\tif (_threeRenderer) {\n\t\t\tif (isWebGL2) (gl as WebGL2RenderingContext).bindVertexArray(null);\n\t\t\telse {\n\t\t\t\tconst ext = getExtension(this, OES_VERTEX_ARRAY_OBJECT, true);\n\t\t\t\text.bindVertexArrayOES(null);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * If this GPUComposer has been inited via GPUComposer.initWithThreeRenderer(), call resetThreeState() in render loop after performing any gpu-io step or draw functions.\n\t */\n\tresetThreeState() {\n\t\tconst { gl, _threeRenderer } = this;\n\t\tif (!_threeRenderer) {\n\t\t\tthrow new Error(`Can't call resetThreeState() on a GPUComposer that was not inited with GPUComposer.initWithThreeRenderer().`);\n\t\t}\n\t\t\n\t\t// Reset viewport.\n\t\tconst viewport = _threeRenderer.getViewport(new ThreejsUtils.Vector4() as Vector4);\n\t\tgl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);\n\t\t// Unbind framebuffer (render to screen).\n\t\t// Reset threejs WebGL bindings and state, this also unbinds the framebuffer.\n\t\t_threeRenderer.resetState();\n\t}\n\n\t// TODO: params.callback is not generated in the docs.\n\t/**\n\t * Save the current state of the canvas to png.\n\t * @param params - PNG parameters.\n\t * @param params.filename - PNG filename (no extension).\n\t * @param params.dpi - PNG dpi (defaults to 72dpi).\n\t * @param params.callback - Optional callback when Blob is ready, default behavior saves the PNG using file-saver.\n\t*/\n\tsavePNG(params: {\n\t\tfilename?: string,\n\t\tdpi?: number,\n\t\tcallback?: (blob: Blob, filename: string) => void,\n\t} = {}) {\n\t\tconst validKeys = ['filename', 'dpi', 'callback'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer.savePNG(params)');\n\n\t\tconst { canvas } = this;\n\t\tconst filename = params.filename || 'output';\n\t\tconst callback = params.callback || saveAs; // Default to saving the image with file-saver.\n\t\t// TODO: need to adjust the canvas size to get the correct px ratio from toBlob().\n\t\t// const ratio = window.devicePixelRatio || 1;\n\t\tcanvas.toBlob((blob) => {\n\t\t\tif (!blob) {\n\t\t\t\tconsole.warn(`Problem saving PNG, unable to init blob from canvas.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (params.dpi) {\n\t\t\t\tchangeDpiBlob(blob, params.dpi).then((blob: Blob) => {\n\t\t\t\t\tcallback(blob, `${filename}.png`);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(blob, `${filename}.png`);\n\t\t\t}\n\t\t}, 'image/png');\n\t}\n\n\t/**\n\t * Call tick() from your render loop to measure the FPS of your application.\n\t * Internally, this does some low pass filtering to give consistent results.\n\t * @returns An Object containing the current fps of your application and the number of times tick() has been called.\n\t */\n\ttick(): { fps: number, numTicks: number} {\n\t\tthis._numTicks += 1;\n\t\tlet { _lastTickTime, _lastTickFPS } = this;\n\t\tconst currentTime = performance.now();\n\t\tthis._lastTickTime = currentTime;\n\t\tif (!_lastTickTime) {\n\t\t\treturn { fps: 0, numTicks: this._numTicks };\n\t\t}\n\t\tconst currentFPS = 1000 / (currentTime - _lastTickTime);\n\t\tif (!_lastTickFPS) _lastTickFPS = currentFPS;\n\t\t// Use a low pass filter to smooth out fps reading.\n\t\tconst factor = 0.9;\n\t\tconst fps =  Number.parseFloat((factor * _lastTickFPS + (1 - factor) * currentFPS).toFixed(1));\n\t\tthis._lastTickFPS = fps;\n\t\treturn {\n\t\t\tfps,\n\t\t\tnumTicks: this._numTicks,\n\t\t};\n\t}\n\n\t/**\n\t * Return the number of ticks of the simulation.\n\t * Use GPUComposer.tick() to increment this value on each animation cycle.\n\t */\n\tget numTicks() {\n\t\treturn this._numTicks;\n\t}\n\t\n\t/**\n\t * Deallocate GPUComposer instance and associated WebGL properties.\n\t */\n\tdispose() {\n\t\tconst { gl, verboseLogging } = this;\n\n\t\tif (verboseLogging) console.log(`Deallocating GPUComposer.`);\n\n\t\t// Delete buffers.\n\t\tif (this._quadPositionsBuffer) {\n\t\t\tgl.deleteBuffer(this._quadPositionsBuffer);\n\t\t\tdelete this._quadPositionsBuffer;\n\t\t}\n\t\tif (this._boundaryPositionsBuffer) {\n\t\t\tgl.deleteBuffer(this._boundaryPositionsBuffer);\n\t\t\tdelete this._boundaryPositionsBuffer;\n\t\t}\n\t\t(Object.keys(this._circlePositionsBuffer) as any as number[]).forEach(key => {\n\t\t\tgl.deleteBuffer(this._circlePositionsBuffer[key]);\n\t\t});\n\t\t// @ts-ignore\n\t\tdelete this._circlePositionsBuffer;\n\t\tdelete this._pointIndexArray;\n\t\tif (this._pointIndexBuffer) {\n\t\t\tgl.deleteBuffer(this._pointIndexBuffer);\n\t\t\tdelete this._pointIndexBuffer;\n\t\t}\n\t\tdelete this._vectorFieldIndexArray;\n\t\tif (this._vectorFieldIndexBuffer) {\n\t\t\tgl.deleteBuffer(this._vectorFieldIndexBuffer);\n\t\t\tdelete this._vectorFieldIndexBuffer;\n\t\t}\n\t\tif (this._indexedLinesIndexBuffer) {\n\t\t\tgl.deleteBuffer(this._indexedLinesIndexBuffer);\n\t\t\tdelete this._indexedLinesIndexBuffer;\n\t\t}\n\n\t\t// Delete vertex attribute locations.\n\t\tObject.keys(this._vertexAttributeLocations).forEach((key) => {\n\t\t\tdelete this._vertexAttributeLocations[key];\n\t\t});\n\t\t// @ts-ignore\n\t\tdelete this._vertexAttributeLocations;\n\t\t// @ts-ignore\n\t\tdelete this._enabledVertexAttributes;\n\n\t\t// Delete vertex shaders.\n\t\tObject.values(this._vertexShaders).forEach(({ compiledShaders })=> {\n\t\t\tObject.keys(compiledShaders).forEach(key => {\n\t\t\t\tgl.deleteShader(compiledShaders[key]);\n\t\t\t\tdelete compiledShaders[key];\n\t\t\t});\n\t\t});\n\t\t// @ts-ignore\n\t\tdelete this._vertexShaders;\n\t\t\n\t\t// Delete fragment shaders.\n\t\tObject.values(this._copyPrograms).forEach(program => {\n\t\t\tprogram.dispose();\n\t\t});\n\t\tObject.keys(this._copyPrograms).forEach(key => {\n\t\t\t// @ts-ignore\n\t\t\tdelete this._copyPrograms[key];\n\t\t});\n\t\t// @ts-ignore;\n\t\tdelete this._copyPrograms;\n\n\t\tObject.values(this._setValuePrograms).forEach(program => {\n\t\t\tprogram.dispose();\n\t\t});\n\t\tObject.keys(this._setValuePrograms).forEach(key => {\n\t\t\t// @ts-ignore\n\t\t\tdelete this._setValuePrograms[key];\n\t\t});\n\t\t// @ts-ignore;\n\t\tdelete this._setValuePrograms;\n\n\t\tthis._wrappedLineColorProgram?.dispose();\n\t\tdelete this._wrappedLineColorProgram;\n\n\t\t// @ts-ignore\n\t\tdelete this._threeRenderer;\n\t\t// @ts-ignore\n\t\tdelete this.gl;\n\t\t// @ts-ignore;\n\t\tdelete this.canvas;\n\t\t// GL context will be garbage collected by webgl.\n\t\t// @ts-ignore\n\t\tdelete this._errorCallback;\n\t\t// @ts-ignore\n\t\tdelete this._extensions;\n\n\t\t// Delete all other keys.\n\t\t// This is mostly for testing so we can be sure we've deallocated everything.\n\t\t// @ts-ignore;\n\t\tdelete this._errorState;\n\t\t// @ts-ignore;\n\t\tdelete this.verboseLogging;\n\t\t// @ts-ignore;\n\t\tdelete this._numTicks;\n\t\t// @ts-ignore;\n\t\tdelete this.isWebGL2;\n\t\t// @ts-ignore;\n\t\tdelete this.glslVersion;\n\t\t// @ts-ignore;\n\t\tdelete this.intPrecision;\n\t\t// @ts-ignore;\n\t\tdelete this.floatPrecision;\n\t\t// @ts-ignore;\n\t\tdelete this._width;\n\t\t// @ts-ignore;\n\t\tdelete this._height;\n\t\t// @ts-ignore\n\t\tdelete this._clearValue;\n\t\tdelete this._clearValueVec4;\n\t}\n}","import { isObject } from '@amandaghassaei/type-checks';\nimport { isTypedArray } from '@petamoriken/float16';\nimport { checkRequiredKeys, checkValidKeys } from './checks';\nimport { getExtension, OES_ELEMENT_INDEX_UINT } from './extensions';\nimport type { GPUComposer } from './GPUComposer';\n\nexport class GPUIndexBuffer {\n\t// Keep a reference to GPUComposer.\n\tprivate readonly _composer: GPUComposer;\n\n\t/**\n\t * GL buffer.\n\t */\n\treadonly buffer: WebGLBuffer;\n\t/**\n\t * GL type.\n\t */\n\treadonly glType: number;\n\t/**\n\t * Index buffer count.\n\t */\n\treadonly count: number;\n\t\n\t/**\n\t * Init a GPUIndexBuffer to use with GPUComposer.drawLayerAsMesh().\n\t * @param composer - The current GPUComposer instance.\n\t * @param params - GPUIndexBuffer parameters.\n\t * @param params.indices - A 1D array containing indexed geometry.  For a mesh, this would be an array of triangle indices.\n\t * @param params.name - Name of GPUIndexBuffer, used for error logging.\n\t * @returns \n\t */\n\tconstructor(\n\t\tcomposer: GPUComposer,\n\t\tparams: {\n\t\t\tindices: number[] | Uint8Array | Uint16Array | Uint32Array,\n\t\t\tname?: string,\n\t\t},\n\t) {\n\t\tthis._composer = composer;\n\n\t\tif (!params) {\n\t\t\tthrow new Error('Error initing GPUIndexBuffer: must pass params to GPUIndexBuffer(composer, params).');\n\t\t}\n\t\tif (!isObject(params)) {\n\t\t\tthrow new Error(`Error initing GPUIndexBuffer: must pass valid params object to GPUIndexBuffer(composer, params), got ${JSON.stringify(params)}.`);\n\t\t}\n\t\t// Check params.\n\t\tconst validKeys = ['indices', 'name'];\n\t\tconst requiredKeys = ['indices'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUIndexBuffer(composer, params)', params.name);\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUIndexBuffer(composer, params)', params.name);\n\n\t\tlet { indices } = params;\n\n\t\tconst { gl, isWebGL2 } = composer;\n\t\t\n\t\tconst indexBuffer = gl.createBuffer()!;\n\t\t// Make index buffer the current ELEMENT_ARRAY_BUFFER.\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n\n\t\t// Cast indices to correct type.\n\t\tif (!isTypedArray(indices)) {\n\t\t\tindices = new Uint32Array(indices);\n\t\t}\n\t\tlet glType;\n\t\tswitch(indices.constructor) {\n\t\t\tcase Uint8Array:\n\t\t\t\tglType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase Uint16Array:\n\t\t\t\tglType = gl.UNSIGNED_SHORT;\n\t\t\t\tbreak;\n\t\t\tcase Uint32Array:\n\t\t\t\tif (!isWebGL2) {\n\t\t\t\t\tconst ext = getExtension(composer, OES_ELEMENT_INDEX_UINT, true);\n\t\t\t\t\tif (!ext) {\n\t\t\t\t\t\t// Fall back to using gl.UNSIGNED_SHORT.\n\t\t\t\t\t\tglType = gl.UNSIGNED_SHORT;\n\t\t\t\t\t\tindices = Uint16Array.from(indices);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tglType = gl.UNSIGNED_INT;\n\t\t\t\tbreak;\n\t\t}\n\t\t// Fill the current element array buffer with data.\n\t\tgl.bufferData(\n\t\t\tgl.ELEMENT_ARRAY_BUFFER,\n\t\t\tindices,\n\t\t\tgl.STATIC_DRAW\n\t\t);\n\n\t\tthis.buffer = indexBuffer;\n\t\tthis.glType = glType as number;\n\t\tthis.count = indices.length;\n\t}\n\n\t/**\n\t * Deallocate GPUIndexBuffer instance and associated WebGL properties.\n\t */\n\tdispose() {\n\t\tconst { _composer, buffer } = this;\n\t\t_composer.gl.deleteBuffer(buffer);\n\n\t\t// Delete all references.\n\t\t// @ts-ignore\n\t\tdelete this._composer;\n\t\t// @ts-ignore\n\t\tdelete this.buffer;\n\n\t\t// Delete these too (for easier testing of deallocations).\n\t\t// @ts-ignore\n\t\tdelete this.glType;\n\t\t// @ts-ignore\n\t\tdelete this.count;\n\t}\n}","import { getFloat16 } from '@petamoriken/float16';\nimport type { Texture } from 'three';\nimport {\n\tisArray,\n\tisFiniteNumber,\n\tisObject,\n\tisPositiveInteger,\n\tisString,\n} from '@amandaghassaei/type-checks';\n// @ts-ignore\nimport { changeDpiBlob } from 'changedpi';\nimport { saveAs } from 'file-saver';\nimport type { GPUComposer } from './GPUComposer';\nimport {\n\tcheckRequiredKeys,\n\tcheckValidKeys,\n\tisValidClearValue,\n\tisValidDataType,\n\tisValidFilter,\n\tisValidImageFormat,\n\tisValidImageType,\n\tisValidWrap,\n} from './checks';\nimport {\n\tHALF_FLOAT,\n\tFLOAT,\n\tUNSIGNED_BYTE,\n\tBYTE,\n\tUNSIGNED_SHORT,\n\tSHORT,\n\tUNSIGNED_INT,\n\tINT,\n\tNEAREST,\n\tLINEAR,\n\tCLAMP_TO_EDGE,\n\tGPULayerArray,\n\tGPULayerFilter,\n\tGPULayerNumComponents,\n\tGPULayerType,\n\tGPULayerWrap,\n\tvalidFilters,\n\tvalidWraps,\n\tvalidDataTypes,\n\tGPULayerState,\n\tImageFormat,\n\tImageType,\n\tvalidImageFormats,\n\tvalidImageTypes,\n } from './constants';\nimport {\n\treadPixelsAsync,\n\treadyToRead,\n} from './utils';\nimport { disposeFramebuffers, bindFrameBuffer } from './framebuffers';\nimport { arrayConstructorForType } from './conversions';\n\nexport class GPULayer {\n\t// Keep a reference to GPUComposer.\n\tprivate readonly _composer: GPUComposer;\n\n\t/**\n\t * Name of GPULayer, used for error logging.\n\t */\n\treadonly name: string;\n\t/**\n\t * Data type represented by GPULayer.\n\t */\n\treadonly type: GPULayerType; // Input type passed in during setup.\n\t/**\n\t * Number of RGBA elements represented by each pixel in the GPULayer (1-4).\n\t */\n\treadonly numComponents: GPULayerNumComponents;\n\t/**\n\t * Interpolation filter for GPULayer, defaults to LINEAR for 2D FLOAT/HALF_FLOAT GPULayers, otherwise defaults to NEAREST.\n\t */\n\treadonly filter: GPULayerFilter;\n\t/**\n\t * Horizontal wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t */\n\treadonly wrapX: GPULayerWrap;\n\t/**\n\t * Vertical wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t */\n\treadonly wrapY: GPULayerWrap;\n\n\t// Value to set when clear() is called, defaults to zero.\n\t// Access with GPULayer.clearValue.\n\tprivate _clearValue: number | number[] = 0;\n\tprivate _clearValueVec4? : number[];\n\n\t// Each GPULayer may contain a number of buffers to store different instances of the state.\n\t// e.g [currentState, previousState]\n\tprivate _bufferIndex = 0;\n\treadonly numBuffers;\n\tprivate readonly _buffers: WebGLTexture[] = [];\n\n\t// Texture sizes.\n\tprivate _length?: number; // This is only used for 1D data layers, access with GPULayer.length.\n\tprivate _width: number; // Access with GPULayer.width.\n\tprivate _height: number; // Access with GPULayer.height.\n\n\t// GPULayer settings.\n\t// Due to variable browser support of WebGL features, \"internal\" variables may be different\n\t// from the parameter originally passed in.  These variables are set so that they match the original\n\t// parameter as best as possible, but fragment shader polyfills may be required.\n\t// All \"gl\" variables are used to initialize internal WebGLTexture.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n\t/**\n\t * @private\n\t */\n\treadonly _glInternalFormat: number;\n\t/**\n\t * @private\n\t */\n\treadonly _glFormat: number;\n\n\t/**\n\t * GPULayer._internalType corresponds to GPULayer.glType, but may be different from GPULayer.type.\n\t * @private\n\t */\n\treadonly _internalType: GPULayerType;\n\t/**\n\t * @private\n\t */\n\treadonly _glType: number;\n\n\t/**\n\t * Internally, GPULayer._glNumChannels may represent a larger number of channels than GPULayer.numComponents.\n\t * For example, writable RGB textures are not supported in WebGL2, must use RGBA instead.\n\t * @private\n\t */\n\treadonly _glNumChannels: number;\n\n\t/**\n\t * GPULayer._internalFilter corresponds to GPULayer.glFilter, may be different from GPULayer.filter.\n\t * @private\n\t */\n\treadonly _internalFilter: GPULayerFilter;\n\t/**\n\t * @private\n\t */\n\treadonly _glFilter: number;\n\n\t/**\n\t * GPULayer._internalWrapX corresponds to GPULayer.glWrapX, but may be different from GPULayer.wrapX.\n\t * @private\n\t */\n\treadonly _internalWrapX: GPULayerWrap;\n\t/**\n\t * @private\n\t */\n\treadonly _glWrapS: number;\n\n\t/**\n\t * GPULayer._internalWrapY corresponds to GPULayer.glWrapY, but may be different from GPULayer.wrapY.\n\t * @private\n\t */\n\treadonly _internalWrapY: GPULayerWrap;\n\t/**\n\t * @private\n\t */\n\treadonly _glWrapT: number;\n\t\n\t// Optimization so that \"copying\" can happen without draw calls by simply swapping WebGL textures between GPULayers.\n\t// This functionality is not currently active right now, but will be added back in later.\n\tprivate _textureOverrides?: (WebGLTexture | undefined)[];\n\n\t// Optimizations so we don't allocate many large arrays if getValues()is called multiple times.\n\tprivate _values?: GPULayerArray;\n\tprivate _valuesRaw?: Float32Array | Uint16Array | Uint32Array | Int32Array;\n\tprivate _valuesBufferView?: DataView;\n\n\t/**\n\t * Create a GPULayer from an image url.\n\t * @param composer - The current GPUComposer instance.\n\t * @param params  - GPULayer parameters.\n\t * @param params.name - Name of GPULayer, used for error logging.\n\t * @param params.url - URL of the image source.\n\t * @param params.type - Data type represented by GPULayer.\n\t * @param params.format - Image format, either RGB or RGBA.\n\t * @param params.filter - Interpolation filter for GPULayer, defaults to LINEAR for FLOAT/HALF_FLOAT Images, otherwise defaults to NEAREST.\n\t * @param params.wrapX - Horizontal wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t * @param params.wrapY - Vertical wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t * @param params.clearValue - Value to write to GPULayer when GPULayer.clear() is called.\n\t */\n\tstatic async initFromImageURL(composer: GPUComposer,\n\t\tparams: {\n\t\t\tname: string,\n\t\t\turl: string,\n\t\t\ttype?: ImageType,\n\t\t\tformat?: ImageFormat,\n\t\t\tfilter?: GPULayerFilter,\n\t\t\twrapX?: GPULayerWrap,\n\t\t\twrapY?: GPULayerWrap,\n\t\t\tclearValue?: number | number[],\n\t\t},\n\t) {\n\t\treturn new Promise<GPULayer>((resolve, reject) => {\n\t\t\tif (!params) {\n\t\t\t\tthrow new Error('Error initing GPULayer: must pass params to GPULayer.initFromImageURL(composer, params).');\n\t\t\t}\n\t\t\tif (!isObject(params)) {\n\t\t\t\tthrow new Error(`Error initing GPULayer: must pass valid params object to GPULayer.initFromImageURL(composer, params), got ${JSON.stringify(params)}.`);\n\t\t\t}\n\t\t\t// Check params.\n\t\t\tconst validKeys = ['name', 'url', 'filter', 'wrapX', 'wrapY', 'format', 'type', 'clearValue'];\n\t\t\tconst requiredKeys = ['name', 'url'];\n\t\t\tconst keys = Object.keys(params);\n\t\t\tcheckValidKeys(keys, validKeys, 'GPULayer.initFromImageURL(composer, params)', params.name);\n\t\t\tcheckRequiredKeys(keys, requiredKeys, 'GPULayer.initFromImageURL(composer, params)', params.name);\n\n\t\t\tconst { url, name, filter, wrapX, wrapY, type, format } = params;\n\t\t\tif (!isString(url)) {\n\t\t\t\tthrow new Error(`Expected GPULayer.initFromImageURL params to have url of type string, got ${url} of type ${typeof url}.`)\n\t\t\t}\n\t\t\tif (type && !isValidImageType(type)) {\n\t\t\t\tthrow new Error(`Invalid type: \"${type}\" for GPULayer.initFromImageURL \"${name}\", must be one of ${JSON.stringify(validImageTypes)}.`)\n\t\t\t}\n\t\t\tif (format && !isValidImageFormat(format)) {\n\t\t\t\tthrow new Error(`Invalid format: \"${format}\" for GPULayer.initFromImageURL \"${name}\", must be one of ${JSON.stringify(validImageFormats)}.`)\n\t\t\t}\n\n\t\t\t// Init a layer to return, we will fill it when image has loaded.\n\t\t\tconst layer = new GPULayer(composer, {\n\t\t\t\tname,\n\t\t\t\ttype: type || FLOAT,\n\t\t\t\tnumComponents: format ? format.length as GPULayerNumComponents : 4,\n\t\t\t\tdimensions: [1, 1], // Init as 1 px to start.\n\t\t\t\tfilter,\n\t\t\t\twrapX,\n\t\t\t\twrapY,\n\t\t\t\tnumBuffers: 1,\n\t\t\t\tclearValue: params.clearValue,\n\t\t\t});\n\n\t\t\t// Load image.\n\t\t\tconst image = new Image();\n\t\t\timage.onload = () => {\n\t\t\t\tlayer.resize([image.width, image.height], image);\n\t\t\t\t// Callback when texture has loaded.\n\t\t\t\tresolve(layer);\n\t\t\t};\n\t\t\timage.onerror = (e) => {\n\t\t\t\treject(new Error(`Error loading image \"${name}\": ${e}`));\n\t\t\t}\n\t\t\timage.src = url;\n\t\t});\n\t}\n\n\t/**\n\t * Create a GPULayer.\n\t * @param composer - The current GPUComposer instance.\n\t * @param params - GPULayer parameters.\n\t * @param params.name - Name of GPULayer, used for error logging.\n\t * @param params.type - Data type represented by GPULayer.\n\t * @param params.numComponents - Number of RGBA elements represented by each pixel in the GPULayer (1-4).\n\t * @param params.dimensions - Dimensions of 1D or 2D GPULayer.\n\t * @param params.filter - Interpolation filter for GPULayer, defaults to LINEAR for 2D FLOAT/HALF_FLOAT GPULayers, otherwise defaults to NEAREST.\n\t * @param params.wrapX - Horizontal wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t * @param params.wrapY - Vertical wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t * @param params.numBuffers - How may buffers to allocate, defaults to 1.  If you intend to use the current state of this GPULayer as an input to generate a new state, you will need at least 2 buffers.\n\t * @param params.clearValue - Value to write to GPULayer when GPULayer.clear() is called.\n\t * @param params.array - Array to initialize GPULayer.\n\t */\n\tconstructor(\n\t\tcomposer: GPUComposer,\n\t\tparams: {\n\t\t\tname: string,\n\t\t\ttype: GPULayerType,\n\t\t\tnumComponents: GPULayerNumComponents,\n\t\t\tdimensions: number | number[],\n\t\t\tarray?: GPULayerArray | number[],\n\t\t\tfilter?: GPULayerFilter,\n\t\t\twrapX?: GPULayerWrap,\n\t\t\twrapY?: GPULayerWrap,\n\t\t\tnumBuffers?: number,\n\t\t\tclearValue?: number | number[],\n\t\t},\n\t) {\n\t\t// Check constructor parameters.\n\t\tconst { name } = (params || {});\n\t\tif (!composer) {\n\t\t\tthrow new Error(`Error initing GPULayer \"${name}\": must pass GPUComposer instance to GPULayer(composer, params).`);\n\t\t}\n\t\tif (!params) {\n\t\t\tthrow new Error('Error initing GPULayer: must pass params to GPULayer(composer, params).');\n\t\t}\n\t\tif (!isObject(params)) {\n\t\t\tthrow new Error(`Error initing GPULayer: must pass valid params object to GPULayer(composer, params), got ${JSON.stringify(params)}.`);\n\t\t}\n\t\t// Check params keys.\n\t\tconst validKeys = ['name', 'type', 'numComponents', 'dimensions', 'filter', 'wrapX', 'wrapY', 'numBuffers', 'clearValue', 'array'];\n\t\tconst requiredKeys = ['name', 'type', 'numComponents', 'dimensions'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPULayer(composer, params)', params.name);\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPULayer(composer, params)', params.name);\n\n\t\tconst { dimensions, type, numComponents } = params;\n\t\tconst { gl } = composer;\n\n\t\t// Save params.\n\t\tthis._composer = composer;\n\t\tthis.name = name;\n\n\t\t// numComponents must be between 1 and 4.\n\t\tif (!isPositiveInteger(numComponents) || numComponents > 4) {\n\t\t\tthrow new Error(`Invalid numComponents: ${JSON.stringify(numComponents)} for GPULayer \"${name}\", must be number in range [1-4].`);\n\t\t}\n\t\tthis.numComponents = numComponents;\n\n\t\t// Set dimensions, may be 1D or 2D.\n\t\tconst { length, width, height } = GPULayer.calcGPULayerSize(dimensions, name, composer.verboseLogging);\n\t\t// We already type checked length, width, and height in calcGPULayerSize.\n\t\tthis._length = length;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\t// Set filtering - if we are processing a 1D array, default to NEAREST filtering.\n\t\t// Else default to LINEAR (interpolation) filtering for float types and NEAREST for integer types.\n\t\tconst defaultFilter = (length === undefined && (type === FLOAT || type == HALF_FLOAT)) ? LINEAR : NEAREST;\n\t\tconst filter = params.filter !== undefined ? params.filter : defaultFilter;\n\t\tif (!isValidFilter(filter)) {\n\t\t\tthrow new Error(`Invalid filter: ${JSON.stringify(filter)} for GPULayer \"${name}\", must be one of ${JSON.stringify(validFilters)}.`);\n\t\t}\n\t\t// Don't allow LINEAR filtering on integer types, it is not supported.\n\t\tif (filter === LINEAR && !(type === FLOAT || type == HALF_FLOAT)) {\n\t\t\tthrow new Error(`LINEAR filtering is not supported on integer types, please use NEAREST filtering for GPULayer \"${name}\" with type: ${type}.`);\n\t\t}\n\t\tthis.filter = filter;\n\n\t\t// Get wrap types, default to clamp to edge.\n\t\tconst wrapX = params.wrapX !== undefined ? params.wrapX : CLAMP_TO_EDGE;\n\t\tif (!isValidWrap(wrapX)) {\n\t\t\tthrow new Error(`Invalid wrapX: ${JSON.stringify(wrapX)} for GPULayer \"${name}\", must be one of ${JSON.stringify(validWraps)}.`);\n\t\t}\n\t\tthis.wrapX = wrapX;\n\t\tconst wrapY = params.wrapY !== undefined ? params.wrapY : CLAMP_TO_EDGE;\n\t\tif (!isValidWrap(wrapY)) {\n\t\t\tthrow new Error(`Invalid wrapY: ${JSON.stringify(wrapY)} for GPULayer \"${name}\", must be one of ${JSON.stringify(validWraps)}.`);\n\t\t}\n\t\tthis.wrapY = wrapY;\n\n\t\t// Set data type.\n\t\tif (!isValidDataType(type)) {\n\t\t\tthrow new Error(`Invalid type: ${JSON.stringify(type)} for GPULayer \"${name}\", must be one of ${JSON.stringify(validDataTypes)}.`);\n\t\t}\n\t\tthis.type = type;\n\t\tconst internalType = GPULayer.getGPULayerInternalType({\n\t\t\tcomposer,\n\t\t\ttype,\n\t\t\tname,\n\t\t});\n\t\tthis._internalType = internalType;\n\t\t// Set gl texture parameters.\n\t\tconst {\n\t\t\tglFormat,\n\t\t\tglInternalFormat,\n\t\t\tglType,\n\t\t\tglNumChannels,\n\t\t} = GPULayer.getGLTextureParameters({\n\t\t\tcomposer,\n\t\t\tname,\n\t\t\tnumComponents,\n\t\t\tinternalType,\n\t\t});\n\t\tthis._glInternalFormat = glInternalFormat;\n\t\tthis._glFormat = glFormat;\n\t\tthis._glType = glType;\n\t\tthis._glNumChannels = glNumChannels;\n\n\t\t// Set internal filtering/wrap types.\n\t\t// Make sure that we set filter BEFORE setting wrap.\n\t\tconst internalFilter = GPULayer.getGPULayerInternalFilter({ composer, filter, wrapX, wrapY, internalType, name });\n\t\tthis._internalFilter = internalFilter;\n\t\tthis._glFilter = gl[internalFilter];\n\t\tthis._internalWrapX = GPULayer.getGPULayerInternalWrap({ composer, wrap: wrapX, internalFilter, internalType, name });\n\t\tthis._glWrapS = gl[this._internalWrapX];\n\t\tthis._internalWrapY = GPULayer.getGPULayerInternalWrap({ composer, wrap: wrapY, internalFilter, internalType, name });\n\t\tthis._glWrapT = gl[this._internalWrapY];\n\n\t\t// Num buffers is the number of states to store for this data.\n\t\tconst numBuffers = params.numBuffers !== undefined ? params.numBuffers : 1;\n\t\tif (!isPositiveInteger(numBuffers)) {\n\t\t\tthrow new Error(`Invalid numBuffers: ${JSON.stringify(numBuffers)} for GPULayer \"${name}\", must be positive integer.`);\n\t\t}\n\t\tthis.numBuffers = numBuffers;\n\n\t\t// Wait until after type and numComponents has been set to set clearValue.\n\t\tif (params.clearValue !== undefined) {\n\t\t\tthis.clearValue = params.clearValue; // Setter can only be called after this.numComponents has been set.\n\t\t}\n\n\t\tthis._initBuffers(params.array);\n\t}\n\n\t/**\n\t * The width of the GPULayer array.\n\t */\n\t get width() {\n\t\treturn this._width;\n\t}\n\n\t/**\n\t * The height of the GPULayer array.\n\t */\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\t/**\n\t * The length of the GPULayer array (only available to 1D GPULayers).\n\t */\n\tget length() {\n\t\tif (!this._length) {\n\t\t\tthrow new Error(`Cannot access length on 2D GPULayer \"${this.name}\".`);\n\t\t}\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Returns whether the GPULayer was inited as a 1D array (rather than 2D).\n\t * @returns - true if GPULayer is 1D, else false.\n\t */\n\tis1D() {\n\t\treturn this._length !== undefined;\n\t}\n\n\t/**\n\t * Returns whether the GPULayer was inited as a 2D array (rather than 1D).\n\t * @returns - true if GPULayer is 2D, else false.\n\t */\n\tis2D() {\n\t\treturn !this.is1D();\n\t}\n\n\t/**\n\t * Test whether the current buffer index has override enabled.\n\t * @private\n\t */\n\t_usingTextureOverrideForCurrentBuffer() {\n\t\treturn !!(this._textureOverrides && this._textureOverrides[this.bufferIndex]);\n\t}\n\n\t/**\n\t * Copy contents of current state to another GPULayer.\n\t * TODO: Still testing this.\n\t * @private\n\t */\n\tcopyCurrentStateToGPULayer(layer: GPULayer) {\n\t\tconst { _composer } = this;\n\t\tif (this === layer) throw new Error(`Can't call GPULayer.copyCurrentStateToGPULayer() on self.`);\n\t\tconst copyProgram = _composer._copyProgramForType(this._internalType);\n\t\t_composer.step({\n\t\t\tprogram: copyProgram,\n\t\t\tinput: this,\n\t\t\toutput: layer,\n\t\t});\n\t}\n\t// saveCurrentStateToGPULayer(layer: GPULayer) {\n\t// \t// A method for saving a copy of the current state without a draw call.\n\t// \t// Draw calls are expensive, this optimization helps.\n\t// \tif (this.numBuffers < 2) {\n\t// \t\tthrow new Error(`Can't call GPULayer.saveCurrentStateToGPULayer on GPULayer \"${this.name}\" with less than 2 buffers.`);\n\t// \t}\n\t// \t// Check that texture params are the same.\n\t// \tif (layer.glWrapS !== this.glWrapS || layer.glWrapT !== this.glWrapT ||\n\t// \t\tlayer.wrapS !== this.wrapS || layer.wrapT !== this.wrapT ||\n\t// \t\tlayer.width !== this.width || layer.height !== this.height ||\n\t// \t\tlayer.glFilter !== this.glFilter || layer.filter !== this.filter ||\n\t// \t\tlayer.glNumChannels !== this.glNumChannels || layer.numComponents !== this.numComponents ||\n\t// \t\tlayer.glType !== this.glType || layer.type !== this.type ||\n\t// \t\tlayer.glFormat !== this.glFormat || layer.glInternalFormat !== this.glInternalFormat) {\n\t// \t\t\tthrow new Error(`Incompatible texture params between GPULayers \"${layer.name}\" and \"${this.name}\".`);\n\t// \t}\n\n\t// \t// If we have not already inited overrides array, do so now.\n\t// \tif (!this.textureOverrides) {\n\t// \t\tthis.textureOverrides = [];\n\t// \t\tfor (let i = 0; i < this.numBuffers; i++) {\n\t// \t\t\tthis.textureOverrides.push(undefined);\n\t// \t\t}\n\t// \t}\n\n\t// \t// Check if we already have an override in place.\n\t// \tif (this.textureOverrides[this.bufferIndex]) {\n\t// \t\tthrow new Error(`Can't call GPULayer.saveCurrentStateToGPULayer on GPULayer \"${this.name}\", this GPULayer has not written new state since last call to GPULayer.saveCurrentStateToGPULayer.`);\n\t// \t}\n\t// \tconst { currentState } = this;\n\t// \tthis.textureOverrides[this.bufferIndex] = currentState;\n\t// \t// Swap textures.\n\t// \tthis.buffers[this.bufferIndex].texture = layer.currentState;\n\t// \tlayer._setCurrentStateTexture(currentState);\n\n\t// \t// Bind swapped texture to framebuffer.\n\t// \tconst { gl } = this.composer;\n\t// \tconst { framebuffer, texture } = this.buffers[this.bufferIndex];\n\t// \tif (!framebuffer) throw new Error(`No framebuffer for writable GPULayer \"${this.name}\".`);\n\t// \tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t// \t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/framebufferTexture2D\n\t// \tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\t// \t// Unbind.\n\t// \tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t// }\n\n\t// // This is used internally.\n\t// _setCurrentStateTexture(texture: WebGLTexture) {\n\t// \tthis.buffers[this.bufferIndex].texture = texture;\n\t// }\n\n\t/**\t\n\t * Init GLTexture/GLFramebuffer pairs for reading/writing GPULayer data.\n\t * @private\n\t */\n\tprivate _initBuffers(\n\t\tarrayOrImage?: GPULayerArray | number[] | HTMLImageElement,\n\t) {\n\t\tconst {\n\t\t\tname,\n\t\t\tnumBuffers,\n\t\t\t_composer,\n\t\t\t_glInternalFormat,\n\t\t\t_glFormat,\n\t\t\t_glType,\n\t\t\t_glFilter,\n\t\t\t_glWrapS,\n\t\t\t_glWrapT,\n\t\t\twidth,\n\t\t\theight,\n\t\t} = this;\n\t\tconst { gl, _errorCallback } = _composer;\n\n\t\tlet validatedArrayOrImage: GPULayerArray | HTMLImageElement | null = null;\n\t\tif (isArray(arrayOrImage)) validatedArrayOrImage = GPULayer.validateGPULayerArray(arrayOrImage as GPULayerArray | number[], this);\n\t\telse if (arrayOrImage?.constructor === HTMLImageElement) validatedArrayOrImage = arrayOrImage;\n\t\t// Init a texture for each buffer.\n\t\tfor (let i = 0; i < numBuffers; i++) {\n\t\t\tconst texture = gl.createTexture();\n\t\t\tif (!texture) {\n\t\t\t\t_errorCallback(`Could not init texture for GPULayer \"${name}\": ${gl.getError()}.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, _glWrapS);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, _glWrapT);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, _glFilter);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, _glFilter);\n\n\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, _glInternalFormat, width, height, 0, _glFormat, _glType, validatedArrayOrImage as any as ArrayBufferView | null);\n\t\t\t\n\t\t\t// Save this buffer to the list.\n\t\t\tthis._buffers.push(texture);\n\t\t}\n\t\t// Unbind.\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t}\n\t\n\t/**\n\t * Get buffer index of the current state.\n\t */\n\tget bufferIndex() {\n\t\treturn this._bufferIndex;\n\t}\n\n\t/**\n\t * Increment buffer index by 1.\n\t */\n\tincrementBufferIndex() {\n\t\tconst { numBuffers } = this;\n\t\tif (numBuffers === 1) return;\n\t\t// Increment bufferIndex.\n\t\tthis._bufferIndex = (this.bufferIndex + 1) % numBuffers;\n\t}\n\n\t/**\n\t * Decrement buffer index by 1.\n\t */\n\t decrementBufferIndex() {\n\t\tconst { numBuffers } = this;\n\t\tif (numBuffers === 1) return;\n\t\t// Decrement bufferIndex.\n\t\tthis._bufferIndex = (this.bufferIndex - 1 + numBuffers) % numBuffers;\n\t}\n\n\t/**\n\t * Get the current state as a GPULayerState object.\n\t */\n\tget currentState() {\n\t\treturn this.getStateAtIndex(this.bufferIndex);\n\t}\n\n\t/**\n\t * Get the current state as a WebGLTexture.\n\t * Used internally.\n\t * @private\n\t */\n\tget _currentTexture() {\n\t\tconst { _buffers, _bufferIndex, _textureOverrides } = this;\n\t\tif (_textureOverrides && _textureOverrides[_bufferIndex]) return _textureOverrides[_bufferIndex]!;\n\t\treturn _buffers[_bufferIndex];\n\t}\n\n\t/**\n\t * Get the previous state as a GPULayerState object (only available for GPULayers with numBuffers > 1).\n\t */\n\tget lastState() {\n\t\tif (this.numBuffers === 1) {\n\t\t\tthrow new Error(`Cannot access lastState on GPULayer \"${this.name}\" with only one buffer.`);\n\t\t}\n\t\treturn this.getStateAtIndex((this.bufferIndex - 1 + this.numBuffers) % this.numBuffers);\n\t}\n\n\t/**\n\t * Get the state at a specified index as a GPULayerState object.\n\t */\n\tgetStateAtIndex(index: number): GPULayerState {\n\t\tconst { numBuffers, _textureOverrides, _buffers } = this;\n\t\tif (index < 0 && index > -numBuffers) {\n\t\t\tindex += numBuffers; // Slightly negative numbers are ok.\n\t\t}\n\t\tif (index < 0 || index >= numBuffers) {\n\t\t\t// We will allow this number to overflow with warning - likely user error.\n\t\t\tconsole.warn(`Out of range buffer index: ${index} for GPULayer \"${this.name}\" with $.numBuffers} buffer${numBuffers > 1 ? 's' : ''}.  Was this intentional?`);\n\t\t\tif (index < 0) {\n\t\t\t\tindex += numBuffers * Math.ceil(Math.abs(index) / numBuffers);\n\t\t\t} else {\n\t\t\t\tindex = index % numBuffers;\n\t\t\t}\n\t\t}\n\t\tlet texture = _buffers[index];\n\t\tif (_textureOverrides && _textureOverrides[index]) texture = _textureOverrides[index]!;\n\t\treturn {\n\t\t\ttexture,\n\t\t\tlayer: this,\n\t\t};\n\t}\n\n\t/**\n\t * Increments the buffer index (if needed).\n\t * @private\n\t */\n\t_prepareForWrite(\n\t\tincrementBufferIndex: boolean,\n\t) {\n\t\tif (incrementBufferIndex) {\n\t\t\tthis.incrementBufferIndex();\n\t\t}\n\n\t\t// We are going to do a data write, if we have overrides enabled, we can remove them.\n\t\tif (this._textureOverrides) {\n\t\t\tthis._textureOverrides[this.bufferIndex] = undefined;\n\t\t}\n\t}\n\n\tsetFromArray(array: GPULayerArray | number[]) {\n\t\tconst {\n\t\t\t_composer,\n\t\t\t_glInternalFormat,\n\t\t\t_glFormat,\n\t\t\t_glType,\n\t\t\twidth,\n\t\t\theight,\n\t\t\t_currentTexture,\n\t\t} = this;\n\t\tconst { gl } = _composer;\n\t\tconst validatedArray = GPULayer.validateGPULayerArray(array, this);\n\t\tgl.bindTexture(gl.TEXTURE_2D, _currentTexture);\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, _glInternalFormat, width, height, 0, _glFormat, _glType, validatedArray);\n\t\t// Unbind texture.\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t}\n\n\t// setFromImage(image: HTMLImageElement) {\n\t// \tconst { name, _composer, width, height, _currentTexture, _glInternalFormat, _glFormat, _glType, numComponents, type } = this;\n\t// \tconst { gl } = _composer;\n\t// \t// Check compatibility.\n\t// \tif (!isValidImageType(type)) {\n\t// \t\tthrow new Error(`GPULayer has invalid type ${type} for setFromImage(), valid types are: ${JSON.stringify(validImageTypes)}.`);\n\t// \t}\n\t// \tif (numComponents < 3) {\n\t// \t\tthrow new Error(`GPULayer has invalid numComponents ${numComponents} for setFromImage(), must have either 3 (RGB) or 4 (RGBA) components.`);\n\t// \t}\n\t// \tif (image.width !== width || image.height !== height) {\n\t// \t\tthrow new Error(`Invalid image dimensions [${image.width}, ${image.height}] for GPULayer \"${name}\" with dimensions [${width}, ${height}].  Call GPULayer.resize(width, height, image) instead.`);\n\t// \t}\n\t// \tgl.bindTexture(gl.TEXTURE_2D, _currentTexture);\n\t// \tgl.texImage2D(gl.TEXTURE_2D, 0, _glInternalFormat, width, height, 0, _glFormat, _glType, image as any);\n\t// \t// Unbind texture.\n\t// \tgl.bindTexture(gl.TEXTURE_2D, null);\n\t// }\n\n\tresize(\n\t\tdimensions: number | number[],\n\t\tarrayOrImage?: HTMLImageElement | GPULayerArray | number[],\n\t) {\n\t\tconst { name, _composer } = this;\n\t\tconst { verboseLogging } = _composer;\n\t\tif (verboseLogging) console.log(`Resizing GPULayer \"${name}\" to ${JSON.stringify(dimensions)}.`);\n\t\tconst { length, width, height } = GPULayer.calcGPULayerSize(dimensions, name, verboseLogging);\n\t\tthis._length = length;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._destroyBuffers();\n\t\tthis._initBuffers(arrayOrImage);\n\t}\n\n\t/**\n\t * Set the clearValue of the GPULayer, which is applied during GPULayer.clear().\n\t */\n\tset clearValue(clearValue: number | number[]) {\n\t\tconst { numComponents, type } = this;\n\t\tif (!isValidClearValue(clearValue, numComponents, type)) {\n\t\t\tthrow new Error(`Invalid clearValue: ${JSON.stringify(clearValue)} for GPULayer \"${this.name}\", expected ${type} or array of ${type} of length ${numComponents}.`);\n\t\t}\n\t\t// Make deep copy if needed.\n\t\tthis._clearValue = isArray(clearValue) ? (clearValue as number[]).slice() : clearValue;\n\t\tthis._clearValueVec4 = undefined;\n\t}\n\n\t/**\n\t * Get the clearValue of the GPULayer.\n\t */\n\tget clearValue() {\n\t\treturn this._clearValue;\n\t}\n\n\t/**\n\t * Get the clearValue of the GPULayer as a vec4, pad with zeros as needed.\n\t */\n\tprivate get clearValueVec4() {\n\t\tlet { _clearValueVec4 } = this;\n\t\tif (!_clearValueVec4) {\n\t\t\tconst { clearValue } = this;\n\t\t\t_clearValueVec4 = [];\n\t\t\tif (isFiniteNumber(clearValue)) {\n\t\t\t\t_clearValueVec4.push(clearValue as number, clearValue as number, clearValue as number, clearValue as number);\n\t\t\t} else {\n\t\t\t\t_clearValueVec4.push(...clearValue as number[]);\n\t\t\t\tfor (let j = _clearValueVec4.length; j < 4; j++) {\n\t\t\t\t\t_clearValueVec4.push(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clearValueVec4 = _clearValueVec4;\n\t\t}\n\t\treturn _clearValueVec4;\n\t}\n\n\t/**\n\t * Clear all data in GPULayer to GPULayer.clearValue.\n\t * @param applyToAllBuffers - Flag to apply to all buffers of GPULayer, or just the current output buffer.\n\t */\n\tclear(applyToAllBuffers = false) {\n\t\tconst { name, _composer, clearValueVec4, numBuffers, type } = this;\n\t\tconst { verboseLogging } = _composer;\n\t\tif (verboseLogging) console.log(`Clearing GPULayer \"${name}\".`);\n\n\t\tconst program = _composer._setValueProgramForType(type);\n\t\tprogram.setUniform('u_value', clearValueVec4);\n\t\tthis.decrementBufferIndex(); // step() wil increment buffer index before draw, this way we clear in place.\n\t\tconst endIndex = applyToAllBuffers ? numBuffers : 1;\n\t\tfor (let i = 0; i < endIndex; i++) {\n\t\t\t// Write clear value to buffers.\n\t\t\t_composer.step({\n\t\t\t\tprogram,\n\t\t\t\toutput: this,\n\t\t\t});\n\t\t}\n\t\tif (applyToAllBuffers) this.incrementBufferIndex(); // Get us back to the starting index.\n\t}\n\n\tprivate _getValuesSetup() {\n\t\tconst { width, height, _composer, _currentTexture } = this;\n\t\tlet { _valuesRaw } = this;\n\t\tconst { gl } = _composer;\n\n\t\t// In case GPULayer was not the last output written to.\n\t\tbindFrameBuffer(_composer, this, _currentTexture);\n\n\t\tlet { _glNumChannels, _glType, _glFormat, _internalType } = this;\n\t\tswitch (_internalType) {\n\t\t\tcase HALF_FLOAT:\n\t\t\t\tif (gl.FLOAT !== undefined) {\n\t\t\t\t\t// Firefox requires that RGBA/FLOAT is used for readPixels of float16 types.\n\t\t\t\t\t_glNumChannels = 4;\n\t\t\t\t\t_glFormat = gl.RGBA;\n\t\t\t\t\t_glType = gl.FLOAT;\n\t\t\t\t\t_valuesRaw = _valuesRaw || new Float32Array(width * height * _glNumChannels);\n\t\t\t\t} else {\n\t\t\t\t\t_valuesRaw = _valuesRaw || new Uint16Array(width * height * _glNumChannels);\n\t\t\t\t}\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Uint16Array(width * height * glNumChannels);\n\t\t\t\tbreak\n\t\t\tcase FLOAT:\n\t\t\t\t// Chrome and Firefox require that RGBA/FLOAT is used for readPixels of float32 types.\n\t\t\t\t// https://github.com/KhronosGroup/WebGL/issues/2747\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = gl.RGBA;\n\t\t\t\t_valuesRaw = _valuesRaw || new Float32Array(width * height * _glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_BYTE:\n\t\t\t\t// We never hit glslVersion === GLSL1 anymore, see GPULayerHelpers.shouldCastIntTypeAsFloat for more info.\n\t\t\t\t// if (glslVersion === GLSL1) {\n\t\t\t\t// \t// Firefox requires that RGBA/UNSIGNED_BYTE is used for readPixels of unsigned byte types.\n\t\t\t\t// \t_glNumChannels = 4;\n\t\t\t\t// \t_glFormat = gl.RGBA;\n\t\t\t\t// \t_valuesRaw = _valuesRaw || new Uint8Array(width * height * _glNumChannels);\n\t\t\t\t// \tbreak;\n\t\t\t\t// }\n\t\t\t\t// Firefox requires that RGBA_INTEGER/UNSIGNED_INT is used for readPixels of unsigned int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_glType = gl.UNSIGNED_INT;\n\t\t\t\t_valuesRaw = _valuesRaw || new Uint32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Uint8Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_SHORT:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/UNSIGNED_INT is used for readPixels of unsigned int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_glType = gl.UNSIGNED_INT;\n\t\t\t\t_valuesRaw = _valuesRaw || new Uint32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Uint16Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_INT:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/UNSIGNED_INT is used for readPixels of unsigned int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_valuesRaw = _valuesRaw || new Uint32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Uint32Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase BYTE:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/INT is used for readPixels of int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_glType = gl.INT;\n\t\t\t\t_valuesRaw = _valuesRaw || new Int32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Int8Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase SHORT:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/INT is used for readPixels of int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_glType = gl.INT;\n\t\t\t\t_valuesRaw = _valuesRaw || new Int32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Int16Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase INT:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/INT is used for readPixels of int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_valuesRaw = _valuesRaw || new Int32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Int32Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported internalType ${_internalType} for getValues().`);\n\t\t}\n\t\tthis._valuesRaw = _valuesRaw;\n\t\tif (readyToRead(gl)) {\n\t\t\treturn { _glFormat, _glType, _valuesRaw, _glNumChannels, _internalType };\n\t\t} else {\n\t\t\tthrow new Error(`Unable to read values from Buffer with status: ${gl.checkFramebufferStatus(gl.FRAMEBUFFER)}.`);\n\t\t}\n\t}\n\n\tprivate _getValuesPost(\n\t\t_valuesRaw: Float32Array | Uint16Array | Uint32Array | Int32Array,\n\t\t_glNumChannels: number,\n\t\t_internalType: GPULayerType,\n\t) {\n\t\tconst { width, height, numComponents, type } = this;\n\t\t\n\t\tconst OUTPUT_LENGTH = (this._length ? this._length : width * height) * numComponents;\n\n\t\t// Convert uint16 to float32 if needed.\n\t\tconst handleFloat16Conversion = _internalType === HALF_FLOAT && _valuesRaw.constructor === Uint16Array;\n\t\tlet { _valuesBufferView } = this;\n\t\tif (handleFloat16Conversion && !_valuesBufferView) {\n\t\t\t_valuesBufferView = new DataView((_valuesRaw as Uint16Array).buffer);\n\t\t\tthis._valuesBufferView = _valuesBufferView;\n\t\t}\n\t\t\n\n\t\t// We may use a different internal type than the assigned type of the GPULayer.\n\t\tif (_valuesRaw.length === OUTPUT_LENGTH && arrayConstructorForType(type, true) === _valuesRaw.constructor) {\n\t\t\tthis._values = _valuesRaw;\n\t\t} else if (!this._values) this._values = GPULayer.initArrayForType(type, OUTPUT_LENGTH, true);\n\t\tconst { _values } = this;\n\n\t\t// In some cases glNumChannels may be > numComponents.\n\t\tif (_valuesBufferView || _values !== _valuesRaw || numComponents !== _glNumChannels) {\n\t\t\tfor (let i = 0, length = width * height; i < length; i++) {\n\t\t\t\tconst index1 = i * _glNumChannels;\n\t\t\t\tconst index2 = i * numComponents;\n\t\t\t\tif (index2 >= OUTPUT_LENGTH) break;\n\t\t\t\tfor (let j = 0; j < numComponents; j++) {\n\t\t\t\t\tif (_valuesBufferView) {\n\t\t\t\t\t\t_values[index2 + j] = getFloat16(_valuesBufferView, 2 * (index1 + j), true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_values[index2 + j] = _valuesRaw[index1 + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _values;\n\t}\n\n\t/**\n\t * Returns the current values of the GPULayer as a TypedArray.\n\t * @returns - A TypedArray containing current state of GPULayer.\n\t */\n\tgetValues() {\n\t\tconst { width, height, _composer } = this;\n\t\tconst { gl } = _composer;\n\t\tconst { _glFormat, _glType, _valuesRaw, _glNumChannels, _internalType } = this._getValuesSetup();\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels\n\t\tgl.readPixels(0, 0, width, height, _glFormat, _glType, _valuesRaw);\n\t\treturn this._getValuesPost(_valuesRaw, _glNumChannels, _internalType);\n\t}\n\n\t/**\n\t * Non-blocking function to return the current values of the GPULayer as a TypedArray.\n\t * This only works for WebGL2 contexts, will fall back to getValues() if WebGL1 context.\n\t * @returns - A TypedArray containing current state of GPULayer.\n\t */\n\tasync getValuesAsync() {\n\t\tconst { width, height, _composer } = this;\n\t\tconst { gl, isWebGL2 } = _composer;\n\t\tif (!isWebGL2) {\n\t\t\t// Async method is not supported for WebGL1.\n\t\t\treturn this.getValues();\n\t\t}\n\t\tconst { _glFormat, _glType, _valuesRaw, _glNumChannels, _internalType } = this._getValuesSetup();\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels\n\t\tawait readPixelsAsync(gl as WebGL2RenderingContext, 0, 0, width, height, _glFormat, _glType, _valuesRaw);\n\t\treturn this._getValuesPost(_valuesRaw, _glNumChannels, _internalType);\n\t}\n\n\tprivate _getCanvasWithImageData(multiplier?: number) {\n\t\tconst values = this.getValues();\n\t\tconst { width, height, numComponents, type } = this;\n\n\t\tmultiplier = multiplier ||\n\t\t\t((type === FLOAT || type === HALF_FLOAT) ? 255 : 1);\n\t\t\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\tconst context = canvas.getContext('2d')!;\n\t\tconst imageData = context.getImageData(0, 0, width, height);\n\t\tconst buffer = imageData.data;\n\t\t// Have to flip the y axis since PNGs are written top to bottom.\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst index = y * width + x;\n\t\t\t\tconst indexFlipped = (height - 1 - y) * width + x;\n\t\t\t\tfor (let i = 0; i < numComponents; i++) {\n\t\t\t\t\tbuffer[4 * indexFlipped + i] = values[numComponents * index + i] * multiplier;\n\t\t\t\t}\n\t\t\t\tif (numComponents === 1) {\n\t\t\t\t\t// Make monochrome.\n\t\t\t\t\tbuffer[4 * indexFlipped + 1] = buffer[4 * indexFlipped];\n\t\t\t\t\tbuffer[4 * indexFlipped + 2] = buffer[4 * indexFlipped];\n\t\t\t\t}\n\t\t\t\tif (numComponents < 4) {\n\t\t\t\t\tbuffer[4 * indexFlipped + 3] = 255; // Set alpha channel to 255.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcontext.putImageData(imageData, 0, 0);\n\t\treturn canvas;\n\t}\n\n\t/**\n\t * Get the current state of this GPULayer as an Image.\n\t * @param params - Image parameters.\n\t * @param params.multiplier - Multiplier to apply to data (defaults to 255 for FLOAT and HALF_FLOAT types, else 1).\n\t*/\n\tgetImage(params?: {\n\t\tmultiplier?: number,\n\t}) {\n\t\tif (params) {\n\t\t\tconst validKeys = ['multiplier'];\n\t\t\tconst keys = Object.keys(params);\n\t\t\tcheckValidKeys(keys, validKeys, 'GPULayer.getImage(params)');\n\t\t}\n\t\tconst canvas = this._getCanvasWithImageData(params && params.multiplier);\n\t\tconst image = new Image();\n\t\timage.src = canvas.toDataURL();\n\t\treturn image;\n\t}\n\n\t/**\n\t * Save the current state of this GPULayer to png.\n\t * @param params - PNG parameters.\n\t * @param params.filename - PNG filename (no extension, defaults to the name of the GPULayer).\n\t * @param params.dpi - PNG dpi (defaults to 72dpi).\n\t * @param params.multiplier - Multiplier to apply to data before saving PNG (defaults to 255 for FLOAT and HALF_FLOAT types, else 1).\n\t * @param params.callback - Optional callback when Blob is ready, default behavior saves the PNG using file-saver.\n\t*/\n\tsavePNG(params: {\n\t\tfilename?: string,\n\t\tdpi?: number,\n\t\tmultiplier?: number,\n\t\tcallback?: (blob: Blob, filename: string) => void,\n\t} = {}) {\n\t\tconst validKeys = ['filename', 'dpi', 'multiplier', 'callback'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPULayer.savePNG(params)');\n\t\t\n\t\tconst { name } = this;\n\t\tconst callback = params.callback || saveAs; // Default to saving the image with file-saver.\n\t\tconst filename = params.filename || name; // Default to the name of this layer.\n\n\t\tconst canvas = this._getCanvasWithImageData(params.multiplier);\n\t\tcanvas.toBlob((blob) => {\n\t\t\tif (!blob) {\n\t\t\t\tconsole.warn(`Problem saving PNG from GPULayer \"${name}\", unable to init blob.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (params.dpi) {\n\t\t\t\tchangeDpiBlob(blob, params.dpi).then((blob: Blob) =>{\n\t\t\t\t\tcallback(blob, `${filename}.png`);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(blob, `${filename}.png`);\n\t\t\t}\n\t\t}, 'image/png');\n\t}\n\n\t/**\n\t * Attach the output buffer of this GPULayer to a Threejs Texture object.\n\t * @param {Texture} texture - Threejs texture object.\n\t */\n\tattachToThreeTexture(texture: Texture) {\n\t\tconst { _composer, numBuffers, currentState, name } = this;\n\t\tconst { _threeRenderer, gl } = _composer;\n\t\tif (!_threeRenderer) {\n\t\t\tthrow new Error('GPUComposer was not inited with a renderer.');\n\t\t}\n\t\t// Link webgl texture to threejs object.\n\t\t// This is not officially supported by threejs.\n\t\tif (numBuffers > 1) {\n\t\t\tthrow new Error(`GPULayer \"${name}\" contains multiple WebGL textures (one for each buffer) that are flip-flopped during compute cycles, please choose a GPULayer with one buffer.  You can copy the current state of this GPULayer to a single buffer GPULayer during your render loop.`);\n\t\t}\n\t\tconst offsetTextureProperties = _threeRenderer.properties.get(texture);\n\t\tgl.deleteTexture(offsetTextureProperties.__webglTexture);\n\t\toffsetTextureProperties.__webglTexture = currentState.texture;\n\t\toffsetTextureProperties.__webglInit = true;\n\t}\n\n\t/**\n\t * Delete this GPULayer's framebuffers and textures.\n\t * @private\n\t */\n\tprivate _destroyBuffers() {\n\t\tconst { _composer, _buffers } = this;\n\t\tconst { gl } = _composer;\n\t\t_buffers.forEach(texture => {\n\t\t\tgl.deleteTexture(texture);\n\t\t\tdisposeFramebuffers(gl, texture);\n\t\t});\n\t\t_buffers.length = 0;\n\n\t\t// These are technically owned by another GPULayer,\n\t\t// so we are not responsible for deleting them from gl context.\n\t\tdelete this._textureOverrides;\n\t}\n\n\t/**\n\t * Create a deep copy of GPULayer with current state copied over.\n\t * @param name - Name of new GPULayer as string.\n\t * @returns - Deep copy of GPULayer.\n\t */\n\tclone(name?: string) {\n\t\t// Make a deep copy.\n\t\treturn this._composer._cloneGPULayer(this, name);\n\t}\n\n\t/**\n\t * Deallocate GPULayer instance and associated WebGL properties.\n\t */\n\tdispose() {\n\t\tconst { name, _composer } = this;\n\t\tconst { gl, verboseLogging } = _composer;\n\n\t\tif (verboseLogging) console.log(`Deallocating GPULayer \"${name}\".`);\n\n\t\tif (!gl) throw new Error(`Must call dispose() on all GPULayers before calling dispose() on GPUComposer.`);\n\t\n\t\tthis._destroyBuffers();\n\t\t// @ts-ignore\n\t\tdelete this._buffers;\n\t\t// @ts-ignore\n\t\tdelete this._composer;\n\n\t\tif (this._values) delete this._values;\n\t\tif (this._valuesRaw) delete this._valuesRaw;\n\t}\n\n\t/** \n\t * These methods are defined in GPULayerHelpers.ts\n\t */\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic initArrayForType(\n\t\ttype: GPULayerType,\n\t\tlength: number,\n\t\thalfFloatsAsFloats?: boolean,\n\t): GPULayerArray;\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic calcGPULayerSize(\n\t\tsize: number | number[],\n\t\tname: string,\n\t\tverboseLogging: boolean,\n\t): { width: number, height: number, length?: number };\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic getGPULayerInternalWrap(\n\t\tparams: {\n\t\t\tcomposer: GPUComposer,\n\t\t\twrap: GPULayerWrap,\n\t\t\tinternalFilter: GPULayerFilter,\n\t\t\tinternalType: GPULayerType,\n\t\t\tname: string,\n\t\t},\n\t): GPULayerWrap;\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic getGPULayerInternalFilter(\n\t\tparams: {\n\t\t\tcomposer: GPUComposer,\n\t\t\tfilter: GPULayerFilter,\n\t\t\twrapX: GPULayerWrap,\n\t\t\twrapY: GPULayerWrap,\n\t\t\tinternalType: GPULayerType,\n\t\t\tname: string,\n\t\t},\n\t): GPULayerFilter;\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic getGLTextureParameters(\n\t\tparams: {\n\t\t\tcomposer: GPUComposer,\n\t\t\tname: string,\n\t\t\tnumComponents: GPULayerNumComponents,\n\t\t\tinternalType: GPULayerType,\n\t\t}\n\t): {\n\t\tglFormat: number,\n\t\tglInternalFormat: number,\n\t\tglType: number,\n\t\tglNumChannels: number,\n\t};\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic getGPULayerInternalType(\n\t\tparams: {\n\t\t\tcomposer: GPUComposer,\n\t\t\ttype: GPULayerType,\n\t\t\tname: string,\n\t\t},\n\t): GPULayerType;\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\t\n\tstatic validateGPULayerArray(\n\t\tarray: GPULayerArray | number[],\n\t\tlayer: GPULayer,\n\t): GPULayerArray;\n}","import { isNumber, isPositiveInteger } from '@amandaghassaei/type-checks';\nimport { setFloat16 } from '@petamoriken/float16';\nimport {\n\tBYTE,\n\tCLAMP_TO_EDGE,\n\tFLOAT,\n\tGPULayerFilter,\n\tGPULayerType,\n\tGPULayerWrap,\n\tHALF_FLOAT,\n\tINT,\n\tNEAREST,\n\tSHORT,\n\tUNSIGNED_BYTE,\n\tUNSIGNED_INT,\n\tUNSIGNED_SHORT,\n\tGLSL3,\n\tGPULayerNumComponents,\n\tGLSL1,\n\tGPULayerArray,\n\tvalidArrayTypes,\n\tMIN_UNSIGNED_BYTE,\n\tMAX_UNSIGNED_BYTE,\n\tMIN_BYTE,\n\tMAX_BYTE,\n\tMIN_UNSIGNED_SHORT,\n\tMAX_UNSIGNED_SHORT,\n\tMIN_SHORT,\n\tMAX_SHORT,\n\tMIN_UNSIGNED_INT,\n\tMAX_UNSIGNED_INT,\n\tMIN_INT,\n\tMAX_INT,\n\tLINEAR,\n\tDEFAULT_PROGRAM_NAME,\n} from './constants';\nimport { arrayConstructorForType } from './conversions';\nimport {\n\tEXT_COLOR_BUFFER_FLOAT,\n\tEXT_COLOR_BUFFER_HALF_FLOAT,\n\tgetExtension,\n\tOES_TEXTURE_FLOAT,\n\tOES_TEXTURE_FLOAT_LINEAR,\n\tOES_TEXTURE_HALF_FLOAT,\n\tOES_TEXTURE_HAlF_FLOAT_LINEAR,\n} from './extensions';\nimport { bindFrameBuffer } from './framebuffers';\nimport type { GPUComposer } from './GPUComposer';\nimport { GPULayer } from './GPULayer';\nimport {\n\tcompileShader,\n\tconvertFragmentShaderToGLSL1,\n\tinitGLProgram,\n\tisIntType,\n\tisUnsignedIntType,\n} from './utils';\n\n// Memoize results.\nconst results = {\n\twriteSupport: {} as { [key: string]: boolean },\n\tfilterWrapSupport: {} as { [key: string]: boolean },\n}\n\n/**\n * Init empty typed array for type, optionally use Float32Array for HALF_FLOAT.\n * @private\n */\nGPULayer.initArrayForType = (\n\ttype: GPULayerType,\n\tlength: number,\n\thalfFloatsAsFloats = false,\n) => {\n\treturn new (arrayConstructorForType(type, halfFloatsAsFloats))(length);\n}\n\n/**\n * Calc 2D size [width, height] for GPU layer given a 1D or 2D size parameter.\n * If 1D size supplied, nearest power of 2 width/height is generated.\n * Also checks that size elements are valid.\n * @private\n */\n\nGPULayer.calcGPULayerSize = (\n\tsize: number | number[],\n\tname: string,\n\tverboseLogging: boolean,\n) => {\n\tif (isNumber(size as number)) {\n\t\tif (!isPositiveInteger(size)) {\n\t\t\tthrow new Error(`Invalid length: ${JSON.stringify(size)} for GPULayer \"${name}\", must be positive integer.`);\n\t\t}\n\t\tconst length = size as number;\n\t\t// Relaxing adherence to power of 2.\n\t\t// // Calc power of two width and height for length.\n\t\t// let exp = 1;\n\t\t// let remainder = length;\n\t\t// while (remainder > 2) {\n\t\t// \texp++;\n\t\t// \tremainder /= 2;\n\t\t// }\n\t\t// const width = Math.pow(2, Math.floor(exp / 2) + exp % 2);\n\t\t// const height = Math.pow(2, Math.floor(exp/2));\n\t\tconst width = Math.ceil(Math.sqrt(length));\n\t\tconst height = Math.ceil(length / width);\n\t\tif (verboseLogging) console.log(`Using [${width}, ${height}] for 1D array of length ${size} in GPULayer \"${name}\".`);\n\t\treturn { width, height, length };\n\t}\n\tconst width = (size as number[])[0];\n\tif (!isPositiveInteger(width)) {\n\t\tthrow new Error(`Invalid width: ${JSON.stringify(width)} for GPULayer \"${name}\", must be positive integer.`);\n\t}\n\tconst height = (size as number[])[1];\n\tif (!isPositiveInteger(height)) {\n\t\tthrow new Error(`Invalid height: ${JSON.stringify(height)} for GPULayer \"${name}\", must be positive integer.`);\n\t}\n\treturn { width, height };\n}\n\n/**\n * Get the GL wrap type to use internally in GPULayer, based on browser support.\n * @private\n */\nGPULayer.getGPULayerInternalWrap = (\n\tparams: {\n\t\tcomposer: GPUComposer,\n\t\twrap: GPULayerWrap,\n\t\tinternalFilter: GPULayerFilter,\n\t\tinternalType: GPULayerType,\n\t\tname: string,\n\t},\n) => {\n\tconst { composer, wrap, internalFilter, internalType } = params;\n\n\t// CLAMP_TO_EDGE is always supported.\n\tif (wrap === CLAMP_TO_EDGE) {\n\t\treturn wrap;\n\t}\n\n\t// Test if wrap/filter combo is actually supported by running some numbers through.\n\tif (testFilterWrap(composer, internalType, internalFilter, wrap)) {\n\t\treturn wrap;\n\t}\n\t// If not, convert to CLAMP_TO_EDGE and polyfill in fragment shader.\n\treturn CLAMP_TO_EDGE;\n\t// REPEAT and MIRROR_REPEAT wrap not supported for non-power of 2 textures in safari.\n\t// I've tested this and it seems that some power of 2 textures will work (512 x 512),\n\t// but not others (1024x1024), so let's just change all WebGL 1.0 to CLAMP.\n\t// Without this, we currently get an error at drawArrays():\n\t// \"WebGL: drawArrays: texture bound to texture unit 0 is not renderable.\n\t// It maybe non-power-of-2 and have incompatible texture filtering or is not\n\t// 'texture complete', or it is a float/half-float type with linear filtering and\n\t// without the relevant float/half-float linear extension enabled.\"\n}\n\n/**\n * Get the GL filter type to use internally in GPULayer, based on browser support.\n * @private\n */\n GPULayer.getGPULayerInternalFilter = (\n\tparams: {\n\t\tcomposer: GPUComposer,\n\t\tfilter: GPULayerFilter,\n\t\twrapX: GPULayerWrap,\n\t\twrapY: GPULayerWrap,\n\t\tinternalType: GPULayerType,\n\t\tname: string,\n\t},\n) => {\n\tlet { filter } = params;\n\tif (filter === NEAREST) {\n\t\t// NEAREST filtering is always supported.\n\t\treturn filter;\n\t}\n\n\tconst { composer, internalType, wrapX, wrapY, name } = params;\n\n\tif (internalType === HALF_FLOAT) {\n\t\tconst extension = getExtension(composer, OES_TEXTURE_HAlF_FLOAT_LINEAR, true)\n\t\t\t|| getExtension(composer, OES_TEXTURE_FLOAT_LINEAR, true);\n\t\tif (!extension || !testFilterWrap(composer, internalType, filter, wrapX) || !testFilterWrap(composer, internalType, filter, wrapY)) {\n\t\t\tconsole.warn(`This browser does not support ${filter} filtering for type ${internalType} and wrap [${wrapX}, ${wrapY}].  Falling back to NEAREST filter for GPULayer \"${name}\" with ${filter} polyfill in fragment shader.`);\n\t\t\tfilter = NEAREST; // Polyfill in fragment shader.\n\t\t}\n\t} if (internalType === FLOAT) {\n\t\tconst extension = getExtension(composer, OES_TEXTURE_FLOAT_LINEAR, true);\n\t\tif (!extension || !testFilterWrap(composer, internalType, filter, wrapX) || !testFilterWrap(composer, internalType, filter, wrapY)) {\n\t\t\tconsole.warn(`This browser does not support ${filter} filtering for type ${internalType} and wrap [${wrapX}, ${wrapY}].  Falling back to NEAREST filter for GPULayer \"${name}\" with ${filter} polyfill in fragment shader.`);\n\t\t\tfilter = NEAREST; // Polyfill in fragment shader.\n\t\t}\n\t}\n\treturn filter;\n}\n\n/**\n * Returns whether to cast int type as floats, as needed by browser.\n * @private\n */\nexport function shouldCastIntTypeAsFloat(\n\tcomposer: GPUComposer,\n\ttype: GPULayerType,\n) {\n\tconst { glslVersion, isWebGL2 } = composer;\n\t// All types are supported by WebGL2 + glsl3.\n\tif (glslVersion === GLSL3 && isWebGL2) return false;\n\t// Int textures (other than UNSIGNED_BYTE) are not supported by WebGL1.0 or glsl1.x.\n\t// https://stackoverflow.com/questions/55803017/how-to-select-webgl-glsl-sampler-type-from-texture-format-properties\n\t// Use HALF_FLOAT/FLOAT instead.\n\t// Some large values of INT and UNSIGNED_INT are not supported unfortunately.\n\t// See tests for more information.\n\t// Update: Even UNSIGNED_BYTE should be cast as float in GLSL1.  I noticed some strange behavior in test:\n\t// setUniform>'should cast/handle uint uniforms for UNSIGNED_BYTE GPULayers' in tests/mocha/GPUProgram and \n\t// getValues>'should return correct values for UNSIGNED_BYTE GPULayer' in tests/mocha/GPULayer\n\treturn type === UNSIGNED_BYTE || type === BYTE || type === SHORT || type === INT || type === UNSIGNED_SHORT || type === UNSIGNED_INT;\n}\n\n/**\n * Returns GLTexture parameters for GPULayer, based on browser support.\n * @private\n */\nGPULayer.getGLTextureParameters = (\n\tparams: {\n\t\tcomposer: GPUComposer,\n\t\tname: string,\n\t\tnumComponents: GPULayerNumComponents,\n\t\tinternalType: GPULayerType,\n\t}\n) => {\n\tconst { composer, name, numComponents, internalType } = params;\n\tconst { gl, glslVersion, isWebGL2 } = composer;\n\t// https://www.khronos.org/registry/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE\n\tlet glType: number | undefined,\n\t\tglFormat: number | undefined,\n\t\tglInternalFormat: number | undefined,\n\t\tglNumChannels: number | undefined;\n\n\tif (isWebGL2) {\n\t\tglNumChannels = numComponents;\n\t\t// https://www.khronos.org/registry/webgl/extensions/EXT_color_buffer_float/\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n\t\t// The sized internal format RGBxxx are not color-renderable.\n\t\t// If numComponents == 3 for a writable texture, use RGBA instead.\n\t\t// Page 5 of https://www.khronos.org/files/webgl20-reference-guide.pdf\n\t\t// Update: Some formats (e.g. RGB) may be emulated, causing a performance hit:\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#some_formats_e.g._rgb_may_be_emulated\n\t\t// Prefer to use rgba instead of rgb for all cases (WebGL1 and WebGL2).\n\t\tif (numComponents === 3) {\n\t\t\tglNumChannels = 4;\n\t\t}\n\t\tif (internalType === FLOAT || internalType === HALF_FLOAT) {\n\t\t\t// This will be hit in all cases for GLSL1, now that we have cast UNSIGNED_BYTE types to HALF_FLOAT for GLSL1.\n\t\t\t// See comments in shouldCastIntTypeAsFloat for more information.\n\t\t\tswitch (glNumChannels) {\n\t\t\t\tcase 1:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RG;\n\t\t\t\t\tbreak;\n\t\t\t\t// case 3:\n\t\t\t\t// \tglFormat = gl.RGB; // We never hit this.\n\t\t\t\t// \tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tglFormat = gl.RGBA;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t}\n\t\t} else {\n\t\t\t// This case will only be hit by GLSL 3.\n\t\t\t// Int textures are not supported in GLSL1.\n\t\t\tswitch (glNumChannels) {\n\t\t\t\tcase 1:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RED_INTEGER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RG_INTEGER;\n\t\t\t\t\tbreak;\n\t\t\t\t// case 3:\n\t\t\t\t// \tglFormat = (gl as WebGL2RenderingContext).RGB_INTEGER; // We never hit this.\n\t\t\t\t// \tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t}\n\t\t}\n\t\tswitch (internalType) {\n\t\t\tcase HALF_FLOAT:\n\t\t\t\tglType = (gl as WebGL2RenderingContext).HALF_FLOAT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R16F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG16F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB16F; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA16F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FLOAT:\n\t\t\t\tglType = (gl as WebGL2RenderingContext).FLOAT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R32F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG32F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB32F; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA32F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_BYTE:\n\t\t\t\tglType = gl.UNSIGNED_BYTE;\n\t\t\t\tif (glslVersion === GLSL1 && internalType === UNSIGNED_BYTE) {\n\t\t\t\t\tglInternalFormat = glFormat;\n\t\t\t\t} else {\n\t\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R8UI;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG8UI;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// case 3:\n\t\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB8UI; // We never hit this.\n\t\t\t\t\t\t// \tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA8UI;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BYTE:\n\t\t\t\tglType = gl.BYTE;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R8I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG8I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB8I; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA8I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SHORT:\n\t\t\t\tglType = gl.SHORT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R16I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG16I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB16I; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA16I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_SHORT:\n\t\t\t\tglType = gl.UNSIGNED_SHORT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R16UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG16UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB16UI; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA16UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase INT:\n\t\t\t\tglType = gl.INT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R32I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG32I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB32I; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA32I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_INT:\n\t\t\t\tglType = gl.UNSIGNED_INT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R32UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG32UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB32UI; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA32UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported type: \"${internalType}\" for GPULayer \"${name}\".`);\n\t\t}\n\t} else {\n\t\t// WebGL1 case.\n\t\tif (numComponents < 1 || numComponents > 4) {\n\t\t\tthrow new Error(`Unsupported numComponents: ${numComponents} for GPULayer \"${name}\".`);\n\t\t}\n\t\t// Always use 4 channel textures for WebGL1.\n\t\t// Some formats (e.g. RGB) may be emulated, causing a performance hit:\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#some_formats_e.g._rgb_may_be_emulated\n\t\tglNumChannels = 4;\n\t\tglFormat = gl.RGBA;\n\t\tglInternalFormat = gl.RGBA;\n\t\tswitch (internalType) {\n\t\t\tcase FLOAT:\n\t\t\t\tglType = gl.FLOAT;\n\t\t\t\tbreak;\n\t\t\tcase HALF_FLOAT:\n\t\t\t\tglType = (gl as WebGL2RenderingContext).HALF_FLOAT || getExtension(composer, OES_TEXTURE_HALF_FLOAT).HALF_FLOAT_OES as number;\n\t\t\t\tbreak;\n\t\t\t// case UNSIGNED_BYTE:\n\t\t\t// \t// This will never be hit, now that we have cast UNSIGNED_BYTE types to HALF_FLOAT for GLSL1.\n\t\t\t// \t// See comments in shouldCastIntTypeAsFloat for more information.\n\t\t\t// \tglType = gl.UNSIGNED_BYTE;\n\t\t\t// \tbreak;\n\t\t\t// No other types are supported in WebGL1.\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported type: \"${internalType}\" in WebGL 1.0 for GPULayer \"${name}\".`);\n\t\t}\n\t}\n\n\t// Check for missing params.\n\tif (glType === undefined || glFormat === undefined || glInternalFormat === undefined) {\n\t\tconst missingParams = [];\n\t\tif (glType === undefined) missingParams.push('glType');\n\t\tif (glFormat === undefined) missingParams.push('glFormat');\n\t\tif (glInternalFormat === undefined) missingParams.push('glInternalFormat');\n\t\tthrow new Error(`Invalid type: ${internalType} for numComponents: ${numComponents}, unable to init parameter${missingParams.length > 1 ? 's' : ''} ${missingParams.join(', ')} for GPULayer \"${name}\".`);\n\t}\n\tif (glNumChannels === undefined || numComponents < 1 || numComponents > 4 || glNumChannels < numComponents) {\n\t\tthrow new Error(`Invalid numChannels: ${glNumChannels} for numComponents: ${numComponents} for GPULayer \"${name}\".`);\n\t}\n\n\treturn {\n\t\tglFormat,\n\t\tglInternalFormat,\n\t\tglType,\n\t\tglNumChannels,\n\t};\n}\n\n/**\n * Rigorous method for testing FLOAT and HALF_FLOAT write support by attaching texture to framebuffer.\n * @private\n */\nexport function testWriteSupport(\n\tcomposer: GPUComposer,\n\tinternalType: GPULayerType,\n) {\n\tconst { gl, glslVersion, isWebGL2 } = composer;\n\n\t// Memoize results for a given set of inputs.\n\tconst key = `${isWebGL2},${internalType},${glslVersion === GLSL3 ? '3' : '1'}`;\n\tif (results.writeSupport[key] !== undefined) {\n\t\treturn results.writeSupport[key];\n\t}\n\n\tconst texture = gl.createTexture();\n\tif (!texture) {\n\t\tresults.writeSupport[key] = false;\n\t\treturn results.writeSupport[key];\n\t}\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\n\t// Default to most widely supported settings.\n\tconst wrap = gl[CLAMP_TO_EDGE];\n\tconst filter = gl[NEAREST];\n\t// Use non-power of two dimensions to check for more universal support.\n\t// (In case size of GPULayer is changed at a later point).\n\tconst width = 10;\n\tconst height = 10;\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n\n\tconst { glInternalFormat, glFormat, glType } = GPULayer.getGLTextureParameters({\n\t\tcomposer,\n\t\tname: 'testWriteSupport',\n\t\tnumComponents: 1,\n\t\tinternalType,\n\t});\n\tgl.texImage2D(gl.TEXTURE_2D, 0, glInternalFormat, width, height, 0, glFormat, glType, null);\n\n\t// Init a framebuffer for this texture so we can write to it.\n\tconst framebuffer = gl.createFramebuffer();\n\tif (!framebuffer) {\n\t\t// Clear out allocated memory.\n\t\tgl.deleteTexture(texture);\n\t\tresults.writeSupport[key] = false;\n\t\treturn results.writeSupport[key];\n\t}\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/framebufferTexture2D\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n\tconst validStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n\t// Clear out allocated memory.\n\tgl.deleteTexture(texture);\n\tgl.deleteFramebuffer(framebuffer);\n\n\tresults.writeSupport[key] = validStatus;\n\treturn results.writeSupport[key];\n}\n\n/**\n * Rigorous method for testing whether a filter/wrap combination is supported\n * by the current browser.  I found that some versions of WebGL2 mobile safari\n * may support the OES_texture_float_linear and EXT_color_buffer_float, but still\n * do not linearly interpolate float textures or wrap only for power-of-two textures.\n * @private\n */\nexport function testFilterWrap(\n\tcomposer: GPUComposer,\n\tinternalType: GPULayerType,\n\tfilter: GPULayerFilter,\n\twrap: GPULayerWrap,\n) {\n\tconst { gl, glslVersion, intPrecision, floatPrecision, _errorCallback, isWebGL2 } = composer;\n\n\t// Memoize results for a given set of inputs.\n\tconst key = `${isWebGL2},${internalType},${filter},${wrap},${glslVersion === GLSL3 ? '3' : '1'}`;\n\tif (results.filterWrapSupport[key] !== undefined) {\n\t\treturn results.filterWrapSupport[key];\n\t}\n\n\tconst texture = gl.createTexture();\n\tif (!texture) {\n\t\tresults.filterWrapSupport[key] = false;\n\t\treturn results.filterWrapSupport[key];\n\t}\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\n\tconst glWrap = gl[wrap];\n\tconst glFilter = gl[filter];\n\t// Use non power of two dimensions to check for more universal support.\n\tconst width = 3;\n\tconst height = 3;\n\tconst numComponents = 1;\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, glWrap);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, glWrap);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);\n\n\tconst { glInternalFormat, glFormat, glType, glNumChannels } = GPULayer.getGLTextureParameters({\n\t\tcomposer,\n\t\tname: 'testFilterWrap',\n\t\tnumComponents,\n\t\tinternalType,\n\t});\n\t// Init texture with values.\n\tconst values = [3, 56.5, 834, -53.6, 0.003, 96.2, 23, 90.2, 32];\n\tlet valuesTyped = GPULayer.initArrayForType(internalType, values.length * glNumChannels, true);\n\tfor (let i = 0; i < values.length; i++) {\n\t\tvaluesTyped[i * glNumChannels] = values[i];\n\t\tvalues[i] = valuesTyped[i * glNumChannels]; // Cast as int/uint if needed.\n\t}\n\tif (internalType === HALF_FLOAT) {\n\t\t// Cast values as Uint16Array for HALF_FLOAT.\n\t\tconst valuesTyped16 = new Uint16Array(valuesTyped.length);\n\t\tconst float16View =  new DataView(valuesTyped16.buffer);\n\t\tfor (let i = 0; i < valuesTyped.length; i++) {\n\t\t\tsetFloat16(float16View, 2 * i, valuesTyped[i], true);\n\t\t}\n\t\tvaluesTyped = valuesTyped16;\n\t}\n\tgl.texImage2D(gl.TEXTURE_2D, 0, glInternalFormat, width, height, 0, glFormat, glType, valuesTyped);\n\n\t// Init a GPULayer to write to.\n\t// Must use CLAMP_TO_EDGE/NEAREST on this GPULayer to avoid infinite loop.\n\tconst output = new GPULayer(composer, {\n\t\tname: 'testFloatLinearFiltering-output',\n\t\ttype: internalType,\n\t\tnumComponents,\n\t\tdimensions: [width, height],\n\t\twrapX: CLAMP_TO_EDGE,\n\t\twrapY: CLAMP_TO_EDGE,\n\t\tfilter: NEAREST,\n\t});\n\n\tconst offset = filter === LINEAR ? 0.5 : 1;\n\t// Run program to perform linear filter.\n\tconst programName = 'testFilterWrap-program';\n\tlet fragmentShaderSource = `\nin vec2 v_uv;\nuniform vec2 u_offset;\n#ifdef GPUIO_INT\n\tuniform isampler2D u_input;\n\tout int out_result;\n#endif\n#ifdef GPUIO_UINT\n\tuniform usampler2D u_input;\n\tout uint out_result;\n#endif\n#ifdef GPUIO_FLOAT\n\tuniform sampler2D u_input;\n\tout float out_result;\n#endif\nvoid main() {\n\tout_result = texture(u_input, v_uv + offset).x;\n}`;\n\tif (glslVersion !== GLSL3) {\n\t\tfragmentShaderSource = convertFragmentShaderToGLSL1(fragmentShaderSource, programName)[0];\n\t}\n\tconst fragmentShader = compileShader(\n\t\tgl,\n\t\tglslVersion,\n\t\tintPrecision,\n\t\tfloatPrecision,\n\t\tfragmentShaderSource,\n\t\tgl.FRAGMENT_SHADER,\n\t\tprogramName,\n\t\t_errorCallback,\n\t\t{\n\t\t\toffset: `vec2(${offset / width}, ${offset / height})`,\n\t\t\t[isUnsignedIntType(internalType) ? 'GPUIO_UINT' : (isIntType(internalType) ? 'GPUIO_INT': 'GPUIO_FLOAT')]: '1',\n\t\t},\n\t\tundefined,\n\t\ttrue,\n\t);\n\n\tfunction wrapValue(val: number, max: number) {\n\t\tif (wrap === CLAMP_TO_EDGE) return Math.max(0, Math.min(max - 1, val));\n\t\treturn (val + max) % max;\n\t}\n\n\tconst vertexShader = composer._getVertexShader(DEFAULT_PROGRAM_NAME, '', {}, programName);\n\tif (vertexShader && fragmentShader) {\n\t\tconst program = initGLProgram(gl, vertexShader, fragmentShader, programName, _errorCallback);\n\t\tif (program) {\n\t\t\t// Draw setup.\n\t\t\toutput._prepareForWrite(false);\n\t\t\tbindFrameBuffer(composer, output, output._currentTexture);\n\t\t\tgl.viewport(0, 0, width, height);\n\t\t\tgl.useProgram(program);\n\t\t\t// Bind texture.\n\t\t\tgl.activeTexture(gl.TEXTURE0 );\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\t// Set uniforms.\n\t\t\tgl.uniform2fv(gl.getUniformLocation(program, 'u_gpuio_scale'), [1, 1]);\n\t\t\tgl.uniform2fv(gl.getUniformLocation(program, 'u_gpuio_translation'), [0, 0]);\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, composer._getQuadPositionsBuffer());\n\t\t\tcomposer._setPositionAttribute(program, programName);\n\n\t\t\t// Draw.\n\t\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t\t\tgl.disable(gl.BLEND);\n\n\t\t\tconst filtered = output.getValues();\n\t\t\tlet supported = true;\n\t\t\tconst tol = isIntType(internalType) ? 0 : (internalType === HALF_FLOAT ? 1e-2 : 1e-4);\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\t\tlet expected;\n\t\t\t\t\tif (filter === LINEAR) {\n\t\t\t\t\t\texpected = (values[y * width + x] +\n\t\t\t\t\t\t\tvalues[y * width + wrapValue(x + 1, width)] +\n\t\t\t\t\t\t\tvalues[wrapValue(y + 1, height) * width + x] +\n\t\t\t\t\t\t\tvalues[wrapValue(y + 1, height) * width + wrapValue(x + 1, width)]) / 4;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst _x = wrapValue(x + offset, width);\n\t\t\t\t\t\tconst _y = wrapValue(y + offset, height);\n\t\t\t\t\t\texpected = values[_y * width + _x];\n\t\t\t\t\t}\n\t\t\t\t\tconst i = y * width + x;\n\t\t\t\t\tif (Math.abs((expected - filtered[i]) / expected) > tol) {\n\t\t\t\t\t\tsupported = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.filterWrapSupport[key] = supported;\n\t\t\t// Clear out allocated memory.\n\t\t\tgl.deleteProgram(program);\n\t\t} else {\n\t\t\tresults.filterWrapSupport[key] = false;\n\t\t}\n\t\t// Clear out allocated memory.\n\t\t// vertexShader belongs to composer, don't delete it.\n\t\tgl.deleteShader(fragmentShader);\n\t} else {\n\t\tresults.filterWrapSupport[key] = false;\n\t}\n\t// Clear out allocated memory.\n\toutput.dispose();\n\tgl.deleteTexture(texture);\n\treturn results.filterWrapSupport[key];\n}\n\n/**\n * Get the GL type to use internally in GPULayer, based on browser support.\n * @private\n * Exported here for testing purposes.\n */\nGPULayer.getGPULayerInternalType = (\n\tparams: {\n\t\tcomposer: GPUComposer,\n\t\ttype: GPULayerType,\n\t\tname: string,\n\t},\n) => {\n\tconst { composer, name } = params;\n\tconst { _errorCallback, isWebGL2 } = composer;\n\tconst { type } = params;\n\tlet internalType = type;\n\t// Check if int types are supported.\n\tconst intCast = shouldCastIntTypeAsFloat(composer, type);\n\tif (intCast) {\n\t\tif (internalType === UNSIGNED_BYTE || internalType === BYTE) {\n\t\t\t// Integers between -2048 and +2048 can be exactly represented by half float.\n\t\t\tinternalType = HALF_FLOAT;\n\t\t} else {\n\t\t\t// Integers between 0 and 16777216 can be exactly represented by float32 (also applies for negative integers between 16777216 and 0)\n\t\t\t// This is sufficient for UNSIGNED_SHORT and SHORT types.\n\t\t\t// Large UNSIGNED_INT and INT cannot be represented by FLOAT type.\n\t\t\tconsole.warn(`Falling back ${internalType} type to FLOAT type for glsl1.x support for GPULayer \"${name}\".\nLarge UNSIGNED_INT or INT with absolute value > 16,777,216 are not supported, on mobile UNSIGNED_INT, INT, UNSIGNED_SHORT, and SHORT with absolute value > 2,048 may not be supported.`);\n\t\t\tinternalType = FLOAT;\n\t\t}\n\t}\n\n\t// Check if float textures supported.\n\tif (!isWebGL2) {\n\t\tif (internalType === FLOAT) {\n\t\t\t// The OES_texture_float extension implicitly enables WEBGL_color_buffer_float extension (for writing).\n\t\t\tconst extension = getExtension(composer, OES_TEXTURE_FLOAT, true);\n\t\t\tif (extension) {\n\t\t\t\t// https://stackoverflow.com/questions/17476632/webgl-extension-support-across-browsers\n\t\t\t\t// Rendering to a floating-point texture may not be supported, even if the OES_texture_float extension\n\t\t\t\t// is supported. Typically, this fails on mobile hardware. To check if this is supported, you have to\n\t\t\t\t// call the WebGL checkFramebufferStatus() function after attempting to attach texture to framebuffer.\n\t\t\t\tconst valid = testWriteSupport(composer, internalType);\n\t\t\t\tif (!valid) {\n\t\t\t\t\tconsole.warn(`FLOAT not supported for writing operations in this browser, falling back to HALF_FLOAT type for GPULayer \"${name}\".`);\n\t\t\t\t\tinternalType = HALF_FLOAT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`FLOAT not supported in this browser, falling back to HALF_FLOAT type for GPULayer \"${name}\".`);\n\t\t\t\tinternalType = HALF_FLOAT;\n\t\t\t}\n\t\t}\n\t\t// Must support at least half float if using a float type.\n\t\tif (internalType === HALF_FLOAT) {\n\t\t\t// The OES_texture_half_float extension implicitly enables EXT_color_buffer_half_float extension (for writing).\n\t\t\tgetExtension(composer, OES_TEXTURE_HALF_FLOAT, true);\n\t\t\t// FYI, very old safari issues: https://stackoverflow.com/questions/54248633/cannot-create-half-float-oes-texture-from-uint16array-on-ipad\n\t\t\tconst valid = testWriteSupport(composer, internalType);\n\t\t\t// May still be ok for read-only, but this will affect the ability to call getValues() and savePNG().\n\t\t\t// We'll let it pass for now.\n\t\t\tif (!valid) {\n\t\t\t\tconsole.warn(`This browser does not support writing to HALF_FLOAT textures.`);\n\t\t\t\t// _errorCallback(`This browser does not support writing to HALF_FLOAT textures.`);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// For writable webGL2 contexts, load EXT_color_buffer_float/EXT_color_buffer_half_float extension.\n\t\tif (internalType === FLOAT) {\n\t\t\tconst extension = getExtension(composer, EXT_COLOR_BUFFER_FLOAT, true);\n\t\t\tif (!extension) {\n\t\t\t\tconsole.warn(`FLOAT not supported in this browser, falling back to HALF_FLOAT type for GPULayer \"${name}\".`);\n\t\t\t\tinternalType = HALF_FLOAT;\n\t\t\t} else {\n\t\t\t\t// Test attaching texture to framebuffer to be sure float writing is supported.\n\t\t\t\tconst valid = testWriteSupport(composer, internalType);\n\t\t\t\tif (!valid) {\n\t\t\t\t\tconsole.warn(`FLOAT not supported for writing operations in this browser, falling back to HALF_FLOAT type for GPULayer \"${name}\".`);\n\t\t\t\t\tinternalType = HALF_FLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (internalType === HALF_FLOAT) {\n\t\t\t// On WebGL 2, EXT_color_buffer_half_float is an alternative to using the EXT_color_buffer_float extension\n\t\t\t// on platforms that support 16-bit floating point render targets but not 32-bit floating point render targets.\n\t\t\tconst halfFloatExt = getExtension(composer, EXT_COLOR_BUFFER_HALF_FLOAT, true);\n\t\t\tif (!halfFloatExt) {\n\t\t\t\t// Some versions of Firefox (e.g. Firefox v104 on Mac) do not support EXT_COLOR_BUFFER_HALF_FLOAT,\n\t\t\t\t// but EXT_COLOR_BUFFER_FLOAT will work instead.\n\t\t\t\tgetExtension(composer, EXT_COLOR_BUFFER_FLOAT, true);\n\t\t\t}\n\t\t\t// Test attaching texture to framebuffer to be sure half float writing is supported.\n\t\t\tconst valid = testWriteSupport(composer, internalType);\n\t\t\t// May still be ok for read-only, but this will affect the ability to call getValues() and savePNG().\n\t\t\t// We'll let it pass for now.\n\t\t\tif (!valid) {\n\t\t\t\tconsole.warn(`This browser does not support writing to HALF_FLOAT textures.`);\n\t\t\t\t_errorCallback(`This browser does not support writing to HALF_FLOAT textures.`);\n\t\t\t}\n\t\t}\n\t}\n\treturn internalType;\n}\n\n/**\n * Min and max values for types.\n * @private\n */\nexport function minMaxValuesForType(type: GPULayerType) {\n\t// Get min and max values for int types.\n\tlet min = -Infinity;\n\tlet max = Infinity;\n\tswitch(type) {\n\t\tcase UNSIGNED_BYTE:\n\t\t\tmin = MIN_UNSIGNED_BYTE;\n\t\t\tmax = MAX_UNSIGNED_BYTE;\n\t\t\tbreak;\n\t\tcase BYTE:\n\t\t\tmin = MIN_BYTE;\n\t\t\tmax = MAX_BYTE;\n\t\t\tbreak;\n\t\tcase UNSIGNED_SHORT:\n\t\t\tmin = MIN_UNSIGNED_SHORT;\n\t\t\tmax = MAX_UNSIGNED_SHORT;\n\t\t\tbreak;\n\t\tcase SHORT:\n\t\t\tmin = MIN_SHORT;\n\t\t\tmax = MAX_SHORT;\n\t\t\tbreak;\n\t\tcase UNSIGNED_INT:\n\t\t\tmin = MIN_UNSIGNED_INT;\n\t\t\tmax = MAX_UNSIGNED_INT;\n\t\t\tbreak;\n\t\tcase INT:\n\t\t\tmin = MIN_INT;\n\t\t\tmax = MAX_INT;\n\t\t\tbreak;\n\t}\n\treturn {\n\t\tmin, max,\n\t};\n}\n\n/**\n * Recasts typed array to match GPULayer.internalType.\n * @private\n */\nGPULayer.validateGPULayerArray = (array: GPULayerArray | number[], layer: GPULayer) => {\n\tconst { numComponents, width, height, name } = layer;\n\tconst glNumChannels = layer._glNumChannels;\n\tconst internalType = layer._internalType;\n\tconst length = layer.is1D() ? layer.length : null;\n\n\t// Check that data is correct length (user error).\n\tif (array.length !== width * height * numComponents) { // Either the correct length for WebGLTexture size\n\t\tif (!length || (length &&  array.length !== length * numComponents)) { // Of the correct length for 1D array.\n\t\t\tthrow new Error(`Invalid data length: ${array.length} for GPULayer \"${name}\" of ${length ? `length ${length} and ` : ''}dimensions: [${width}, ${height}] and numComponents: ${numComponents}.`);\n\t\t}\n\t}\n\n\t// Get array type to figure out if we need to type cast.\n\t// For webgl1.0 we may need to cast an int type to a FLOAT or HALF_FLOAT.\n\tlet shouldTypeCast = false;\n\tswitch(array.constructor) {\n\t\tcase Array:\n\t\t\tshouldTypeCast = true;\n\t\t\tbreak;\n\t\tcase Float32Array:\n\t\t\tshouldTypeCast = internalType !== FLOAT;\n\t\t\tbreak;\n\t\tcase Uint8Array:\n\t\t\tshouldTypeCast = internalType !== UNSIGNED_BYTE;\n\t\t\tbreak;\n\t\tcase Int8Array:\n\t\t\tshouldTypeCast = internalType !== BYTE;\n\t\t\tbreak;\n\t\tcase Uint16Array:\n\t\t\t// User may have converted to HALF_FLOAT already.\n\t\t\t// We need to add this check in case type is UNSIGNED_SHORT and internal type is HALF_FLOAT.\n\t\t\t// (This can happen for some WebGL1 contexts.)\n\t\t\t// if (type === HALF_FLOAT) {\n\t\t\t// \tshouldTypeCast = internalType !== HALF_FLOAT;\n\t\t\t// \t// In order to complete this, we will also need to handle converting from Uint16Array to some other type.\n\t\t\t// \t// Are there cases where HALF_FLOAT is not supported?\n\t\t\t// } else {\n\t\t\t\tshouldTypeCast = internalType !== UNSIGNED_SHORT\n\t\t\t// }\n\t\t\tbreak;\n\t\tcase Int16Array:\n\t\t\tshouldTypeCast = internalType !== SHORT;\n\t\t\tbreak;\n\t\tcase Uint32Array:\n\t\t\tshouldTypeCast = internalType !== UNSIGNED_INT;\n\t\t\tbreak;\n\t\tcase Int32Array:\n\t\t\tshouldTypeCast = internalType !== INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid array type: ${array.constructor.name} for GPULayer \"${name}\", please use one of [${validArrayTypes.map(constructor => constructor.name).join(', ')}].`);\n\t}\n\n\t// Get min and max values for internalType.\n\tconst { min, max } = minMaxValuesForType(internalType);\n\n\t// Then check if array needs to be lengthened.\n\t// This could be because glNumChannels !== numComponents or because length !== width * height.\n\tconst arrayLength = width * height * glNumChannels;\n\tconst shouldResize = array.length !== arrayLength;\n\t\t\n\tlet validatedArray = array as GPULayerArray;\n\tif (shouldTypeCast || shouldResize) {\n\t\tvalidatedArray = GPULayer.initArrayForType(internalType, arrayLength);\n\t\t// Fill new data array with old data.\n\t\t// We have to handle the case of Float16 specially by converting data to Uint16Array.\n\t\tconst view = (internalType === HALF_FLOAT && shouldTypeCast) ? new DataView(validatedArray.buffer) : null;\n\t\tfor (let i = 0, _len = array.length / numComponents; i < _len; i++) {\n\t\t\tfor (let j = 0; j < numComponents; j++) {\n\t\t\t\tconst origValue = array[i * numComponents + j];\n\t\t\t\tlet value = origValue;\n\t\t\t\tlet clipped = false;\n\t\t\t\tif (value < min) {\n\t\t\t\t\tvalue = min;\n\t\t\t\t\tclipped = true;\n\t\t\t\t} else if (value > max) {\n\t\t\t\t\tvalue = max;\n\t\t\t\t\tclipped = true;\n\t\t\t\t}\n\t\t\t\tif (clipped) {\n\t\t\t\t\tconsole.warn(`Clipping out of range value ${origValue} to ${value} for GPULayer \"${name}\" with internal type ${internalType}.`);\n\t\t\t\t}\n\t\t\t\tconst index = i * glNumChannels + j;\n\t\t\t\tif (view) {\n\t\t\t\t\tsetFloat16(view, 2 * index, value, true);\n\t\t\t\t} else {\n\t\t\t\t\tvalidatedArray[index] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn validatedArray;\n}","import type { GPUComposer } from './GPUComposer';\nimport {\n\tFLOAT_1D_UNIFORM,\n\tFLOAT_2D_UNIFORM,\n\tFLOAT_3D_UNIFORM,\n\tFLOAT_4D_UNIFORM,\n\tINT_1D_UNIFORM,\n\tINT_2D_UNIFORM,\n\tINT_3D_UNIFORM,\n\tINT_4D_UNIFORM,\n\tUniform,\n\tUniformType,\n\tUniformInternalType,\n\tUniformValue,\n\tCompileTimeConstants,\n\tPROGRAM_NAME_INTERNAL,\n\tUINT_1D_UNIFORM,\n\tUINT_2D_UNIFORM,\n\tUINT_3D_UNIFORM,\n\tUINT_4D_UNIFORM,\n\tUniformParams,\n\tBOOL_1D_UNIFORM,\n\tBOOL_2D_UNIFORM,\n\tBOOL_3D_UNIFORM,\n\tBOOL_4D_UNIFORM,\n\tGLSL3,\n\tGPULayerState,\n\tREPEAT,\n\tLINEAR,\n\tGLSL1,\n} from './constants';\nimport {\n\tcompileShader,\n\tpreprocessFragmentShader,\n\tinitGLProgram,\n\tuniformInternalTypeForValue,\n\tisIntType,\n} from './utils';\nimport {\n\tSAMPLER2D_CAST_INT,\n\tSAMPLER2D_DIMENSIONS_UNIFORM,\n\tSAMPLER2D_FILTER,\n\tSAMPLER2D_HALF_PX_UNIFORM,\n\tSAMPLER2D_WRAP_X,\n\tSAMPLER2D_WRAP_Y,\n} from './polyfills';\nimport {\n\tisArray,\n\tisBoolean,\n\tisFiniteNumber,\n\tisInteger,\n\tisNonNegativeInteger,\n\tisObject,\n\tisString,\n} from '@amandaghassaei/type-checks';\nimport { checkRequiredKeys, checkValidKeys } from './checks';\nimport { getExtension, OES_STANDARD_DERIVATIVES } from './extensions';\n\nexport class GPUProgram {\n\t// Keep a reference to GPUComposer.\n\tprivate readonly _composer: GPUComposer;\n\n\t/**\n\t * Name of GPUProgram, used for error logging.\n\t */\n\treadonly name: string;\n\n\t// Compiled fragment shaders (we hang onto different versions depending on compile time constants).\n\tprivate _fragmentShaders: {[key: string]: WebGLShader} = {};\n\t// Source code for fragment shader.\n\t// Hold onto this in case we need to recompile with different #defines.\n\tprotected _fragmentShaderSource!: string;\n\t// #define variables for fragment shader program.\n\tprivate readonly _compileTimeConstants: CompileTimeConstants = {};\n\t// #extension declarations for fragment shader program.\n\tprivate readonly _extensions?: string;\n\t// Uniform locations, values, and types.\n\tprivate readonly _uniforms: { [ key: string]: Uniform } = {};\n\n\t// Store WebGLProgram's - we need to compile several WebGLPrograms of GPUProgram.fragmentShader + various vertex shaders.\n\t// Each combination of vertex + fragment shader requires a separate WebGLProgram.\n\t// These programs are compiled on the fly as needed.\n\tprivate readonly _programs: {[key: string]: WebGLProgram } = {};\n\t// Reverse lookup for above.\n\tprivate readonly _programsKeyLookup = new WeakMap<WebGLProgram, string>();\n\n\t// Store the index of input sampler2D in input array.\n\tprotected readonly _samplerUniformsIndices: { name: string, inputIndex: number, shaderIndex: number }[] = [];\n\n\t/**\n\t * This is only used in cases where GLSL1 program has multiple outputs.\n\t * @private\n\t */\n\t_childPrograms?: GPUProgramChild[];\n\n\t/**\n\t * Create a GPUProgram.\n\t * @param composer - The current GPUComposer instance.\n\t * @param params - GPUProgram parameters.\n\t * @param params.name - Name of GPUProgram, used for error logging.\n\t * @param params.fragmentShader - Fragment shader source or array of sources to be joined.\n\t * @param params.uniforms - Array of uniforms to initialize with GPUProgram.  More uniforms can be added later with GPUProgram.setUniform().\n\t * @param params.compileTimeConstants - Compile time #define constants to include with fragment shader.\n\t */\n\tconstructor(\n\t\tcomposer: GPUComposer,\n\t\tparams: {\n\t\t\tname: string,\n\t\t\t// We may want to pass in an array of shader string sources, if split across several files.\n\t\t\tfragmentShader: string | string[],\n\t\t\tuniforms?: UniformParams[],\n\t\t\t// We'll allow some compile time constants to be passed in as #define to the preprocessor for the fragment shader.\n\t\t\tcompileTimeConstants?: CompileTimeConstants,\n\t\t},\n\t) {\n\t\t// Check constructor parameters.\n\t\tconst { name } = (params || {});\n\t\tif (!composer) {\n\t\t\tthrow new Error(`Error initing GPUProgram \"${name}\": must pass GPUComposer instance to GPUProgram(composer, params).`);\n\t\t}\n\t\tif (!params) {\n\t\t\tthrow new Error(`Error initing GPUProgram: must pass params to GPUProgram(composer, params).`);\n\t\t}\n\t\tif (!isObject(params)) {\n\t\t\tthrow new Error(`Error initing GPUProgram: must pass valid params object to GPUProgram(composer, params), got ${JSON.stringify(params)}.`);\n\t\t}\n\t\t// Check params keys.\n\t\tconst validKeys = ['name', 'fragmentShader', 'uniforms', 'compileTimeConstants'];\n\t\tconst requiredKeys = ['name', 'fragmentShader'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUProgram(composer, params)', params.name);\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUProgram(composer, params)', params.name);\n\n\t\tconst { fragmentShader, uniforms, compileTimeConstants } = params;\n\n\t\t// Save arguments.\n\t\tthis._composer = composer;\n\t\tthis.name = name;\n\n\t\t// Preprocess fragment shader source.\n\t\tconst fragmentShaderSource = isString(fragmentShader) ?\n\t\t\t\tfragmentShader as string :\n\t\t\t\t(fragmentShader as string[]).join('\\n');\n\t\tconst { shaderSource, samplerUniforms, additionalSources } = preprocessFragmentShader(\n\t\t\tfragmentShaderSource, composer.glslVersion, name,\n\t\t);\n\t\tthis._fragmentShaderSource = shaderSource;\n\n\t\tsamplerUniforms.forEach((name, i) => {\n\t\t\tthis._samplerUniformsIndices.push({\n\t\t\t\tname,\n\t\t\t\tinputIndex: 0, // All uniforms default to 0.\n\t\t\t\tshaderIndex: i,\n\t\t\t});\n\t\t});\n\t\tif (this.constructor === GPUProgram) { // This is not a child program.\n\t\t\tif (additionalSources) {\n\t\t\t\tthis._childPrograms = [];\n\t\t\t\tfor (let i = 0, numChildren = additionalSources.length; i < numChildren; i++) {\n\t\t\t\t\tthis._childPrograms.push(new GPUProgramChild(composer, params, { fragmentShaderSource: additionalSources[i] }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Save compile time constants.\n\t\tif (compileTimeConstants) {\n\t\t\tthis._compileTimeConstants = { ...compileTimeConstants };\n\t\t}\n\t\t// Save extension declarations.\n\t\tif (composer.glslVersion === GLSL1 && (shaderSource.includes('dFdx') ||shaderSource.includes('dFdy') || shaderSource.includes('fwidth'))) {\n\t\t\tconst ext = getExtension(composer, OES_STANDARD_DERIVATIVES, true);\n\t\t\tif (ext) this._extensions = '#extension GL_OES_standard_derivatives : enable\\n';\n\t\t}\n\n\t\t// Set program uniforms.\n\t\tif (uniforms) {\n\t\t\tfor (let i = 0; i < uniforms.length; i++) {\n\t\t\t\tconst { name, value, type } = uniforms[i];\n\t\t\t\tthis.setUniform(name, value, type);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Force compilation of GPUProgram with new compileTimeConstants.\n\t * @param compileTimeConstants - Compile time #define constants to include with fragment shader.\n\t */\n\trecompile(compileTimeConstants: CompileTimeConstants) {\n\t\tconst { _compileTimeConstants } = this;\n\t\t// Check if we have changed the compile-time constants.\n\t\t// compileTimeConstants may be a partial list.\n\t\tlet needsRecompile = false;\n\t\tObject.keys(compileTimeConstants).forEach(key => {\n\t\t\tif (_compileTimeConstants[key] !== compileTimeConstants[key]) {\n\t\t\t\tneedsRecompile = true;\n\t\t\t\t_compileTimeConstants[key] = compileTimeConstants[key];\n\t\t\t}\n\t\t});\n\t\tif (!needsRecompile) return;\n\t\tconst { \n\t\t\t_fragmentShaders,\n\t\t\t_programs,\n\t\t\t_programsKeyLookup,\n\t\t\t_composer,\n\t\t\t_uniforms,\n\t\t} = this;\n\t\tconst { gl } = _composer;\n\t\t// Delete cached compiled shaders and programs.\n\t\tconst programKeys = Object.keys(_programs);\n\t\tfor (let i = 0, numPrograms = programKeys.length; i < numPrograms; i++) {\n\t\t\tconst key = programKeys[i];\n\t\t\tconst program = _programs[key];\n\t\t\tgl.deleteProgram(program);\n\t\t\t_programsKeyLookup.delete(program);\n\t\t\tdelete _programs[key];\n\t\t}\n\t\tconst fragmentShaderKeys = Object.keys(_fragmentShaders);\n\t\tfor (let i = 0, numFragmentShaders = fragmentShaderKeys.length; i < numFragmentShaders; i++) {\n\t\t\tconst key = fragmentShaderKeys[i];\n\t\t\tgl.deleteShader(_fragmentShaders[key]);\n\t\t\tdelete _fragmentShaders[key];\n\t\t}\n\t\t// Delete all cached uniform locations.\n\t\tconst uniforms = Object.values(_uniforms);\n\t\tfor (let i = 0, numUniforms = uniforms.length; i < numUniforms; i++) {\n\t\t\tuniforms[i].location = new WeakMap();\n\t\t}\n\n\t\tif (this._childPrograms) {\n\t\t\tfor (let i = 0, numChildren = this._childPrograms.length; i < numChildren; i++) {\n\t\t\t\tthis._childPrograms[i].recompile(compileTimeConstants);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get fragment shader for GPUProgram, compile new one if needed.\n\t * Used internally.\n\t * @private\n\t */\n\tprivate _getFragmentShader(fragmentId: string, internalCompileTimeConstants: CompileTimeConstants, ) {\n\t\tconst { _fragmentShaders } = this;\n\t\tif (_fragmentShaders[fragmentId]) {\n\t\t\t// No need to recompile.\n\t\t\treturn _fragmentShaders[fragmentId];\n\t\t}\n\n\t\tconst { _composer, name, _fragmentShaderSource, _compileTimeConstants, _extensions } = this;\n\t\tconst {\n\t\t\tgl,\n\t\t\t_errorCallback,\n\t\t\tverboseLogging,\n\t\t\tglslVersion,\n\t\t\tfloatPrecision,\n\t\t\tintPrecision,\n\t\t} = _composer;\n\t\t\n\t\t// Update compile time constants.\n\t\tconst keys = Object.keys(internalCompileTimeConstants);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key = keys[i];\n\t\t\t_compileTimeConstants[key] = internalCompileTimeConstants[key];\n\t\t}\n\n\t\tif (verboseLogging) console.log(`Compiling fragment shader for GPUProgram \"${name}\" with compile time constants: ${JSON.stringify(_compileTimeConstants)}`);\n\t\tconst shader = compileShader(\n\t\t\tgl,\n\t\t\tglslVersion,\n\t\t\tintPrecision,\n\t\t\tfloatPrecision,\n\t\t\t_fragmentShaderSource,\n\t\t\tgl.FRAGMENT_SHADER,\n\t\t\tname,\n\t\t\t_errorCallback,\n\t\t\t_compileTimeConstants,\n\t\t\t_extensions,\n\t\t\tObject.keys(_fragmentShaders).length === 0,\n\t\t);\n\t\tif (!shader) {\n\t\t\t_errorCallback(`Unable to compile fragment shader for GPUProgram \"${name}\".`);\n\t\t\treturn;\n\t\t}\n\t\t_fragmentShaders[fragmentId] = shader;\n\t\treturn _fragmentShaders[fragmentId];\n\t}\n\n\t/**\n\t * Get GLProgram associated with a specific vertex shader.\n\t * @private\n\t */\n\t_getProgramWithName(name: PROGRAM_NAME_INTERNAL, vertexCompileConstants: CompileTimeConstants, input: GPULayerState[]) {\n\t\tconst { _samplerUniformsIndices, _composer } = this;\n\n\t\tlet fragmentID = '';\n\t\tconst fragmentCompileConstants: CompileTimeConstants = {};\n\t\tfor (let i = 0, length = _samplerUniformsIndices.length; i < length; i++) {\n\t\t\tconst { inputIndex } = _samplerUniformsIndices[i];\n\t\t\tconst { layer } = input[inputIndex];\n\t\t\tconst {\n\t\t\t\tfilter, wrapX, wrapY, type,\n\t\t\t\t_internalFilter, _internalWrapX, _internalWrapY,\n\t\t\t} = layer;\n\t\t\tconst wrapXVal = wrapX === _internalWrapX ? 0 : (wrapX === REPEAT ? 1 : 0);\n\t\t\tconst wrapYVal = wrapY === _internalWrapY ? 0 : (wrapY === REPEAT ? 1 : 0);\n\t\t\tconst filterVal = filter === _internalFilter ? 0 : (filter === LINEAR ? 1 : 0);\n\t\t\tfragmentID += `_IN${i}_${wrapXVal}_${wrapYVal}_${filterVal}`;\n\t\t\tfragmentCompileConstants[`${SAMPLER2D_WRAP_X}${i}`] = `${wrapXVal}`;\n\t\t\tfragmentCompileConstants[`${SAMPLER2D_WRAP_Y}${i}`] = `${wrapYVal}`;\n\t\t\tfragmentCompileConstants[`${SAMPLER2D_FILTER}${i}`] = `${filterVal}`;\n\t\t\tif (_composer.glslVersion === GLSL1 && isIntType(type)) {\n\t\t\t\tfragmentCompileConstants[`${SAMPLER2D_CAST_INT}${i}`] = '1';\n\t\t\t}\n\t\t}\n\t\tconst vertexID = Object.keys(vertexCompileConstants).map(key => `_${key}_${vertexCompileConstants[key]}`).join();\n\t\tconst key = `${name}${vertexID}${fragmentID}`;\n\n\t\t// Check if we've already compiled program.\n\t\tif (this._programs[key]) return this._programs[key];\n\n\t\t// Otherwise, we need to compile a new program on the fly.\n\t\tconst { _uniforms, _programs, _programsKeyLookup } = this;\n\t\tconst { gl, _errorCallback } = _composer;\n\n\t\tconst vertexShader = _composer._getVertexShader(name, vertexID, vertexCompileConstants, this.name);\n\t\tif (vertexShader === undefined) {\n\t\t\t_errorCallback(`Unable to init vertex shader \"${name}${vertexID}\" for GPUProgram \"${this.name}\".`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst fragmentShader = this._getFragmentShader(fragmentID, fragmentCompileConstants);\n\t\tif (fragmentShader === undefined) {\n\t\t\t_errorCallback(`Unable to init fragment shader \"${fragmentID}\" for GPUProgram \"${this.name}\".`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst program = initGLProgram(gl, vertexShader, fragmentShader, this.name, _errorCallback);\n\t\tif (program === undefined) {\n\t\t\tgl.deleteShader(fragmentShader);\n\t\t\t_errorCallback(`Unable to init program \"${key}\" for GPUProgram \"${this.name}\".`);\n\t\t\treturn;\n\t\t}\n\n\t\t// If we have any uniforms set for this GPUProgram, add those to WebGLProgram we just inited.\n\t\t// Set active program.\n\t\tgl.useProgram(program);\n\t\tconst uniformNames = Object.keys(_uniforms);\n\t\tfor (let i = 0, numUniforms = uniformNames.length; i < numUniforms; i++) {\n\t\t\tconst uniformName = uniformNames[i];\n\t\t\tconst uniform = _uniforms[uniformName];\n\t\t\tconst { value, type } = uniform;\n\t\t\tthis._setProgramUniform(program, uniformName, value, type);\n\t\t}\n\n\t\t_programs[key] = program;\n\t\t_programsKeyLookup.set(program, key);\n\t\treturn program;\n\t}\n\n\t/**\n\t * Set uniform for GLProgram.\n\t * @private\n\t */\n\tprivate _setProgramUniform(\n\t\tprogram: WebGLProgram,\n\t\tuniformName: string,\n\t\tvalue: UniformValue,\n\t\ttype: UniformInternalType,\n\t) {\n\t\tconst { _composer, _uniforms } = this;\n\t\tconst { gl, _errorCallback, glslVersion } = _composer;\n\n\t\t// We have already set gl.useProgram(program) outside this function.\n\n\t\tconst isGLSL3 = glslVersion === GLSL3;\n\n\t\tlet location = _uniforms[uniformName]?.location.get(program);\n\t\t// Init a location for WebGLProgram if needed (only do this once).\n\t\tif (location === undefined) {\n\t\t\tconst _location = gl.getUniformLocation(program, uniformName);\n\t\t\tif (_location === null) {\n\t\t\t\tconsole.warn(`Could not init uniform \"${uniformName}\" for program \"${this.name}\". Check that uniform is present in shader code, unused uniforms may be removed by compiler. Also check that uniform type in shader code matches type ${type}. Error code: ${gl.getError()}.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlocation = _location;\n\n\t\t\t// Save location for future use.\n\t\t\tif (_uniforms[uniformName]) {\n\t\t\t\t_uniforms[uniformName].location.set(program, location);\n\t\t\t}\n\n\t\t\t// Since this is the first time we are initing the uniform, check that type is correct.\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getUniform\n\t\t\tconst uniform = gl.getUniform(program, location);\n\t\t\tlet badType = false;\n\t\t\tif (type === BOOL_1D_UNIFORM || type === BOOL_2D_UNIFORM || type === BOOL_3D_UNIFORM || type === BOOL_4D_UNIFORM) {\n\t\t\t\tif (!isBoolean(uniform) && uniform.constructor !== Array) {\n\t\t\t\t\tbadType = true;\n\t\t\t\t}\n\t\t\t} else if (type === FLOAT_1D_UNIFORM || type === FLOAT_2D_UNIFORM || type === FLOAT_3D_UNIFORM || type === FLOAT_4D_UNIFORM) {\n\t\t\t\tif (!isFiniteNumber(uniform) && uniform.constructor !== Float32Array) {\n\t\t\t\t\tbadType = true;\n\t\t\t\t}\n\t\t\t} else if (type === INT_1D_UNIFORM || type === INT_2D_UNIFORM || type === INT_3D_UNIFORM || type === INT_4D_UNIFORM) {\n\t\t\t\tif (!isInteger(uniform) && uniform.constructor !== Int32Array) {\n\t\t\t\t\tbadType = true;\n\t\t\t\t}\n\t\t\t} else if (type === UINT_1D_UNIFORM || type === UINT_2D_UNIFORM || type === UINT_3D_UNIFORM || type === UINT_4D_UNIFORM) {\n\t\t\t\tif (!isGLSL3) {\n\t\t\t\t\t// GLSL1 does not have uint type, expect int instead.\n\t\t\t\t\tif (!isNonNegativeInteger(uniform) && uniform.constructor !== Int32Array) {\n\t\t\t\t\t\tbadType = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!isNonNegativeInteger(uniform) && uniform.constructor !== Uint32Array) {\n\t\t\t\t\tbadType = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (badType) {\n\t\t\t\t_errorCallback(`Invalid uniform \"${uniformName}\" for program \"${this.name}\". Check that uniform type in shader code matches type ${type}, gl.getUniform(program, location) returned type: ${uniform.constructor.name}.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Set uniform.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform\n\t\tswitch (type) {\n\t\t\t// We are setting boolean uniforms with uniform[1234]i.\n\t\t\t// This suggest floats work as well, but ints seem more natural:\n\t\t\t// https://github.com/KhronosGroup/WebGL/blob/main/sdk/tests/conformance/uniforms/gl-uniform-bool.html\n\t\t\tcase BOOL_1D_UNIFORM:\n\t\t\t\tgl.uniform1i(location, value ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase BOOL_2D_UNIFORM:\n\t\t\t\tgl.uniform2i(location, (value as number[])[0] ? 1 : 0, (value as number[])[1] ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase BOOL_3D_UNIFORM:\n\t\t\t\tgl.uniform3i(location, (value as number[])[0] ? 1 : 0, (value as number[])[1] ? 1 : 0, (value as number[])[2] ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase BOOL_4D_UNIFORM:\n\t\t\t\tgl.uniform4i(location, (value as number[])[0] ? 1 : 0, (value as number[])[1] ? 1 : 0, (value as number[])[2] ? 1 : 0, (value as number[])[3] ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase FLOAT_1D_UNIFORM:\n\t\t\t\tgl.uniform1f(location, value as number);\n\t\t\t\tbreak;\n\t\t\tcase FLOAT_2D_UNIFORM:\n\t\t\t\tgl.uniform2fv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase FLOAT_3D_UNIFORM:\n\t\t\t\tgl.uniform3fv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase FLOAT_4D_UNIFORM:\n\t\t\t\tgl.uniform4fv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase INT_1D_UNIFORM:\n\t\t\t\tgl.uniform1i(location, value as number);\n\t\t\t\tbreak;\n\t\t\tcase INT_2D_UNIFORM:\n\t\t\t\tgl.uniform2iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase INT_3D_UNIFORM:\n\t\t\t\tgl.uniform3iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase INT_4D_UNIFORM:\n\t\t\t\tgl.uniform4iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\t// Uint not supported in GLSL1, use int instead.\n\t\t\tcase UINT_1D_UNIFORM:\n\t\t\t\tif (isGLSL3) (gl as WebGL2RenderingContext).uniform1ui(location, value as number);\n\t\t\t\telse gl.uniform1i(location, value as number);\n\t\t\t\tbreak;\n\t\t\tcase UINT_2D_UNIFORM:\n\t\t\t\tif (isGLSL3) (gl as WebGL2RenderingContext).uniform2uiv(location, value as number[]);\n\t\t\t\telse gl.uniform2iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase UINT_3D_UNIFORM:\n\t\t\t\tif (isGLSL3) (gl as WebGL2RenderingContext).uniform3uiv(location, value as number[]);\n\t\t\t\telse gl.uniform3iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase UINT_4D_UNIFORM:\n\t\t\t\tif (isGLSL3) (gl as WebGL2RenderingContext).uniform4uiv(location, value as number[]);\n\t\t\t\telse gl.uniform4iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown uniform type ${type} for GPUProgram \"${this.name}\".`);\n\t\t}\n\t}\n\n\t/**\n\t * Cache uniform value and return whether the value has changed.\n\t * @private\n\t */\n\tprivate _cacheUniformValue(name: string, value: UniformValue, type: UniformInternalType) {\n\t\tconst { _uniforms } = this;\n\t\t// Cache uniform values.\n\t\tconst uniform = _uniforms[name];\n\t\tif (!uniform) {\n\t\t\t// Init uniform if needed.\n\t\t\t_uniforms[name] = { location: new WeakMap(), value: isArray(value) ? (value as number[]).slice() : value, type };\n\t\t\treturn true;\n\t\t}\n\t\tconst oldValue = uniform.value;\n\t\t// Update value with a deep copy of input.\n\t\tuniform.value = isArray(value) ? (value as number[]).slice() : value;\n\t\t// Deep check if value has changed.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0, length = (value as number[]).length; i < length; i++) {\n\t\t\t\tif ((value as number[])[i] !== (oldValue as number[])[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false; // No change.\n\t\t}\n\t\treturn value !== oldValue;\n\t}\n\n\t/**\n\t * Set fragment shader uniform for GPUProgram.\n\t * @param name - Uniform name as it appears in fragment shader.\n\t * @param value - Uniform value.\n\t * @param type - Uniform type.\n\t */\n\tsetUniform(\n\t\tname: string,\n\t\tvalue: UniformValue,\n\t\ttype?: UniformType,\n\t) {\n\t\tconst { _programs, _uniforms, _composer, _samplerUniformsIndices } = this;\n\t\tconst { verboseLogging, gl } = _composer;\n\n\t\t// Check that length of value is correct.\n\t\tif (isArray(value)) {\n\t\t\tconst length = (value as number[]).length;\n\t\t\tif (length > 4) throw new Error(`Invalid uniform value: [${(value as number[]).join(', ')}] passed to GPUProgram \"${this.name}, uniforms must be of type number[] with length <= 4, number, or boolean.\"`)\n\t\t}\n\n\t\t// Get uniform internal type.\n\t\tlet currentType = _uniforms[name]?.type;\n\t\tif (type) {\n\t\t\tconst internalType = uniformInternalTypeForValue(value, type, name, this.name);\n\t\t\tif (currentType === undefined) currentType = internalType;\n\t\t\telse {\n\t\t\t\t// console.warn(`Don't need to pass in type to GPUProgram.setUniform for previously inited uniform \"${uniformName}\"`);\n\t\t\t\t// Check that types match previously set uniform.\n\t\t\t\tif (currentType !== internalType) {\n\t\t\t\t\tthrow new Error(`Uniform \"${name}\" for GPUProgram \"${this.name}\" cannot change from type ${currentType} to type ${internalType}.`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (currentType === undefined) {\n\t\t\tthrow new Error(`Unknown type for uniform \"${name}\", please pass in type to GPUProgram.setUniform(name, value, type) when initing a new uniform.`);\n\t\t}\n\n\t\tconst changed = this._cacheUniformValue(name, value, currentType);\n\t\tif (!changed) return;\n\n\t\t// Cache user-defined sampler uniform values.\n\t\tconst samplerUniform = _samplerUniformsIndices.find((uniform) => uniform.name === name);\n\t\tif (samplerUniform && isInteger(value)) {\n\t\t\tsamplerUniform.inputIndex = value as number;\n\t\t}\n\n\t\tif (verboseLogging) console.log(`Setting uniform \"${name}\" for program \"${this.name}\" to value ${JSON.stringify(value)}.`)\n\n\t\t// Update any active programs.\n\t\tconst programNames = Object.keys(_programs);\n\t\tfor (let i = 0, numPrograms = programNames.length; i < numPrograms; i++) {\n\t\t\tconst programName = programNames[i];\n\t\t\t// Set active program.\n\t\t\tconst program = _programs[programName]!;\n\t\t\tgl.useProgram(program);\n\t\t\tthis._setProgramUniform(program, name, value, currentType);\n\t\t}\n\n\t\t// this code is only executed in cases where we have a shader program with multiple outputs in a WebGL1 context.\n\t\t// Notify all child programs of the setUniform.\n\t\tif (this._childPrograms) {\n\t\t\tfor (let i = 0, numChildren = this._childPrograms.length; i < numChildren; i++) {\n\t\t\t\tthis._childPrograms[i].setUniform(name, value, type);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Set internal fragment shader uniforms for GPUProgram.\n\t * @private\n\t */\n\t_setInternalFragmentUniforms(\n\t\tprogram: WebGLProgram,\n\t\tinput: GPULayerState[],\n\t) {\n\t\tif (input.length === 0) return;\n\t\tif (!program) {\n\t\t\tthrow new Error('Must pass in valid WebGLProgram to GPUProgram._setInternalFragmentUniforms, got undefined.');\n\t\t}\n\t\tconst { _programsKeyLookup, _samplerUniformsIndices } = this;\n\t\tconst programName = _programsKeyLookup.get(program);\n\t\tif (!programName) {\n\t\t\tthrow new Error(`Could not find valid programName for WebGLProgram in GPUProgram \"${this.name}\".`);\n\t\t}\n\n\t\tconst indexLookup = new Array(Math.max(input.length, _samplerUniformsIndices.length)).fill(-1);\n\t\tfor (let i = 0, length = _samplerUniformsIndices.length; i < length; i++) {\n\t\t\tconst { inputIndex, shaderIndex } = _samplerUniformsIndices[i];\n\t\t\tif (indexLookup[inputIndex] >= 0) {\n\t\t\t\t// There is an index collision, this should not happen.\n\t\t\t\tconsole.warn(`Found > 1 sampler2D uniforms at texture index ${inputIndex} for GPUProgram \"${this.name}\".`);\n\t\t\t} else {\n\t\t\t\tindexLookup[inputIndex] = shaderIndex;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, length = input.length; i < length; i++) {\n\t\t\tconst { layer } = input[i];\n\t\t\tconst { width, height } = layer;\n\t\t\tconst index = indexLookup[i];\n\t\t\tif (index < 0) continue;\n\t\t\tconst { filter, wrapX, wrapY, _internalFilter, _internalWrapX, _internalWrapY } = layer;\n\t\t\tconst filterMismatch = filter !== _internalFilter;\n\t\t\tif (filterMismatch || wrapX !== _internalWrapX || wrapY !== _internalWrapY) {\n\t\t\t\tconst halfPxSize = [0.5 / width, 0.5 / height];\n\t\t\t\tconst halfPxUniform = `${SAMPLER2D_HALF_PX_UNIFORM}${index}`;\n\t\t\t\tconst halfPxUniformChanged = this._cacheUniformValue(halfPxUniform, halfPxSize, FLOAT_2D_UNIFORM);\n\t\t\t\tif (halfPxUniformChanged) {\n\t\t\t\t\tthis._setProgramUniform(\n\t\t\t\t\t\tprogram,\n\t\t\t\t\t\thalfPxUniform,\n\t\t\t\t\t\thalfPxSize,\n\t\t\t\t\t\tFLOAT_2D_UNIFORM,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (filterMismatch) {\n\t\t\t\t\tconst dimensions = [width, height];\n\t\t\t\t\tconst dimensionsUniform = `${SAMPLER2D_DIMENSIONS_UNIFORM}${index}`;\n\t\t\t\t\tconst dimensionsUniformChanged = this._cacheUniformValue(dimensionsUniform, dimensions, FLOAT_2D_UNIFORM);\n\t\t\t\t\tif (dimensionsUniformChanged) {\n\t\t\t\t\t\tthis._setProgramUniform(\n\t\t\t\t\t\t\tprogram,\n\t\t\t\t\t\t\tdimensionsUniform,\n\t\t\t\t\t\t\tdimensions,\n\t\t\t\t\t\t\tFLOAT_2D_UNIFORM,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set vertex shader uniform for GPUProgram.\n\t * @private\n\t */\n\t_setVertexUniform(\n\t\tprogram: WebGLProgram,\n\t\tuniformName: string,\n\t\tvalue: UniformValue,\n\t\ttype: UniformType,\n\t) {\n\t\tif (!program) {\n\t\t\tthrow new Error('Must pass in valid WebGLProgram to GPUProgram._setVertexUniform, got undefined.');\n\t\t}\n\t\tconst { _programsKeyLookup } = this;\n\t\tconst programName = _programsKeyLookup.get(program);\n\t\tif (!programName) {\n\t\t\tthrow new Error(`Could not find valid programName for WebGLProgram in GPUProgram \"${this.name}\".`);\n\t\t}\n\t\tconst internalType = uniformInternalTypeForValue(value, type, uniformName, this.name);\n\t\t// const changed = this._cacheUniformValue(uniformName, value, internalType);\n\t\t// Don't cache vertex uniforms for now.\n\t\t// TODO: cached vertex uniforms need to be stored per WebGLProgram.\n\t\tthis._setProgramUniform(program, uniformName, value, internalType);\n\t}\n\n\t/**\n\t * Deallocate GPUProgram instance and associated WebGL properties.\n\t */\n\tdispose() {\n\t\tconst { _composer, _fragmentShaders, _programs, _programsKeyLookup } = this;\n\t\tconst { gl, verboseLogging } = _composer;\n\n\t\tif (verboseLogging) console.log(`Deallocating GPUProgram \"${this.name}\".`);\n\t\tif (!gl) throw new Error(`Must call dispose() on all GPUPrograms before calling dispose() on GPUComposer.`);\n\n\t\t// Unbind all gl data before deleting.\n\t\tObject.values(_programs).forEach(program => {\n\t\t\tif (program) {\n\t\t\t\tgl.deleteProgram(program);\n\t\t\t\t_programsKeyLookup.delete(program);\n\t\t\t}\n\t\t});\n\t\tObject.keys(_programs).forEach(key => {\n\t\t\tdelete _programs[key as PROGRAM_NAME_INTERNAL];\n\t\t});\n\n\t\t// Delete fragment shaders.\n\t\tObject.values(_fragmentShaders).forEach(shader => {\n\t\t\tgl.deleteShader(shader);\n\t\t});\n\t\tObject.keys(_fragmentShaders).forEach(key => {\n\t\t\tdelete _fragmentShaders[key];\n\t\t});\n\n\t\tif (this._childPrograms) {\n\t\t\tfor (let i = 0, numChildren = this._childPrograms.length; i < numChildren; i++) {\n\t\t\t\tthis._childPrograms[i].dispose();\n\t\t\t}\n\t\t\tthis._childPrograms.length;\n\t\t}\n\t\tdelete this._childPrograms;\n\t\t\n\t\t// Vertex shaders are owned by GPUComposer and shared across many GPUPrograms.\n\n\t\t// Delete all references.\n\t\t// @ts-ignore\n\t\tdelete this._composer;\n\t\t// @ts-ignore\n\t\tdelete this.name;\n\t\t// @ts-ignore\n\t\tdelete this._fragmentShaderSource;\n\t\t// @ts-ignore\n\t\tdelete this._compileTimeConstants;\n\t\t// @ts-ignore\n\t\tdelete this._extensions;\n\t\t// @ts-ignore\n\t\tdelete this._uniforms;\n\t\t// @ts-ignore\n\t\tdelete this._programs;\n\t\t// @ts-ignore\n\t\tdelete this._programsKeyLookup;\n\t\t// @ts-ignore\n\t\tdelete this._fragmentShaders;\n\t\t// @ts-ignore\n\t\tdelete this._samplerUniformsIndices;\n\t}\n}\n\nclass GPUProgramChild extends GPUProgram {\n\tconstructor(\n\t\tcomposer: GPUComposer,\n\t\tparams: {\n\t\t\tname: string,\n\t\t\t// We may want to pass in an array of shader string sources, if split across several files.\n\t\t\tfragmentShader: string | string[],\n\t\t\tuniforms?: UniformParams[],\n\t\t\t// We'll allow some compile time constants to be passed in as #define to the preprocessor for the fragment shader.\n\t\t\tcompileTimeConstants?: CompileTimeConstants,\n\t\t},\n\t\t_gpuio_child_params: {\n\t\t\tfragmentShaderSource: string,\n\t\t},\n\t) {\n\t\tsuper(composer, params);\n\n\t\tconst { fragmentShaderSource } = _gpuio_child_params;\n\t\t// fragmentShader has already been pre-processed.\n\t\tthis._fragmentShaderSource = fragmentShaderSource;\n\t}\n}","import { isArray } from '@amandaghassaei/type-checks';\nimport {\n\tFLOAT,\n\tGLSLPrecision,\n\tGPULayerNumComponents,\n\tGPULayerType,\n\tINT,\n} from './constants';\nimport {\n\tglslComponentSelectionForNumComponents,\n\tglslPrefixForType,\n\tglslTypeForType,\n\tuniformTypeForType,\n} from './conversions';\nimport type { GPUComposer } from './GPUComposer';\nimport { GPUProgram } from './GPUProgram';\n\n/**\n * Init GPUProgram to copy contents of one GPULayer to another GPULayer.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input/output.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the input/output.\n * @returns\n */\nexport function copyProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst glslType = glslTypeForType(type, 4);\n\tconst name = params.name ||`copy_${uniformTypeForType(type, composer.glslVersion)}_layer`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform ${precision} ${glslPrefixForType(type)}sampler2D u_state;\nout ${precision} ${glslType} out_result;\nvoid main() {\n\tout_result = texture(u_state, v_uv);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to add several GPULayers together.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the inputs/output.\n * @param params.components - Component(s) of inputs to add, defaults to 'xyzw.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.numInputs - The number of inputs to add together, defaults to 2.\n * @param params.precision - Optionally specify the precision of the inputs/output.\n * @returns\n */\n export function addLayersProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tcomponents?: string,\n\tname?: string,\n\tnumInputs?: number,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst numInputs = params.numInputs || 2;\n\tconst precision = params.precision || '';\n\tconst components = params.components || 'xyzw';\n\tconst glslType = glslTypeForType(type, components.length as GPULayerNumComponents);\n\tconst arrayOfLengthNumInputs = new Array(numInputs);\n\tconst name = params.name || `${numInputs}-way_add_${uniformTypeForType(type, composer.glslVersion)}_${components}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\n${ arrayOfLengthNumInputs.map((el, i) => `uniform ${precision} ${glslPrefixForType(type)}sampler2D u_state${i};`).join('\\n') }\nout ${precision} ${glslType} out_result;\nvoid main() {\n\tout_result = ${ arrayOfLengthNumInputs.map((el, i) => `texture(u_state${i}, v_uv).${components}`).join(' + ') };\n}`,\n\t\tuniforms: arrayOfLengthNumInputs.map((el, i) => {\n\t\t\treturn {\n\t\t\t\tname: `u_state${i}`,\n\t\t\t\tvalue: i,\n\t\t\t\ttype: INT,\n\t\t\t};\n\t\t}),\n\t});\n}\n\n/**\n * Init GPUProgram to add uniform \"u_value\" to a GPULayer.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input/output (we assume \"u_value\" has the same type).\n * @param params.value - Initial value to add, if value has length 1 it will be applied to all components of GPULayer.  Change this later using uniform \"u_value\".\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the input/output/\"u_value\".\n * @returns\n */\n export function addValueProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tvalue: number | number[],\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type, value } = params;\n\tconst precision = params.precision || '';\n\tconst valueLength = isArray(value) ? (value as number[]).length : 1;\n\tconst valueType = glslTypeForType(type, valueLength as GPULayerNumComponents);\n\tconst numComponents = valueLength === 1 ? 4 : valueLength;\n\tconst outputType = glslTypeForType(type, numComponents as GPULayerNumComponents);\n\tconst componentSelection = glslComponentSelectionForNumComponents(numComponents as GPULayerNumComponents);\n\tconst name = params.name || `addValue_${valueType}_w_length_${valueLength}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform ${precision} ${valueType} u_value;\nuniform ${precision} ${glslPrefixForType(type)}sampler2D u_state;\nout ${precision} ${outputType} out_result;\nvoid main() {\n\tout_result = ${valueType !== outputType ? outputType : ''}(u_value) + texture(u_state, v_uv)${componentSelection};\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_value',\n\t\t\t\tvalue,\n\t\t\t\ttype: uniformTypeForType(type, composer.glslVersion),\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to multiply uniform \"u_value\" to a GPULayer.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input/output (we assume \"u_value\" has the same type).\n * @param params.value - Initial value to multiply, if value has length 1 it will be applied to all components of GPULayer.  Change this later using uniform \"u_value\".\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the input/output/\"u_value\".\n * @returns\n */\n export function multiplyValueProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tvalue: number | number[],\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type, value } = params;\n\tconst precision = params.precision || '';\n\tconst valueLength = isArray(value) ? (value as number[]).length : 1;\n\tconst valueType = glslTypeForType(type, valueLength as GPULayerNumComponents);\n\tconst numComponents = valueLength === 1 ? 4 : valueLength;\n\tconst outputType = glslTypeForType(type, numComponents as GPULayerNumComponents);\n\tconst componentSelection = glslComponentSelectionForNumComponents(numComponents as GPULayerNumComponents);\n\tconst name = params.name || `addValue_${valueType}_w_length_${valueLength}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform ${precision} ${valueType} u_value;\nuniform ${precision} ${glslPrefixForType(type)}sampler2D u_state;\nout ${precision} ${outputType} out_result;\nvoid main() {\n\tout_result = ${valueType !== outputType ? outputType : ''}(u_value) * texture(u_state, v_uv)${componentSelection};\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_value',\n\t\t\t\tvalue,\n\t\t\t\ttype: uniformTypeForType(type, composer.glslVersion),\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to set all elements in a GPULayer to uniform \"u_value\".\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the output (we assume \"u_value\" has same type).\n * @param params.value - Initial value to set, if value has length 1 it will be applied to all components of GPULayer.  Change this later using uniform \"u_value\".\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the output/\"u_value\".\n * @returns\n */\nexport function setValueProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tvalue: number | number[],\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type, value } = params;\n\tconst precision = params.precision || '';\n\tconst valueLength = isArray(value) ? (value as number[]).length : 1;\n\tconst valueType = glslTypeForType(type, valueLength as GPULayerNumComponents);\n\tconst numComponents = valueLength === 1 ? 4 : valueLength;\n\tconst outputType = glslTypeForType(type, numComponents as GPULayerNumComponents);\n\tconst name = params.name || `setValue_${valueType}_w_length_${valueLength}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nuniform ${precision} ${valueType} u_value;\nout ${precision} ${outputType} out_result;\nvoid main() {\n\tout_result = ${valueType !== outputType ? outputType : ''}(u_value);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_value',\n\t\t\t\tvalue,\n\t\t\t\ttype: uniformTypeForType(type, composer.glslVersion),\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to set all elements in a GPULayer to uniform \"u_value\".\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the output.\n * @param params.color - Initial color as RGB in range [0, 1], defaults to [0, 0, 0].  Change this later using uniform \"u_color\".\n * @param params.opacity - Initial opacity in range [0, 1], defaults to 1.  Change this later using uniform \"u_opacity\".\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the output/uniforms.\n * @returns\n */\n export function setColorProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tcolor?: number[],\n\topacity?: number,\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst opacity = params.opacity === undefined ? 1 : params.opacity;\n\tconst color = params.color || [0, 0, 0];\n\tconst name = params.name || `setColor`;\n\tconst glslType = glslTypeForType(type, 4);\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nuniform ${precision} vec3 u_color;\nuniform ${precision} float u_opacity;\nout ${precision} ${glslType} out_result;\nvoid main() {\n\tout_result = ${glslType}(u_color, u_opacity);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_color',\n\t\t\t\tvalue: color,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_opacity',\n\t\t\t\tvalue: opacity,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to zero output GPULayer.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @returns\n */\n export function zeroProgram(composer: GPUComposer, params: {\n\tname?: string,\n}) {\n\treturn setValueProgram(composer, {\n\t\ttype: FLOAT,\n\t\tvalue: 0,\n\t\tname: params.name,\n\t});\n}\n\n\n/**\n * Init GPUProgram to render 3 component GPULayer as RGB.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.scale - Scaling factor, defaults to 1.  Change this later using uniform \"u_scale\".\n * @param params.opacity - Opacity, defaults to 1.  Change this later using uniform \"u_opacity\".\n * @param params.precision - Optionally specify the precision of the input.\n * @returns\n */\n export function renderRGBProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tname?: string,\n\tscale?: number,\n\topacity?: number,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst numComponents = 3;\n\tconst glslType = glslTypeForType(type, numComponents);\n\tconst glslFloatType = glslTypeForType(FLOAT, numComponents);\n\tconst glslPrefix = glslPrefixForType(type);\n\tconst shouldCast = glslFloatType === glslType;\n\tconst name = params.name || `renderRGB_${glslType}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform float u_opacity;\nuniform float u_scale;\nuniform ${precision} ${glslPrefix}sampler2D u_state;\nout vec4 out_result;\nvoid main() {\n\tvec3 color = u_scale * (${shouldCast ? '' : glslFloatType}(texture(u_state, v_uv).rgb));\n\tout_result = vec4(color, u_opacity);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_scale',\n\t\t\t\tvalue: params.scale !== undefined ? params.scale : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_opacity',\n\t\t\t\tvalue: params.opacity !== undefined ? params.opacity : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to render RGBA amplitude of an input GPULayer's components, defaults to grayscale rendering and works for scalar and vector fields.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input.\n * @param params.components - Component(s) of input GPULayer to render, defaults to 'xyzw'.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.scale - Scaling factor, defaults to 1.  Change this later using uniform \"u_scale\".\n * @param params.opacity - Opacity, defaults to 1.  Change this later using uniform \"u_opacity\".\n * @param params.colorMax - RGB color for amplitude === scale, scaled to [0,1] range, defaults to white.  Change this later using uniform \"u_colorMax\".\n * @param params.colorMin - RGB color for amplitude === 0, scaled to [0,1] range, defaults to black.  Change this later using uniform \"u_colorMin\".\n * @param params.precision - Optionally specify the precision of the input.\n * @returns\n */\n export function renderAmplitudeProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tcomponents?: string,\n\tname?: string,\n\tscale?: number,\n\topacity?: number,\n\tcolorMax?: number[],\n\tcolorMin?: number[],\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst components = params.components || 'xyzw';\n\tconst numComponents = components.length as GPULayerNumComponents;\n\tconst glslType = glslTypeForType(type, numComponents);\n\tconst glslFloatType = glslTypeForType(FLOAT, numComponents);\n\tconst glslPrefix = glslPrefixForType(type);\n\tconst shouldCast = glslFloatType === glslType;\n\tconst name = params.name || `renderAmplitude_${glslType}_w_${numComponents}_components`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform float u_opacity;\nuniform float u_scale;\nuniform vec3 u_colorMax;\nuniform vec3 u_colorMin;\nuniform ${precision} ${glslPrefix}sampler2D u_state;\nout vec4 out_result;\nvoid main() {\n\tfloat amplitude = u_scale * ${ numComponents === 1 ? 'abs' : 'length'}(${shouldCast ? '' : glslFloatType}(texture(u_state, v_uv)${components === 'xyzw' || components === 'rgba' || components === 'stpq' ? '' : `.${components}`}));\n\tvec3 color = mix(u_colorMin, u_colorMax, amplitude);\n\tout_result = vec4(color, u_opacity);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_scale',\n\t\t\t\tvalue: params.scale !== undefined ? params.scale : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_opacity',\n\t\t\t\tvalue: params.opacity !== undefined ? params.opacity : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorMax',\n\t\t\t\tvalue: params.colorMax || [1, 1, 1],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorMin',\n\t\t\t\tvalue: params.colorMin || [0, 0, 0],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to render signed amplitude of an input GPULayer to linearly interpolated colors.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.scale - Scaling factor, defaults to 1.  Change this later using uniform \"u_scale\".\n * @param params.bias - Bias for center point of color range, defaults to 0.  Change this later using uniform \"u_bias\".\n * @param params.opacity - Opacity, defaults to 1.  Change this later using uniform \"u_opacity\".\n * @param params.colorMax - RGB color for amplitude === bias + scale, scaled to [0,1] range, defaults to red.  Change this later using uniform \"u_colorMax\".\n * @param params.colorMin - RGB color for amplitude === bias + scale, scaled to [0,1] range, defaults to blue.  Change this later using uniform \"u_colorMin\".\n * @param params.colorCenter - RGB color for amplitude === bias, scaled to [0,1] range, defaults to white.  Change this later using uniform \"u_colorCenter\".\n * @param params.component - Component of input GPULayer to render, defaults to \"x\".\n * @param params.precision - Optionally specify the precision of the input.\n * @returns\n */\n export function renderSignedAmplitudeProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tcomponent?: 'x' | 'y' | 'z' | 'w',\n\tname?: string,\n\tscale?: number,\n\tbias?: number,\n\topacity?: number,\n\tcolorMax?: number[],\n\tcolorMin?: number[],\n\tcolorCenter?: number[],\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst glslType = glslTypeForType(type, 1);\n\tconst glslPrefix = glslPrefixForType(type);\n\tconst castFloat = glslType === 'float';\n\tconst component = params.component || 'x';\n\tconst name = params.name || `renderAmplitude_${glslType}_${component}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform float u_opacity;\nuniform float u_scale;\nuniform float u_bias;\nuniform vec3 u_colorMin;\nuniform vec3 u_colorMax;\nuniform vec3 u_colorCenter;\nuniform ${precision} ${glslPrefix}sampler2D u_state;\nout vec4 out_result;\nvoid main() {\n\tfloat signedAmplitude = u_scale * (${castFloat ? '' : 'float'}(texture(u_state, v_uv).${component}) - u_bias);\n\tfloat amplitudeSign = sign(signedAmplitude);\n\tvec3 interpColor = mix(u_colorMin, u_colorMax, amplitudeSign / 2.0 + 0.5);\n\tvec3 color = mix(u_colorCenter, interpColor, signedAmplitude * amplitudeSign);\n\tout_result = vec4(color, u_opacity);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_scale',\n\t\t\t\tvalue: params.scale !== undefined ? params.scale : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_bias',\n\t\t\t\tvalue: params.bias || 0,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_opacity',\n\t\t\t\tvalue: params.opacity !== undefined ? params.opacity : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorMin',\n\t\t\t\tvalue: params.colorMin || [0, 0, 1],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorMax',\n\t\t\t\tvalue: params.colorMax || [1, 0, 0],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorCenter',\n\t\t\t\tvalue: params.colorCenter || [1, 1, 1],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * @private\n */\nexport function wrappedLineColorProgram(composer: GPUComposer) {\n\treturn new GPUProgram(composer, {\n\t\tname: `wrappedLineColor`,\n\t\tfragmentShader: `\nin vec2 v_lineWrapping;\nuniform vec4 u_value;\nout vec4 out_result;\nvoid main() {\n\t// Check if this line has wrapped.\n\tif ((v_lineWrapping.x != 0.0 && v_lineWrapping.x != 1.0) || (v_lineWrapping.y != 0.0 && v_lineWrapping.y != 1.0)) {\n\t\t// Render nothing.\n\t\tdiscard;\n\t\treturn;\n\t}\n\tout_result = vec4(u_value);\n}`,\n\t});\n}\n","/**\n * These are the parts of threejs Vector4 that we need.\n * Used internally.\n * @private\n */\nexport class Vector4 {\n\tx: number;\n\ty: number;\n\tz: number;\n\tw: number;\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t}\n\tget width() {\n\t\treturn this.z;\n\t}\n\tget height() {\n\t\treturn this.w;\n\t}\n\tcopy(v: Vector4) {\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = v.w;\n\t\treturn this;\n\t}\n}","import {\n\tisArray,\n\tisFiniteNumber,\n\tisInteger,\n\tisNonNegativeInteger,\n} from '@amandaghassaei/type-checks';\nimport {\n\tvalidDataTypes,\n\tvalidFilters,\n\tvalidWraps,\n\tGPULayerType,\n\tHALF_FLOAT,\n\tFLOAT,\n\tBYTE,\n\tSHORT,\n\tINT,\n\tUNSIGNED_BYTE,\n\tUNSIGNED_SHORT,\n\tUNSIGNED_INT,\n\tvalidImageFormats,\n\tvalidImageTypes,\n} from './constants';\n\n/**\n * Checks if type is valid GPULayer data type.\n * @private\n */\nexport function isValidDataType(type: string) {\n\treturn validDataTypes.indexOf(type) > -1;\n}\n\n/**\n * Checks if filter is valid GPULayer filter type.\n * @private\n */\nexport function isValidFilter(type: string) {\n\treturn validFilters.indexOf(type) > -1;\n}\n\n/**\n * Checks if wrap is valid GPULayer wrap type.\n * @private\n */\nexport function isValidWrap(type: string) {\n\treturn validWraps.indexOf(type) > -1;\n}\n\n/**\n * For image urls that are passed in and inited as GPULayers.\n * @private\n */\nexport function isValidImageFormat(type: string) {\n\treturn validImageFormats.indexOf(type) > -1;\n}\n/**\n * For image urls that are passed in and inited as GPULayers.\n * @private\n */\nexport function isValidImageType(type: string) {\n\treturn validImageTypes.indexOf(type) > -1;\n}\n\n/**\n * Checks if value is valid GPULayer clear value for numComponents and type.\n * @private\n */\nexport function isValidClearValue(clearValue: number | number[], numComponents: number, type: GPULayerType) {\n\tif (isArray(clearValue)) {\n\t\t// Length of clearValue must match numComponents.\n\t\tif ((clearValue as number[]).length !== numComponents) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < (clearValue as number[]).length; i++) {\n\t\t\tif (!isNumberOfType((clearValue as number[])[i], type)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!isNumberOfType(clearValue, type)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Checks if value is valid number for a given GPULayer type.\n * Checks extrema values.\n * @private\n */\nexport function isNumberOfType(value: any, type: GPULayerType) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\tcase FLOAT:\n\t\t\treturn isFiniteNumber(value);\n\t\tcase BYTE:\n\t\t\t// -(2 ** 7)\n\t\t\tif (value < -128) return false;\n\t\t\t// 2 ** 7 - 1\n\t\t\tif (value > 127) return false;\n\t\t\treturn isInteger(value);\n\t\tcase SHORT:\n\t\t\t// -(2 ** 15)\n\t\t\tif (value < -32768) return false;\n\t\t\t// 2 ** 15 - 1\n\t\t\tif (value > 32767) return false;\n\t\t\treturn isInteger(value);\n\t\tcase INT:\n\t\t\t// -(2 ** 31)\n\t\t\tif (value < -2147483648) return false;\n\t\t\t// 2 ** 31 - 1\n\t\t\tif (value > 2147483647) return false;\n\t\t\treturn isInteger(value);\n\t\tcase UNSIGNED_BYTE:\n\t\t\t// 2 ** 8 - 1\n\t\t\tif (value > 255) return false;\n\t\t\treturn isNonNegativeInteger(value);\n\t\tcase UNSIGNED_SHORT:\n\t\t\t// 2 ** 16 - 1\n\t\t\tif (value > 65535) return false;\n\t\t\treturn isNonNegativeInteger(value);\n\t\tcase UNSIGNED_INT:\n\t\t\t// 2 ** 32 - 1\n\t\t\tif (value > 4294967295) return false;\n\t\t\treturn isNonNegativeInteger(value);\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown type ${type}`);\n\t}\n}\n\nexport function checkValidKeys(keys: string[], validKeys: string[], methodName: string, name?: string) {\n\tkeys.forEach(key => {\n\t\tif (validKeys.indexOf(key) < 0) {\n\t\t\tconsole.warn(`Invalid params key \"${key}\" passed to ${methodName}${name ? ` with name \"${name}\"` : ''}.  Valid keys are ${JSON.stringify(validKeys)}.`);\n\t\t}\n\t});\n}\n\nexport function checkRequiredKeys(keys: string[], requiredKeys: string[], methodName: string, name?: string) {\n\trequiredKeys.forEach(key => {\n\t\tif (keys.indexOf(key) < 0) {\n\t\t\tthrow new Error(`Required params key \"${key}\" was not passed to ${methodName}${name ? ` with name \"${name}\"` : ''}.`);\n\t\t}\n\t});\n}","import type { GPULayer } from './GPULayer';\n\n// Data types and constants.\n\n/**\n * Half float data type.\n */\nexport const HALF_FLOAT = 'HALF_FLOAT';\n/**\n * Float data type.\n */\nexport const FLOAT = 'FLOAT';\n/**\n * Unsigned byte data type.\n */\nexport const UNSIGNED_BYTE = 'UNSIGNED_BYTE';\n/**\n * Byte data type.\n */\nexport const BYTE = 'BYTE';\n/**\n * Unsigned short data type.\n */\nexport const UNSIGNED_SHORT = 'UNSIGNED_SHORT';\n/**\n * Short data type.\n */\nexport const SHORT = 'SHORT';\n/**\n * Unsigned int data type.\n */\nexport const UNSIGNED_INT = 'UNSIGNED_INT';\n/**\n * Int data type.\n */\nexport const INT = 'INT';\n/**\n * Boolean data type (GPUProgram uniforms only).\n */\nexport const BOOL = 'BOOL';\n/**\n * Unsigned int data type (GPUProgram uniforms only).\n */\nexport const UINT = 'UINT';\n\n// Filter types.\n/**\n * Nearest texture filtering.\n */\nexport const NEAREST = 'NEAREST';\n/**\n * Linear texture filtering.\n */\nexport const LINEAR = 'LINEAR';\n\n// Wrap types.\n/**\n * Clamp to edge wrapping (no wrapping).\n */\nexport const CLAMP_TO_EDGE = 'CLAMP_TO_EDGE';\n/**\n * Repeat/periodic wrapping.\n */\nexport const REPEAT = 'REPEAT';\n// export const MIRRORED_REPEAT = 'MIRRORED_REPEAT';\n\n// GPULayer parameter types.\n/**\n * GPULayer array types.\n */\nexport type GPULayerArray =  Float32Array | Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array;\n/**\n * @private\n */\nexport const validArrayTypes = [Float32Array, Uint8Array, Int8Array, Uint16Array, Int16Array, Uint32Array, Int32Array, Array];\n/**\n * GPULayer data types.\n */\nexport type GPULayerType = typeof HALF_FLOAT | typeof FLOAT | typeof UNSIGNED_BYTE | typeof BYTE | typeof UNSIGNED_SHORT | typeof SHORT | typeof UNSIGNED_INT | typeof INT;\n/**\n * @private\n */\nexport const validDataTypes = [HALF_FLOAT, FLOAT, UNSIGNED_BYTE, BYTE, UNSIGNED_SHORT, SHORT, UNSIGNED_INT, INT];\n/**\n * GPULayer numComponents options.\n */\nexport type GPULayerNumComponents = 1 | 2 | 3 | 4;\n/**\n * GPULayer filter/interpolation types.\n */\nexport type GPULayerFilter = typeof LINEAR | typeof NEAREST;\n/**\n * @private\n */\nexport const validFilters = [NEAREST, LINEAR];\n/**\n * @private\n */\n/**\n * GPULayer wrap types.\n */\nexport type GPULayerWrap = typeof REPEAT | typeof CLAMP_TO_EDGE;// | typeof MIRRORED_REPEAT;\n/**\n * @private\n */\nexport const validWraps = [CLAMP_TO_EDGE, REPEAT]; // MIRRORED_REPEAT\n/**\n * The WebGLTexture corresponding to a GPULayer buffer (e.g. currentState or lastState).\n * This data structure also includes a reference back to the GPULayer that it originated from.\n */\nexport type GPULayerState = {\n\ttexture: WebGLTexture,\n\tlayer: GPULayer,\n}\n\n// For image urls that are passed in and inited as textures.\n/**\n * RGB image format.\n */\nexport const RGB = 'RGB';\n/**\n * RGBA image format.\n */\nexport const RGBA = 'RGBA';\n/**\n * Image formats for GPULayer.initFromImage().\n */\nexport type ImageFormat = typeof RGB | typeof RGBA;\n/**\n * Image types for GPULayer.initFromImage().\n */\n export type ImageType = typeof UNSIGNED_BYTE | typeof FLOAT | typeof HALF_FLOAT;\n/**\n * @private\n */\nexport const validImageFormats = [RGB, RGBA];\n/**\n * @private\n */\n export const validImageTypes = [UNSIGNED_BYTE, FLOAT, HALF_FLOAT];\n\n// GLSL versions.\n/**\n * GLSL version 300 (WebGL2 only).\n */\nexport const GLSL3 = '300 es';\n/**\n * GLSL version 100 (WebGL1 and WebGL2).\n */\nexport const GLSL1 = '100';\n/**\n * GLSL available versions.\n */\nexport type GLSLVersion = typeof GLSL1 | typeof GLSL3;\n\n// WebGL versions.\n/**\n * WebGL2 context ID.\n */\nexport const WEBGL2 = 'webgl2';\n/**\n * WebGL1 context ID.\n */\nexport const WEBGL1 = 'webgl';\n/**\n * Experimental WebGL context ID.\n */\nexport const EXPERIMENTAL_WEBGL = 'experimental-webgl';\n/**\n * Experimental WebGL context ID.\n */\n export const EXPERIMENTAL_WEBGL2 = 'experimental-webgl2';\n\n// Precision declarations.\n/**\n * GLSL lowp precision declaration.\n */\nexport const PRECISION_LOW_P = 'lowp';\n/**\n * GLSL mediump precision declaration.\n */\nexport const PRECISION_MEDIUM_P = 'mediump';\n/**\n * GLSL highp precision declaration.\n */\nexport const PRECISION_HIGH_P = 'highp';\n/**\n * GLSL available precision declarations.\n */\nexport type GLSLPrecision = typeof PRECISION_LOW_P | typeof PRECISION_MEDIUM_P | typeof PRECISION_HIGH_P;\n\n// Uniform types.\n/**\n * @private\n */\nexport const FLOAT_1D_UNIFORM = 'FLOAT_1D_UNIFORM';\n/**\n * @private\n */\nexport const FLOAT_2D_UNIFORM = 'FLOAT_2D_UNIFORM';\n/**\n * @private\n */\nexport const FLOAT_3D_UNIFORM = 'FLOAT_3D_UNIFORM';\n/**\n * @private\n */\nexport const FLOAT_4D_UNIFORM = 'FLOAT_4D_UNIFORM';\n/**\n * @private\n */\nexport const INT_1D_UNIFORM = 'INT_1D_UNIFORM';\n/**\n * @private\n */\nexport const INT_2D_UNIFORM = 'INT_2D_UNIFORM';\n/**\n * @private\n */\nexport const INT_3D_UNIFORM = 'INT_3D_UNIFORM';\n/**\n * @private\n */\nexport const INT_4D_UNIFORM = 'INT_4D_UNIFORM';\n/**\n * @private\n */\nexport const UINT_1D_UNIFORM = 'UINT_1D_UNIFORM';\n/**\n * @private\n */\nexport const UINT_2D_UNIFORM = 'UINT_2D_UNIFORM';\n/**\n * @private\n */\nexport const UINT_3D_UNIFORM = 'UINT_3D_UNIFORM';\n/**\n * @private\n */\nexport const UINT_4D_UNIFORM = 'UINT_4D_UNIFORM';\n/**\n * @private\n */\n export const BOOL_1D_UNIFORM = 'BOOL_1D_UNIFORM';\n /**\n * @private\n */\n  export const BOOL_2D_UNIFORM = 'BOOL_2D_UNIFORM';\n  /**\n * @private\n */\n export const BOOL_3D_UNIFORM = 'BOOL_3D_UNIFORM';\n /**\n * @private\n */\n  export const BOOL_4D_UNIFORM = 'BOOL_4D_UNIFORM';\n\n// Uniform types and values.\n/**\n * GPUProgram uniform types.\n */\nexport type UniformType = typeof FLOAT | typeof INT | typeof UINT | typeof BOOL;\n/**\n * @private\n */\nexport type UniformInternalType = \n\ttypeof BOOL_1D_UNIFORM |\n\ttypeof BOOL_2D_UNIFORM |\n\ttypeof BOOL_3D_UNIFORM |\n\ttypeof BOOL_4D_UNIFORM |\n\ttypeof FLOAT_1D_UNIFORM |\n\ttypeof FLOAT_2D_UNIFORM |\n\ttypeof FLOAT_3D_UNIFORM |\n\ttypeof FLOAT_4D_UNIFORM |\n\ttypeof INT_1D_UNIFORM |\n\ttypeof INT_2D_UNIFORM |\n\ttypeof INT_3D_UNIFORM |\n\ttypeof INT_4D_UNIFORM |\n\ttypeof UINT_1D_UNIFORM |\n\ttypeof UINT_2D_UNIFORM |\n\ttypeof UINT_3D_UNIFORM |\n\ttypeof UINT_4D_UNIFORM;\n/**\n * GPUProgram uniform values.\n */\nexport type UniformValue = boolean | boolean[] | number | number[];\n/**\n * GPUProgram uniform parameters.\n */\nexport type UniformParams = {\n\tname: string,\n\tvalue: UniformValue,\n\ttype: UniformType,\n};\n/**\n * @private\n */\nexport type Uniform = { \n\tlocation: WeakMap<WebGLProgram, WebGLUniformLocation>,\n\tvalue: UniformValue,\n\ttype: UniformInternalType,\n};\n\n// Vertex shader types.\n/**\n * @private\n */\nexport const DEFAULT_PROGRAM_NAME = 'DEFAULT';\n/**\n * @private\n */\nexport const SEGMENT_PROGRAM_NAME = 'SEGMENT';\n/**\n * @private\n */\nexport const LAYER_POINTS_PROGRAM_NAME = 'LAYER_POINTS';\n/**\n * @private\n */\nexport const LAYER_LINES_PROGRAM_NAME = 'LAYER_LINES';\n/**\n * @private\n */\nexport const LAYER_VECTOR_FIELD_PROGRAM_NAME = 'LAYER_VECTOR_FIELD';\n/**\n * @private\n */\n export const LAYER_MESH_PROGRAM_NAME = 'LAYER_MESH';\n// Vertex shader compile time constants.\n/**\n * @private\n */\nexport const GPUIO_VS_WRAP_X = 'GPUIO_VS_WRAP_X';\n/**\n * @private\n */\nexport const GPUIO_VS_WRAP_Y = 'GPUIO_VS_WRAP_Y';\n/**\n * @private\n */\n export const GPUIO_VS_INDEXED_POSITIONS = 'GPUIO_VS_INDEXED_POSITIONS';\n/**\n * @private\n */\nexport const GPUIO_VS_UV_ATTRIBUTE = 'GPUIO_VS_UV_ATTRIBUTE';\n /**\n * @private\n */\nexport const GPUIO_VS_NORMAL_ATTRIBUTE = 'GPUIO_VS_NORMAL_ATTRIBUTE';\n/**\n * @private\n */\nexport const GPUIO_VS_POSITION_W_ACCUM = 'GPUIO_VS_POSITION_W_ACCUM';\n\n/**\n * @private\n */\nexport type PROGRAM_NAME_INTERNAL =\n\ttypeof DEFAULT_PROGRAM_NAME |\n\ttypeof SEGMENT_PROGRAM_NAME |\n\ttypeof LAYER_POINTS_PROGRAM_NAME |\n\ttypeof LAYER_LINES_PROGRAM_NAME |\n\ttypeof LAYER_VECTOR_FIELD_PROGRAM_NAME |\n\ttypeof LAYER_MESH_PROGRAM_NAME;\n\n// Pass in #defines as strings to make it easier to control float vs int.\n/**\n * Object containing compile time #define constants for GPUProgram fragment shader.\n */\nexport type CompileTimeConstants = { [key: string]: string };\n\n// Error callback, defaults to throwing an error.\nexport type ErrorCallback = (message: string) => void;\n/**\n * @private\n */\nexport const DEFAULT_ERROR_CALLBACK = (message: string) => { throw new Error(message); };\n\n// For stepCircle() and stepSegment() (with end caps).\n/**\n * @private\n */\nexport const DEFAULT_CIRCLE_NUM_SEGMENTS = 18;// Must be divisible by 6 to work with stepSegment().\n\n// Extrema values.\n/**\n * @private\n */\nexport const MIN_UNSIGNED_BYTE = 0;\n/**\n * @private\n */\nexport const MAX_UNSIGNED_BYTE = 2 ** 8 - 1;\n/**\n * @private\n */\nexport const MIN_BYTE = -(2 ** 7);\n/**\n * @private\n */\nexport const MAX_BYTE = 2 ** 7 - 1;\n/**\n * @private\n */\nexport const MIN_UNSIGNED_SHORT = 0;\n/**\n * @private\n */\nexport const MAX_UNSIGNED_SHORT = 2 ** 16 - 1;\n/**\n * @private\n */\nexport const MIN_SHORT = -(2 ** 15);\n/**\n * @private\n */\nexport const MAX_SHORT = 2 ** 15 - 1;\n/**\n * @private\n */\nexport const MIN_UNSIGNED_INT = 0;\n/**\n * @private\n */\nexport const MAX_UNSIGNED_INT = 2 ** 32 - 1;\n/**\n * @private\n */\nexport const MIN_INT = -(2 ** 31);\n/**\n * @private\n */\nexport const MAX_INT = 2 ** 31 - 1;\n// There are larger HALF_FLOAT and FLOAT ints, but they may be spaced out by > 1.\n/**\n * @private\n */\nexport const MIN_HALF_FLOAT_INT = -2048;\n/**\n * @private\n */\nexport const MAX_HALF_FLOAT_INT = 2048;\n/**\n * @private\n */\nexport const MIN_FLOAT_INT = -16777216;\n/**\n * @private\n */\nexport const MAX_FLOAT_INT = 16777216;\n\n// Precision compile time constants\n/**\n * @private\n */\nexport const GPUIO_INT_PRECISION = 'GPUIO_INT_PRECISION';\n/**\n * @private\n */\nexport const GPUIO_FLOAT_PRECISION = 'GPUIO_FLOAT_PRECISION';\n\nexport const BOUNDARY_TOP = 'BOUNDARY_TOP';\nexport const BOUNDARY_BOTTOM = 'BOUNDARY_BOTTOM';\nexport const BOUNDARY_LEFT = 'BOUNDARY_LEFT';\nexport const BOUNDARY_RIGHT = 'BOUNDARY_RIGHT';\nexport type BoundaryEdge = typeof BOUNDARY_TOP | typeof BOUNDARY_BOTTOM | typeof BOUNDARY_LEFT | typeof BOUNDARY_RIGHT;\n","import {\n\tBYTE,\n\tFLOAT,\n\tGLSL1,\n\tGLSLPrecision,\n\tGLSLVersion,\n\tGPULayerNumComponents,\n\tGPULayerType,\n\tHALF_FLOAT,\n\tINT,\n\tPRECISION_HIGH_P,\n\tPRECISION_LOW_P,\n\tPRECISION_MEDIUM_P,\n\tSHORT,\n\tUINT,\n\tUNSIGNED_BYTE,\n\tUNSIGNED_INT,\n\tUNSIGNED_SHORT,\n} from './constants';\n\n/**\n * Enum for precision values.\n * See src/glsl/common/precision.ts for more info.\n * @private\n */\n export function intForPrecision(precision: GLSLPrecision) {\n\tif (precision === PRECISION_HIGH_P) return 2;\n\tif (precision === PRECISION_MEDIUM_P) return 1;\n\tif (precision === PRECISION_LOW_P) return 0;\n\tthrow new Error(`Unknown shader precision value: ${JSON.stringify(precision)}.`);\n}\n\n/**\n * @private\n */\nexport function uniformTypeForType(type: GPULayerType, glslVersion: GLSLVersion) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\tcase FLOAT:\n\t\t\treturn FLOAT;\n\t\tcase UNSIGNED_BYTE:\n\t\tcase UNSIGNED_SHORT:\n\t\tcase UNSIGNED_INT:\n\t\t\tif (glslVersion === GLSL1) return INT;\n\t\t\treturn UINT;\n\t\tcase BYTE:\n\t\tcase SHORT:\n\t\tcase INT:\n\t\t\treturn INT;\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid type: ${type} passed to glslKeyForType.`);\n\t}\n}\n\n/**\n * @private\n */\nexport function arrayConstructorForType(\n\ttype: GPULayerType,\n\thalfFloatsAsFloats = false,\n) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\t\tif (halfFloatsAsFloats) return Float32Array;\n\t\t\treturn Uint16Array;\n\t\tcase FLOAT:\n\t\t\treturn Float32Array;\n\t\tcase UNSIGNED_BYTE:\n\t\t\treturn Uint8Array;\n\t\tcase BYTE:\n\t\t\treturn Int8Array;\n\t\tcase UNSIGNED_SHORT:\n\t\t\treturn Uint16Array;\n\t\tcase SHORT:\n\t\t\treturn Int16Array;\n\t\tcase UNSIGNED_INT:\n\t\t\treturn Uint32Array;\n\t\tcase INT:\n\t\t\treturn Int32Array;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported type: \"${type}\".`);\n\t}\n}\n\n/**\n * @private\n */\nexport function glslTypeForType(type: GPULayerType, numComponents: GPULayerNumComponents) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\tcase FLOAT:\n\t\t\tif (numComponents === 1) return 'float';\n\t\t\treturn `vec${numComponents}`;\n\t\tcase UNSIGNED_BYTE:\n\t\tcase UNSIGNED_SHORT:\n\t\tcase UNSIGNED_INT:\n\t\t\tif (numComponents === 1) return 'uint';\n\t\t\treturn `uvec${numComponents}`;\n\t\tcase BYTE:\n\t\tcase SHORT:\n\t\tcase INT:\n\t\t\tif (numComponents === 1) return 'int';\n\t\t\treturn `ivec${numComponents}`;\n\t}\n\tthrow new Error(`Invalid type: ${type} passed to glslTypeForType.`);\n}\n\n/**\n * @private\n */\n export function glslPrefixForType(type: GPULayerType) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\tcase FLOAT:\n\t\t\treturn '';\n\t\tcase UNSIGNED_BYTE:\n\t\tcase UNSIGNED_SHORT:\n\t\tcase UNSIGNED_INT:\n\t\t\treturn 'u';\n\t\tcase BYTE:\n\t\tcase SHORT:\n\t\tcase INT:\n\t\t\treturn 'i';\n\t}\n\tthrow new Error(`Invalid type: ${type} passed to glslPrefixForType.`);\n}\n\n/**\n * @private\n */\nexport function glslComponentSelectionForNumComponents(numComponents: GPULayerNumComponents) {\n\tswitch (numComponents) {\n\t\tcase 1:\n\t\t\treturn '.x';\n\t\tcase 2:\n\t\t\treturn '.xy';\n\t\tcase 3:\n\t\t\treturn '.xyz';\n\t\tcase 4:\n\t\t\treturn '';\n\t}\n\tthrow new Error(`Invalid numComponents: ${numComponents} passed to glslComponentSelectionForNumComponents.`);\n}","import type { GPUComposer } from './GPUComposer';\n\n// https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float\n// Float is provided by default in WebGL2 contexts.\n// This extension implicitly enables the WEBGL_color_buffer_float extension (if supported), which allows rendering to 32-bit floating-point color buffers.\nexport const OES_TEXTURE_FLOAT = 'OES_texture_float';\n// https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_half_float\n// Half float is supported by modern mobile browsers, float not yet supported.\n// Half float is provided by default for Webgl2 contexts.\n// This extension implicitly enables the EXT_color_buffer_half_float extension (if supported), which allows rendering to 16-bit floating point formats.\nexport const OES_TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n// https://www.khronos.org/registry/OpenGL/extensions/OES/OES_texture_float_linear.txt\nexport const OES_TEXTURE_FLOAT_LINEAR = 'OES_texture_float_linear';\nexport const OES_TEXTURE_HAlF_FLOAT_LINEAR = 'OES_texture_half_float_linear';\n// https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture\n// Adds gl.UNSIGNED_SHORT, gl.UNSIGNED_INT types to textImage2D in WebGL1.0\nexport const WEBGL_DEPTH_TEXTURE = 'WEBGL_depth_texture';\n// EXT_COLOR_BUFFER_FLOAT adds ability to render to a variety of floating pt textures.\n// This is needed for the WebGL2 contexts that do not support OES_TEXTURE_FLOAT / OES_TEXTURE_HALF_FLOAT extensions.\n// https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float\n// https://stackoverflow.com/questions/34262493/framebuffer-incomplete-attachment-for-texture-with-internal-format\n// https://stackoverflow.com/questions/36109347/framebuffer-incomplete-attachment-only-happens-on-android-w-firefox\nexport const EXT_COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n// On WebGL 2, EXT_COLOR_BUFFER_HALF_FLOAT is an alternative to using the EXT_color_buffer_float extension on platforms\n// that support 16-bit floating point render targets but not 32-bit floating point render targets.\nexport const EXT_COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n// Vertex array extension is used by threejs.\nexport const OES_VERTEX_ARRAY_OBJECT = 'OES_vertex_array_object';\n// Extension to use int32 for indexed geometry for WebGL1.\n// According to WebGLStats nearly all devices support this extension.\n// Fallback to gl.UNSIGNED_SHORT if not available.\nexport const OES_ELEMENT_INDEX_UINT = 'OES_element_index_uint';\n// Derivatives extensions.\nexport const OES_STANDARD_DERIVATIVES = 'OES_standard_derivatives';\n\nexport function getExtension(\n\tcomposer: GPUComposer,\n\textensionName: string,\n\toptional = false,\n) {\n\t// Check if we've already loaded the extension.\n\tif (composer._extensions[extensionName] !== undefined) return composer._extensions[extensionName];\n\n\tconst { gl, _errorCallback, _extensions, verboseLogging } = composer;\n\tlet extension;\n\ttry {\n\t\textension = gl.getExtension(extensionName);\n\t} catch (e) {}\n\tif (extension) {\n\t\t// Cache this extension.\n\t\t_extensions[extensionName] = extension;\n\t\tif (composer.verboseLogging) console.log(`Loaded extension: ${extensionName}.`);\n\t} else {\n\t\t_extensions[extensionName] = false; // Cache the bad extension lookup.\n\t\tif (composer.verboseLogging) console.log(`Unsupported ${optional ? 'optional ' : ''}extension: ${extensionName}.`);\n\t}\n\t// If the extension is not optional, throw error.\n\tif (!extension && !optional) {\n\t\t_errorCallback(`Required extension unsupported by this device / browser: ${extensionName}.`);\n\t}\n\treturn extension;\n}","import type { GPUComposer } from './GPUComposer';\nimport type { GPULayer } from './GPULayer';\n\n// Cache framebuffers to minimize invalidating FBO attachment bindings:\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#avoid_invalidating_fbo_attachment_bindings\nconst framebufferMap: WeakMap<WebGLTexture | WebGLTexture[], WebGLFramebuffer> = new WeakMap();\nconst allTextureFramebuffersMap: WeakMap<WebGLTexture, WebGLFramebuffer[]> = new WeakMap();\n\nfunction initFrameBuffer(\n\tcomposer: GPUComposer,\n\tlayer0: GPULayer,\n\ttexture0: WebGLTexture,\n\tadditionalTextures?: WebGLTexture[],\n) {\n\tconst { gl, _errorCallback, isWebGL2 } = composer;\n\t// Init a framebuffer for this texture so we can write to it.\n\tconst framebuffer = gl.createFramebuffer();\n\tif (!framebuffer) {\n\t\t_errorCallback(`Could not init framebuffer for GPULayer \"${layer0.name}\": ${gl.getError()}.`);\n\t\treturn;\n\t}\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/framebufferTexture2D\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture0, 0);\n\tif (additionalTextures) {\n\t\t// Check if length additional textures exceeds a max.\n\t\tif (!isWebGL2) {\n\t\t\tthrow new Error('WebGL1 does not support drawing to multiple outputs.');\n\t\t}\n\t\tif (additionalTextures.length > 15) {\n\t\t\tthrow new Error(`Can't draw to more than 16 outputs.`);\n\t\t}\n\t\tfor (let i = 0, numTextures = additionalTextures.length; i < numTextures; i++) {\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, additionalTextures[i], 0);\n\t\t}\n\t}\n\n\tconst status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\tif(status !== gl.FRAMEBUFFER_COMPLETE){\n\t\t_errorCallback(`Invalid status for framebuffer for GPULayer \"${layer0.name}\": ${status}.`);\n\t}\n\n\treturn framebuffer;\n}\n\n/**\n * Bind framebuffer for write operation.\n * @private\n */\nexport function bindFrameBuffer(\n\tcomposer: GPUComposer,\n\tlayer0: GPULayer,\n\ttexture0: WebGLTexture,\n\tadditionalTextures?: WebGLTexture[],\n) {\n\tconst { gl } = composer;\n\tconst key = additionalTextures ? [texture0, ...additionalTextures] : texture0;\n\tlet framebuffer = framebufferMap.get(key);\n\tif (!framebuffer) {\n\t\tframebuffer = initFrameBuffer(composer, layer0, texture0, additionalTextures);\n\t\tif (!framebuffer) return;\n\t\tframebufferMap.set(key, framebuffer);\n\t\tconst allFramebuffers = allTextureFramebuffersMap.get(texture0) || [];\n\t\tallFramebuffers.push(framebuffer);\n\t\tallTextureFramebuffersMap.set(texture0, allFramebuffers);\n\t\tif (additionalTextures) {\n\t\t\tfor (let i = 0, numTextures = additionalTextures.length; i < numTextures; i++) {\n\t\t\t\tconst texture = additionalTextures[i];\n\t\t\t\tconst allFramebuffers = allTextureFramebuffersMap.get(texture) || [];\n\t\t\t\tallFramebuffers.push(framebuffer);\n\t\t\t\tallTextureFramebuffersMap.set(texture, allFramebuffers);\n\t\t\t}\n\t\t}\n\t}\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n}\n\n/**\n * Delete framebuffers when no longer needed.\n * @private\n */\nexport function disposeFramebuffers(gl: WebGLRenderingContext | WebGL2RenderingContext, texture: WebGLTexture) {\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t// Delete all framebuffers associated with this texture.\n\tconst allFramebuffers = allTextureFramebuffersMap.get(texture);\n\tif (allFramebuffers) {\n\t\tfor (let i = 0, numFramebuffers = allFramebuffers.length; i < numFramebuffers; i++) {\n\t\t\tgl.deleteFramebuffer(allFramebuffers[i]);\n\t\t}\n\t}\n\tallTextureFramebuffersMap.delete(texture);\n}","import {\n\tGPUIO_FLOAT_PRECISION,\n\tGPUIO_INT_PRECISION,\n\tPRECISION_LOW_P,\n\tPRECISION_MEDIUM_P,\n} from '../../constants';\nimport { intForPrecision } from '../../conversions';\n\n// These precision definitions are applied to all vertex and fragment shaders.\n// Default to highp, but fallback to mediump if highp not available.\n// These defaults can be set in GPUComposer constructor as intPrecision and floatPrecision parameters.\n// https://webglfundamentals.org/webgl/lessons/webgl-precision-issues.html\nexport const PRECISION_SOURCE = `\n#if (${GPUIO_INT_PRECISION} == ${intForPrecision(PRECISION_LOW_P)})\n\tprecision lowp int;\n\t#if (__VERSION__ == 300)\n\t\tprecision lowp isampler2D;\n\t\tprecision lowp usampler2D;\n\t#endif\n#elif (${GPUIO_INT_PRECISION} == ${intForPrecision(PRECISION_MEDIUM_P)})\n\tprecision mediump int;\n\t#if (__VERSION__ == 300)\n\t\tprecision mediump isampler2D;\n\t\tprecision mediump usampler2D;\n\t#endif\n#else \n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\n\t\tprecision highp int;\n\t\t#if (__VERSION__ == 300)\n\t\t\tprecision highp isampler2D;\n\t\t\tprecision highp usampler2D;\n\t\t#endif\n\t#else\n\t\tprecision mediump int;\n\t\t#if (__VERSION__ == 300)\n\t\t\tprecision mediump isampler2D;\n\t\t\tprecision mediump usampler2D;\n\t\t#endif\n\t#endif\n#endif\n#if (${GPUIO_FLOAT_PRECISION} == ${intForPrecision(PRECISION_LOW_P)})\n\tprecision lowp float;\n\tprecision lowp sampler2D;\n#elif (${GPUIO_FLOAT_PRECISION} == ${intForPrecision(PRECISION_MEDIUM_P)})\n\tprecision mediump float;\n\tprecision mediump sampler2D;\n#else\n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\n\t\tprecision highp float;\n\t\tprecision highp sampler2D;\n\t#else\n\t\tprecision mediump float;\n\t\tprecision mediump sampler2D;\n\t#endif\n#endif\n`;","import {\n\tGPUIO_VS_UV_ATTRIBUTE,\n\tGPUIO_VS_NORMAL_ATTRIBUTE,\n} from '../../constants';\n\nexport const DEFAULT_VERT_SHADER_SOURCE = `\nin vec2 a_gpuio_position;\n#ifdef ${GPUIO_VS_UV_ATTRIBUTE}\n\tin vec2 a_gpuio_uv;\n#endif\n#ifdef ${GPUIO_VS_NORMAL_ATTRIBUTE}\n\tin vec2 a_gpuio_normal;\n#endif\n\nuniform vec2 u_gpuio_scale;\nuniform vec2 u_gpuio_translation;\n\nout vec2 v_uv;\nout vec2 v_uv_local;\n#ifdef ${GPUIO_VS_NORMAL_ATTRIBUTE}\n\tout vec2 v_normal;\n#endif\n\nvoid main() {\n\t// Optional varyings.\n\t#ifdef ${GPUIO_VS_UV_ATTRIBUTE}\n\t\tv_uv_local = a_gpuio_uv;\n\t#else\n\t\tv_uv_local = 0.5 * (a_gpuio_position + 1.0);\n\t#endif\n\t#ifdef ${GPUIO_VS_NORMAL_ATTRIBUTE}\n\t\tv_normal = a_gpuio_normal;\n\t#endif\n\n\t// Apply transformations.\n\tvec2 position = u_gpuio_scale * a_gpuio_position + u_gpuio_translation;\n\n\t// Calculate a global uv for the viewport.\n\tv_uv = 0.5 * (position + 1.0);\n\n\t// Calculate vertex position.\n\tgl_Position = vec4(position, 0, 1);\n}`;","import {\n\tGPUIO_VS_INDEXED_POSITIONS, GPUIO_VS_POSITION_W_ACCUM, GPUIO_VS_WRAP_X, GPUIO_VS_WRAP_Y,\n} from '../../constants';\nimport { VERTEX_SHADER_HELPERS_SOURCE } from './VertexShaderHelpers';\n\nexport const LAYER_LINES_VERTEX_SHADER_SOURCE = `\n${VERTEX_SHADER_HELPERS_SOURCE}\n\n#if (__VERSION__ != 300 || ${GPUIO_VS_INDEXED_POSITIONS} == 1)\n\t// Cannot use int vertex attributes.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\tin float a_gpuio_index;\n#endif\n\nuniform sampler2D u_gpuio_positions; // Texture lookup with position data.\nuniform vec2 u_gpuio_positionsDimensions;\nuniform vec2 u_gpuio_scale;\n\nout vec2 v_uv;\nout vec2 v_lineWrapping; // Use this to test if line is only half wrapped and should not be rendered.\nflat out int v_index;\n\nvoid main() {\n\t// Calculate a uv based on the point's index attribute.\n\t#if (__VERSION__ != 300 || ${GPUIO_VS_INDEXED_POSITIONS} == 1)\n\t\tvec2 positionUV = uvFromIndex(a_gpuio_index, u_gpuio_positionsDimensions);\n\t\tv_index = int(a_gpuio_index);\n\t#else\n\t\tvec2 positionUV = uvFromIndex(gl_VertexID, u_gpuio_positionsDimensions);\n\t\tv_index = gl_VertexID;\n\t#endif\n\n\t// Calculate a global uv for the viewport.\n\t// Lookup vertex position and scale to [0, 1] range.\n\t#ifdef ${GPUIO_VS_POSITION_W_ACCUM}\n\t\t// We have packed a 2D displacement with the position.\n\t\tvec4 positionData = texture(u_gpuio_positions, positionUV);\n\t\t// position = first two components plus last two components (optional accumulation buffer).\n\t\tv_uv = (positionData.rg + positionData.ba) * u_gpuio_scale;\n\t#else\n\t\tv_uv = texture(u_gpuio_positions, positionUV).rg  * u_gpuio_scale;\n\t#endif\n\n\t// Wrap if needed.\n\tv_lineWrapping = vec2(0.0);\n\t#ifdef ${GPUIO_VS_WRAP_X}\n\t\tv_lineWrapping.x = max(step(1.0, v_uv.x), step(v_uv.x, 0.0));\n\t\tv_ux.x = fract(v_uv.x + 1.0);\n\t#endif\n\t#ifdef ${GPUIO_VS_WRAP_Y}\n\t\tv_lineWrapping.y = max(step(1.0, v_uv.y), step(v_uv.y, 0.0));\n\t\tv_ux.y = fract(v_uv.y + 1.0);\n\t#endif\n\n\t// Calculate position in [-1, 1] range.\n\tvec2 position = v_uv * 2.0 - 1.0;\n\n\tgl_Position = vec4(position, 0, 1);\n}`;","import {\n\tGPUIO_VS_POSITION_W_ACCUM,\n} from '../../constants';\nimport { VERTEX_SHADER_HELPERS_SOURCE } from './VertexShaderHelpers';\n\nexport const LAYER_MESH_VERTEX_SHADER_SOURCE = `\n${VERTEX_SHADER_HELPERS_SOURCE}\n\n#if (__VERSION__ != 300)\n\t// Cannot use int vertex attributes.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\tin float a_gpuio_index;\n#endif\n\nuniform sampler2D u_gpuio_positions; // Texture lookup with position data.\nuniform vec2 u_gpuio_positionsDimensions;\nuniform vec2 u_gpuio_scale;\n\nout vec2 v_uv;\nout vec2 v_uv_position;\nout vec2 v_position;\nflat out int v_index;\n\nvoid main() {\n\t// Calculate a uv based on the point's index attribute.\n\t#if (__VERSION__ == 300)\n\t\tv_uv_position = uvFromIndex(gl_VertexID, u_gpuio_positionsDimensions);\n\t\tv_index = gl_VertexID;\n\t#else\n\t\tv_uv_position = uvFromIndex(a_gpuio_index, u_gpuio_positionsDimensions);\n\t\tv_index = int(a_gpuio_index);\n\t#endif\n\n\t// Calculate a global uv for the viewport.\n\t// Lookup vertex position and scale to [0, 1] range.\n\t#ifdef ${GPUIO_VS_POSITION_W_ACCUM}\n\t\t// We have packed a 2D displacement with the position.\n\t\tvec4 positionData = texture(u_gpuio_positions, v_uv_position);\n\t\t// position = first two components plus last two components (optional accumulation buffer).\n\t\tv_position = positionData.rg + positionData.ba;\n\t\tv_uv = v_position * u_gpuio_scale;\n\t#else\n\t\tv_position = texture(u_gpuio_positions, v_uv_position).rg;\n\t\tv_uv = v_position * u_gpuio_scale;\n\t#endif\n\n\t// Calculate position in [-1, 1] range.\n\tvec2 position = v_uv * 2.0 - 1.0;\n\n\tgl_Position = vec4(position, 0, 1);\n}`;","import {\n\tGPUIO_VS_POSITION_W_ACCUM, GPUIO_VS_WRAP_X, GPUIO_VS_WRAP_Y,\n} from '../../constants';\nimport { VERTEX_SHADER_HELPERS_SOURCE } from './VertexShaderHelpers';\n\nexport const LAYER_POINTS_VERTEX_SHADER_SOURCE = `\n${VERTEX_SHADER_HELPERS_SOURCE}\n\n#if (__VERSION__ != 300)\n\t// Cannot use int vertex attributes.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\tin float a_gpuio_index;\n#endif\n\nuniform sampler2D u_gpuio_positions; // Texture lookup with position data.\nuniform vec2 u_gpuio_positionsDimensions;\nuniform vec2 u_gpuio_scale;\nuniform float u_gpuio_pointSize;\n\nout vec2 v_uv;\nout vec2 v_uv_position;\nout vec2 v_position;\nflat out int v_index;\n\nvoid main() {\n\t// Calculate a uv based on the point's index attribute.\n\t#if (__VERSION__ == 300)\n\t\tv_uv_position = uvFromIndex(gl_VertexID, u_gpuio_positionsDimensions);\n\t\tv_index = gl_VertexID;\n\t#else\n\t\tv_uv_position = uvFromIndex(a_gpuio_index, u_gpuio_positionsDimensions);\n\t\tv_index = int(a_gpuio_index);\n\t#endif\n\n\t// Calculate a global uv for the viewport.\n\t// Lookup vertex position and scale to [0, 1] range.\n\t#ifdef ${GPUIO_VS_POSITION_W_ACCUM}\n\t\t// We have packed a 2D displacement with the position.\n\t\tvec4 positionData = texture(u_gpuio_positions, v_uv_position);\n\t\t// position = first two components plus last two components (optional accumulation buffer).\n\t\tv_position = positionData.rg + positionData.ba;\n\t\tv_uv = v_position * u_gpuio_scale;\n\t#else\n\t\tv_position = texture(u_gpuio_positions, v_uv_position).rg;\n\t\tv_uv = v_position * u_gpuio_scale;\n\t#endif\n\n\t// Wrap if needed.\n\t#ifdef ${GPUIO_VS_WRAP_X}\n\t\tv_uv.x = fract(v_uv.x + ceil(abs(v_uv.x)));\n\t#endif\n\t#ifdef ${GPUIO_VS_WRAP_Y}\n\t\tv_uv.y = fract(v_uv.y + ceil(abs(v_uv.y)));\n\t#endif\n\n\t// Calculate position in [-1, 1] range.\n\tvec2 position = v_uv * 2.0 - 1.0;\n\n\tgl_PointSize = u_gpuio_pointSize;\n\tgl_Position = vec4(position, 0, 1);\n}`;","import { VERTEX_SHADER_HELPERS_SOURCE } from './VertexShaderHelpers';\n\nexport const LAYER_VECTOR_FIELD_VERTEX_SHADER_SOURCE = `\n${VERTEX_SHADER_HELPERS_SOURCE}\n\n#if (__VERSION__ != 300)\n\t// Cannot use int vertex attributes.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\tin float a_gpuio_index;\n#endif\n\nuniform sampler2D u_gpuio_vectors; // Texture lookup with vector data.\nuniform vec2 u_gpuio_dimensions;\nuniform vec2 u_gpuio_scale;\n\nout vec2 v_uv;\nflat out int v_index;\n\nvoid main() {\n\t#if (__VERSION__ == 300)\n\t\t// Divide index by 2.\n\t\tint index = gl_VertexID / 2;\n\t\tv_index = index;\n\t#else\n\t\t// Divide index by 2.\n\t\tfloat index = floor((a_gpuio_index + 0.5) / 2.0);\n\t\tv_index = int(index);\n\t#endif\n\n\t// Calculate a uv based on the vertex index attribute.\n\tv_uv = uvFromIndex(index, u_gpuio_dimensions);\n\t#if (__VERSION__ == 300)\n\t\t// Add vector displacement if needed.\n\t\tv_uv += float(gl_VertexID - 2 * index) * texture(u_gpuio_vectors, v_uv).xy * u_gpuio_scale;\n\t#else\n\t\t// Add vector displacement if needed.\n\t\tv_uv += (a_gpuio_index - 2.0 * index) * texture(u_gpuio_vectors, v_uv).xy * u_gpuio_scale;\n\t#endif\n\n\n\t// Calculate position in [-1, 1] range.\n\tvec2 position = v_uv * 2.0 - 1.0;\n\n\tgl_Position = vec4(position, 0, 1);\n}`;","export const SEGMENT_VERTEX_SHADER_SOURCE = `\nin vec2 a_gpuio_position;\n\nuniform float u_gpuio_halfThickness;\nuniform vec2 u_gpuio_scale;\nuniform float u_gpuio_length;\nuniform float u_gpuio_rotation;\nuniform vec2 u_gpuio_translation;\n\nout vec2 v_uv_local;\nout vec2 v_uv;\n\nmat2 rotate2d(float _angle){\n\treturn mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n\t// Calculate UV coordinates of current rendered object.\n\tv_uv_local = 0.5 * (a_gpuio_position + 1.0);\n\n\tvec2 position = a_gpuio_position;\n\t// Apply thickness / radius.\n\tposition *= u_gpuio_halfThickness;\n\t// Stretch center of shape to form a round-capped line segment.\n\tfloat signX = sign(position.x);\n\tposition.x += signX * u_gpuio_length / 2.0;\n\tv_uv_local.x = (signX + 1.0) / 2.0;// Set entire cap uv.x to 1 or 0.\n\t// Apply transformations.\n\tposition = u_gpuio_scale * (rotate2d(-u_gpuio_rotation) * position) + u_gpuio_translation;\n\n\t// Calculate a global uv for the viewport.\n\tv_uv = 0.5 * (position + 1.0);\n\n\t// Calculate vertex position.\n\tgl_Position = vec4(position, 0, 1);\n}`;","export const VERTEX_SHADER_HELPERS_SOURCE = `\n/**\n * Create UV coordinates from a 1D index for data stored in a texture of size \"dimensions\".\n */\nvec2 uvFromIndex(const float index, const vec2 dimensions) {\n\tfloat y = floor((index + 0.5) / dimensions.x);\n\tfloat x = floor(index - y * dimensions.x + 0.5);\n\treturn vec2(x + 0.5, y + 0.5) / dimensions;\n}\nvec2 uvFromIndex(const int index, const vec2 dimensions) {\n\tint width = int(dimensions.x);\n\tint y = index / width;\n\tint x = index - y * width;\n\treturn vec2(float(x) + 0.5, float(y) + 0.5) / dimensions;\n}\nvec2 uvFromIndex(const float index, const ivec2 dimensions) {\n\tfloat width = float(dimensions.x);\n\tfloat y = floor((index + 0.5) / width);\n\tfloat x = floor(index - y * width + 0.5);\n\treturn vec2(x + 0.5, y + 0.5) / vec2(dimensions);\n}\nvec2 uvFromIndex(const int index, const ivec2 dimensions) {\n\tint y = index / dimensions.x;\n\tint x = index - y * dimensions.x;\n\treturn vec2(float(x) + 0.5, float(y) + 0.5) / vec2(dimensions);\n}`\n","import * as utils from './utils';\nimport { GPUComposer } from './GPUComposer';\nimport { GPULayer } from './GPULayer';\nimport * as GPULayerHelpers from './GPULayerHelpers';\nimport { GPUProgram } from './GPUProgram';\nimport { GPUIndexBuffer } from './GPUIndexBuffer';\nimport * as checks from './checks';\nimport * as regex from './regex';\nimport * as extensions from './extensions';\nimport * as polyfills from './polyfills';\nimport * as conversions from './conversions';\nimport * as Programs from './Programs';\n\n// These exports are only used for testing.\n/**\n * @private\n */\nconst _testing = {\n\tisFloatType: utils.isFloatType,\n\tisUnsignedIntType: utils.isUnsignedIntType,\n\tisSignedIntType: utils.isSignedIntType,\n\tisIntType: utils.isIntType,\n\tmakeShaderHeader: utils.makeShaderHeader,\n\tcompileShader: utils.compileShader,\n\tinitGLProgram: utils.initGLProgram,\n\treadyToRead: utils.readyToRead,\n\tpreprocessVertexShader: utils.preprocessVertexShader,\n\tpreprocessFragmentShader: utils.preprocessFragmentShader,\n\tisPowerOf2: utils.isPowerOf2,\n\tinitSequentialFloatArray: utils.initSequentialFloatArray,\n\tuniformInternalTypeForValue: utils.uniformInternalTypeForValue,\n\tindexOfLayerInArray: utils.indexOfLayerInArray,\n\treadPixelsAsync: utils.readPixelsAsync,\n\t...extensions,\n\t...regex,\n\t...checks,\n\t...GPULayerHelpers,\n\t...polyfills,\n\t...conversions,\n}\n\n// Named exports.\nconst {\n\tisWebGL2,\n\tisWebGL2Supported,\n\tisHighpSupportedInVertexShader,\n\tisHighpSupportedInFragmentShader,\n\tgetVertexShaderMediumpPrecision,\n\tgetFragmentShaderMediumpPrecision,\n} = utils;\nconst {\n\tcopyProgram,\n\taddLayersProgram,\n\taddValueProgram,\n\tmultiplyValueProgram,\n\tsetValueProgram,\n\tsetColorProgram,\n\tzeroProgram,\n\trenderRGBProgram,\n\trenderAmplitudeProgram,\n\trenderSignedAmplitudeProgram,\n} = Programs;\n\nexport {\n\tGPUComposer,\n\tGPULayer,\n\tGPUProgram,\n\tGPUIndexBuffer,\n\tisWebGL2,\n\tisWebGL2Supported,\n\tisHighpSupportedInVertexShader,\n\tisHighpSupportedInFragmentShader,\n\tgetVertexShaderMediumpPrecision,\n\tgetFragmentShaderMediumpPrecision,\n\tcopyProgram,\n\taddLayersProgram,\n\taddValueProgram,\n\tmultiplyValueProgram,\n\trenderAmplitudeProgram,\n\trenderSignedAmplitudeProgram,\n\tsetValueProgram,\n\tsetColorProgram,\n\tzeroProgram,\n\trenderRGBProgram,\n\t_testing,\n}\nexport * from './constants';","import { GLSLVersion, GLSL1 } from './constants';\nimport { getSampler2DsInProgram } from './regex';\n\n/**\n * Wrap type to use in polyfill.\n * (0) Default behavior (no polyfill).\n * (1) REPEAT polyfill.\n * @private\n */\nexport const SAMPLER2D_WRAP_X = 'GPUIO_WRAP_X';\n/**\n * Wrap type to use in polyfill.\n * (0) Default behavior (no polyfill).\n * (1) REPEAT polyfill.\n * @private\n */\nexport const SAMPLER2D_WRAP_Y = 'GPUIO_WRAP_Y';\n/**\n * Flag to cast texture() result to int type (needed for GLSL1).\n * @private\n */\n export const SAMPLER2D_CAST_INT = 'GPUIO_CAST_INT';\n\n/**\n * Filter type to use in polyfill.\n * (0) Default behavior (no polyfill).\n * (0) LINEAR polyfill.\n * @private\n */\nexport const SAMPLER2D_FILTER = 'GPUIO_FILTER';\n\n/**\n * UV size of half a pixel for this texture.\n * @private\n */\nexport const SAMPLER2D_HALF_PX_UNIFORM = 'u_gpuio_half_px';\n\n/**\n * Dimensions of texture\n * @private\n */\nexport const SAMPLER2D_DIMENSIONS_UNIFORM = 'u_gpuio_dimensions';\n\n/**\n * Override texture function to perform polyfill filter/wrap.\n * https://www.codeproject.com/Articles/236394/Bi-Cubic-and-Bi-Linear-Interpolation-with-GLSL\n * @private\n */\nexport function texturePolyfill(shaderSource: string) {\n\tconst textureCalls = shaderSource.match(/\\btexture\\(/g);\n\tif (!textureCalls || textureCalls.length === 0) return { shaderSource, samplerUniforms: [] };\n\tconst samplerUniforms = getSampler2DsInProgram(shaderSource);\n\tif (samplerUniforms.length === 0) return { shaderSource, samplerUniforms };\n\tsamplerUniforms.forEach((name, i) => {\n\t\tconst regex = new RegExp(`\\\\btexture(2D)?\\\\(\\\\s?${name}\\\\b`, 'gs');\n\t\tshaderSource = shaderSource.replace(regex, `GPUIO_TEXTURE_POLYFILL${i}(${name}`);\n\t});\n\tconst remainingTextureCalls = shaderSource.match(/\\btexture(2D)?\\(/g);\n\tif (remainingTextureCalls?.length) {\n\t\tconsole.warn('Fragment shader polyfill has missed some calls to texture().', shaderSource);\n\t}\n\t\n\tlet polyfillUniforms: {[key: string] : string } = {};\n\tfor (let i = 0; i < samplerUniforms.length; i++) {\n\t\t// Init uniforms with a type.\n\t\tpolyfillUniforms[`${SAMPLER2D_HALF_PX_UNIFORM}${i}`] = 'vec2';\n\t\tpolyfillUniforms[`${SAMPLER2D_DIMENSIONS_UNIFORM}${i}`] = 'vec2';\n\t}\n\n\tfunction make_GPUIO_TEXTURE_POLYFILL(i: number, prefix: string, castOpening = '') {\n\t\tconst castEnding = castOpening === '' ? '' : ')';\n\t\tconst returnPrefix = castOpening === '' ? prefix : 'i';\n\t\treturn `\n${returnPrefix}vec4 GPUIO_TEXTURE_POLYFILL${i}(const ${prefix}sampler2D sampler, const vec2 uv) {\n\t${ prefix === '' ? `#if (${SAMPLER2D_FILTER}${i} == 0)` : ''}\n\t\t#if (${SAMPLER2D_WRAP_X}${i} == 0)\n\t\t\t#if (${SAMPLER2D_WRAP_Y}${i} == 0)\n\t\t\t\treturn ${castOpening}texture(sampler, uv)${castEnding};\n\t\t\t#else\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_WRAP_CLAMP_REPEAT(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i})${castEnding};\n\t\t\t#endif\n\t\t#else\n\t\t\t#if (${SAMPLER2D_WRAP_Y}${i} == 0)\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_WRAP_REPEAT_CLAMP(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i})${castEnding};\n\t\t\t#else\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_WRAP_REPEAT_REPEAT(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i})${castEnding};\n\t\t\t#endif\n\t\t#endif\n\t${ prefix === '' ? `#else\n\t\t#if (${SAMPLER2D_WRAP_X}${i} == 0)\n\t\t\t#if (${SAMPLER2D_WRAP_Y}${i} == 0)\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_BILINEAR_INTERP(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i}, ${SAMPLER2D_DIMENSIONS_UNIFORM}${i})${castEnding};\n\t\t\t#else\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_BILINEAR_INTERP_WRAP_CLAMP_REPEAT(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i}, ${SAMPLER2D_DIMENSIONS_UNIFORM}${i})${castEnding};\n\t\t\t#endif\n\t\t#else\n\t\t\t#if (${SAMPLER2D_WRAP_Y}${i} == 0)\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_BILINEAR_INTERP_WRAP_REPEAT_CLAMP(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i}, ${SAMPLER2D_DIMENSIONS_UNIFORM}${i})${castEnding};\n\t\t\t#else\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_BILINEAR_INTERP_WRAP_REPEAT_REPEAT(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i}, ${SAMPLER2D_DIMENSIONS_UNIFORM}${i})${castEnding};\n\t\t\t#endif\n\t\t#endif\n\t#endif` : '' }\n}\\n`;\n\t}\n\n\tfunction make_GPUIO_TEXTURE_WRAP(prefix: string) {\n\t\treturn `\n${prefix}vec4 GPUIO_TEXTURE_WRAP_REPEAT_REPEAT(const ${prefix}sampler2D sampler, const vec2 uv, const vec2 halfPx) {\n\treturn texture(sampler, GPUIO_WRAP_REPEAT_UV(uv));\n}\n${prefix}vec4 GPUIO_TEXTURE_WRAP_REPEAT_CLAMP(const ${prefix}sampler2D sampler, vec2 uv, const vec2 halfPx) {\n\tuv.x = GPUIO_WRAP_REPEAT_UV_COORD(uv.x);\n\t// uv.y = GPUIO_WRAP_CLAMP_UV_COORD(uv.y, halfPx.y);\n\treturn texture(sampler, uv);\n}\n${prefix}vec4 GPUIO_TEXTURE_WRAP_CLAMP_REPEAT(const ${prefix}sampler2D sampler, vec2 uv, const vec2 halfPx) {\n\t// uv.x = GPUIO_WRAP_CLAMP_UV_COORD(uv.x, halfPx.x);\n\tuv.y = GPUIO_WRAP_REPEAT_UV_COORD(uv.y);\n\treturn texture(sampler, uv);\n}\\n`;\n\t}\n\n\tfunction make_GPUIO_BILINEAR_INTERP(wrapType: string | null) {\n\t\tconst lookupFunction = wrapType ? `GPUIO_TEXTURE_WRAP_${wrapType}` : 'texture';\n\t\tconst extraParams =  wrapType ? `, halfPx` : '';\n\t\treturn`\nvec4 GPUIO_TEXTURE_BILINEAR_INTERP${ wrapType ? `_WRAP_${wrapType}` : '' }(const sampler2D sampler, const vec2 uv, const vec2 halfPx, const vec2 dimensions) {\n\tvec2 pxFraction = fract(uv * dimensions);\n\tvec2 offset = halfPx - vec2(0.00001, 0.00001) * max(\n\t\t\tstep(abs(pxFraction.x - 0.5), 0.001),\n\t\t\tstep(abs(pxFraction.y - 0.5), 0.001)\n\t\t);\n\tvec2 baseUV = uv - offset;\n\tvec2 diagOffset = vec2(offset.x, -offset.y);\n\tvec4 minmin = ${lookupFunction}(sampler, baseUV${extraParams});\n\tvec4 maxmin = ${lookupFunction}(sampler, uv + diagOffset${extraParams});\n\tvec4 minmax = ${lookupFunction}(sampler, uv - diagOffset${extraParams});\n\tvec4 maxmax = ${lookupFunction}(sampler, uv + offset${extraParams});\n\tvec2 t = fract(baseUV * dimensions);\n\tvec4 yMin = mix(minmin, maxmin, t.x);\n\tvec4 yMax = mix(minmax, maxmax, t.x);\n\treturn mix(yMin, yMax, t.y);\n}\\n`;\n\t}\n\n\tshaderSource = `\n${ Object.keys(polyfillUniforms).map((key) => `uniform ${polyfillUniforms[key]} ${key};`).join('\\n') }\n\nfloat GPUIO_WRAP_REPEAT_UV_COORD(const float coord) {\n\treturn fract(coord + ceil(abs(coord)));\n}\nvec2 GPUIO_WRAP_REPEAT_UV(const vec2 uv) {\n\treturn fract(uv + ceil(abs(uv)));\n}\n// float GPUIO_WRAP_CLAMP_UV_COORD(const float coord, const float halfPx) {\n// \treturn clamp(coord, halfPx, 1.0 - halfPx);\n// }\n\n${ make_GPUIO_TEXTURE_WRAP('') }\n#if (__VERSION__ == 300)\n${ ['u', 'i'].map(prefix => make_GPUIO_TEXTURE_WRAP(prefix)).join('\\n') }\n#endif\n\n${ [ null,\n\t'REPEAT_REPEAT',\n\t'REPEAT_CLAMP',\n\t'CLAMP_REPEAT',\n].map(wrap => make_GPUIO_BILINEAR_INTERP(wrap)).join('\\n') }\n\n${ samplerUniforms.map((uniform, index) => {\nreturn `#ifndef ${SAMPLER2D_CAST_INT}${index}\n\t${ make_GPUIO_TEXTURE_POLYFILL(index, '') }\n#endif`}).join('\\n') }\n#if (__VERSION__ == 300)\n${ ['u', 'i'].map(prefix => {\n\treturn samplerUniforms.map((uniform, index) => {\n\t\treturn make_GPUIO_TEXTURE_POLYFILL(index, prefix);\n\t}).join('\\n');\n}).join('\\n') }\n#else\n\t${ samplerUniforms.map((uniform, index) => {\nreturn `#ifdef ${SAMPLER2D_CAST_INT}${index}\n\t${make_GPUIO_TEXTURE_POLYFILL(index, '', 'ivec4(') }\n#endif`}).join('\\n') }\n#endif\n\n${shaderSource}`;\n\treturn {\n\t\tshaderSource,\n\t\tsamplerUniforms,\n\t}\n}\n\ntype T = 'float' | 'vec2' | 'vec3' | 'vec4';\ntype TI = 'int' | 'ivec2' | 'ivec3' | 'ivec4';\ntype TU = 'uint' | 'uvec2' | 'uvec3' | 'uvec4';\ntype TB = 'bool' | 'bvec2' | 'bvec3' | 'bvec4';\n\nfunction floatTypeForIntType(type: TI | TU): T {\n\tswitch(type) {\n\t\tcase 'int':\n\t\tcase 'uint':\n\t\t\treturn 'float';\n\t\tcase 'ivec2':\n\t\tcase 'uvec2':\n\t\t\treturn 'vec2';\n\t\tcase 'ivec3':\n\t\tcase 'uvec3':\n\t\t\treturn 'vec3';\n\t\tcase 'ivec4':\n\t\tcase 'uvec4':\n\t\t\treturn 'vec4';\n\t}\n\tthrow new Error(`Unknown type ${type}.`);\n}\n\nfunction floatTypeForBoolType(type: TB): T {\n\tswitch(type) {\n\t\tcase 'bool':\n\t\t\treturn 'float';\n\t\tcase 'bvec2':\n\t\t\treturn 'vec2';\n\t\tcase 'bvec3':\n\t\t\treturn 'vec3';\n\t\tcase 'bvec4':\n\t\t\treturn 'vec4';\n\t}\n\tthrow new Error(`Unknown type ${type}.`);\n}\n\nfunction abs(type: TI) { return `${type} abs(const ${type} a) { return ${type}(abs(${floatTypeForIntType(type)}(a))); }`; }\nfunction sign(type: TI) { return `${type} sign(const ${type} a) { return ${type}(sign(${floatTypeForIntType(type)}(a))); }`; }\nfunction trunc(type: T) { return `${type} trunc(const ${type} a) { return round(a - fract(a) * sign(a)); }`; }\nfunction round(type: T) { return `${type} round(const ${type} a) { return floor(a + 0.5); }`; }\nfunction roundEven(type: T) { return `${type} roundEven(const ${type} a) { return 2.0 * round(a / 2.0); }`; }\nfunction min(type1: TI, type2: TI) { return `${type1} min(const ${type1} a, const ${type2} b) { return ${type1}(min(${floatTypeForIntType(type1)}(a), ${floatTypeForIntType(type2)}(b))); }`; }\nfunction max(type1: TI, type2: TI) { return `${type1} max(const ${type1} a, const ${type2} b) { return ${type1}(max(${floatTypeForIntType(type1)}(a), ${floatTypeForIntType(type2)}(b))); }`; }\nfunction clamp(type1: TI, type2: TI) { return `${type1} clamp(const ${type1} a, const ${type2} min, const ${type2} max) { return ${type1}(clamp(${floatTypeForIntType(type1)}(a), ${floatTypeForIntType(type2)}(min), ${floatTypeForIntType(type2)}(max))); }`; }\nfunction mix(type1: T, type2: TB) { return `${type1} mix(const ${type1} a, const ${type1} b, const ${type2} c) { return mix(a, b, ${floatTypeForBoolType(type2)}(c)); }`; }\nfunction det2(n: number, m: number, size: number) { return `a[${n}][${m}] * a[${(n + 1) % size}][${(m + 1) % size}] - a[${(n + 1) % size}][${m}] * a[${n}][${(m + 1) % size}]`; }\n// TODO: I don't think these are quite right yet.\nfunction det3(n: number, m: number, size: number) { return [0, 1, 2].map(offset => `a[${n}][${(m + offset) % size}] * (${det2((n + 1) % size, (m + 1 + offset) % size, size)})`).join(' + '); }\nfunction det4(n: number, m: number, size: number) { return [0, 1, 2, 3].map(offset => `a[${n}][${(m + offset) % size}] * (${det3((n + 1) % size, (m + 1 + offset) % size, size)})`).join(' + '); }\n\n/**\n * Polyfill common functions/operators that GLSL1 lacks.\n * @private\n */\nexport function GLSL1Polyfills(shaderSource: string) {\n\t// We'll attempt to just add in what we need, but no worries if we add extraneous functions.\n\t// They will be removed by compiler.\n\tlet GLSL1_POLYFILLS = '';\n\n\t// We don't need to create unsigned int polyfills, bc unsigned int is not a supported type in GLSL1.\n\t// All unsigned int variables will be cast as int and be caught by the signed int polyfills.\n\n\tif (shaderSource.includes('abs')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${abs('int')}\n${abs('ivec2')}\n${abs('ivec3')}\n${abs('ivec4')}\n`;\n\t}\n\n\tif (shaderSource.includes('sign')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${sign('int')}\n${sign('ivec2')}\n${sign('ivec3')}\n${sign('ivec4')}\n`;\n\t}\n\n\tif (shaderSource.includes('round')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${round('float')}\n${round('vec2')}\n${round('vec3')}\n${round('vec4')}\n`;\n\t}\n\n\tif (shaderSource.includes('trunc')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${trunc('float')}\n${trunc('vec2')}\n${trunc('vec3')}\n${trunc('vec4')}\n`;\n\t}\n\n\tif (shaderSource.includes('roundEven')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${roundEven('float')}\n${roundEven('vec2')}\n${roundEven('vec3')}\n${roundEven('vec4')}\n`;\n\t}\n\n\tif (shaderSource.includes('min')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${min('int', 'int')}\n${min('ivec2', 'ivec2')}\n${min('ivec3', 'ivec3')}\n${min('ivec4', 'ivec4')}\n${min('ivec2', 'int')}\n${min('ivec3', 'int')}\n${min('ivec4', 'int')}\n`;\n\t}\n\n\tif (shaderSource.includes('max')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${max('int', 'int')}\n${max('ivec2', 'ivec2')}\n${max('ivec3', 'ivec3')}\n${max('ivec4', 'ivec4')}\n${max('ivec2', 'int')}\n${max('ivec3', 'int')}\n${max('ivec4', 'int')}\n`;\n\t}\n\n\tif (shaderSource.includes('clamp')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${clamp('int', 'int')}\n${clamp('ivec2', 'ivec2')}\n${clamp('ivec3', 'ivec3')}\n${clamp('ivec4', 'ivec4')}\n${clamp('ivec2', 'int')}\n${clamp('ivec3', 'int')}\n${clamp('ivec4', 'int')}\n`;\n\t}\n\n\tif (shaderSource.includes('mix')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\n${mix('float', 'bool')}\n${mix('vec2', 'bvec2')}\n${mix('vec3', 'bvec3')}\n${mix('vec4', 'bvec4')}\n`;\n\t}\n\n\tif (shaderSource.includes('outerProduct')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nmat2 outerProduct(const vec2 a, const vec2 b) {\n\treturn mat2(\n\t\ta.x * b.x, a.x * b.y,\n\t\ta.y * b.x, a.y * b.y\n\t);\n}\nmat3 outerProduct(const vec3 a, const vec3 b) {\n\treturn mat3(\n\t\ta.x * b.x, a.x * b.y, a.x * b.z,\n\t\ta.y * b.x, a.y * b.y, a.y * b.z,\n\t\ta.z * b.x, a.z * b.y, a.z * b.z\n\t);\n}\nmat4 outerProduct(const vec4 a, const vec4 b) {\n\treturn mat4(\n\t\ta.x * b.x, a.x * b.y, a.x * b.z, a.x * b.w,\n\t\ta.y * b.x, a.y * b.y, a.y * b.z, a.y * b.w,\n\t\ta.z * b.x, a.z * b.y, a.z * b.z, a.z * b.w,\n\t\ta.w * b.x, a.w * b.y, a.w * b.z, a.w * b.w\n\t);\n}\n`;\n\t}\n\n\tif (shaderSource.includes('transpose')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nmat2 transpose(mat2 a) {\n\tfloat temp = a[0][1];\n\ta[0][1] = a[1][0];\n\ta[1][0] = temp;\n\treturn a;\n}\nmat3 transpose(mat3 a) {\n\tfloat temp = a[0][2];\n\ta[0][2] = a[2][0];\n\ta[2][0] = temp;\n\ttemp = a[0][1];\n\ta[0][1] = a[1][0];\n\ta[1][0] = temp;\n\ttemp = a[1][2];\n\ta[1][2] = a[2][1];\n\ta[2][1] = temp;\n\treturn a;\n}\nmat4 transpose(mat4 a) {\n\tfloat temp = a[0][3];\n\ta[0][3] = a[3][0];\n\ta[3][0] = temp;\n\ttemp = a[0][2];\n\ta[0][2] = a[2][0];\n\ta[2][0] = temp;\n\ttemp = a[2][3];\n\ta[2][3] = a[3][2];\n\ta[3][2] = temp;\n\ttemp = a[0][1];\n\ta[0][1] = a[1][0];\n\ta[1][0] = temp;\n\ttemp = a[1][2];\n\ta[1][2] = a[2][1];\n\ta[2][1] = temp;\n\ttemp = a[2][3];\n\ta[2][3] = a[3][2];\n\ta[3][2] = temp;\n\treturn a;\n}\n`;\n\t}\n\n\tif (shaderSource.includes('determinant')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nfloat determinant(const mat2 a) {\n\treturn ${ det2(0, 0, 2) };\n}\nfloat determinant(const mat3 a) {\n\treturn ${ det3(0, 0, 3) };\n}\nfloat determinant(const mat4 a) {\n\treturn ${ det4(0, 0, 4) };\n}\n`;\n\t}\n\n\t// Copied from https://github.com/gpujs/gpu.js/blob/master/src/backend/web-gl/fragment-shader.js\n\tif (shaderSource.includes('sinh')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nfloat sinh(const float x) {\n\treturn (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;\n}\n`;\n\t}\n\tif (shaderSource.includes('cosh')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nfloat cosh(const float x) {\n\treturn (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; \n}\n`;\n\t}\n\tif (shaderSource.includes('tanh')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nfloat tanh(const float x) {\n\tfloat e = exp(2.0 * x);\n\treturn (e - 1.0) / (e + 1.0);\n}\n`;\n\t}\n\tif (shaderSource.includes('asinh')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nfloat asinh(const float x) {\n\treturn log(x + sqrt(x * x + 1.0));\n}\n`;\n\t}\n\tif (shaderSource.includes('asinh')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nfloat acosh(const float x) {\n\treturn log(x + sqrt(x * x - 1.0));\n}\n`;\n\t}\n\tif (shaderSource.includes('asinh')) {\n\t\tGLSL1_POLYFILLS += `\\n\\n\nfloat atanh(float x) {\n\tx = (x + 1.0) / (x - 1.0);\n\treturn 0.5 * log(x * sign(x));\n}\n`;\n\t}\n\n\treturn GLSL1_POLYFILLS;\n}\n\nfunction index1DToUV(type1: 'int' | 'uint', type2: 'ivec2' | 'uvec2' | 'vec2') {\nreturn`vec2 index1DToUV(const ${type1} index1D, const ${type2} dimensions) {\n\t${type1} width = ${type1}(dimensions.x);\n\t${type1} y = index1D / width;\n\t${type1} x = index1D - width * y;\n\tfloat u = (float(x) + 0.5) / float(dimensions.x);\n\tfloat v = (float(y) + 0.5) / float(dimensions.y);\n\treturn vec2(u, v);\n}`;\n}\nfunction modi(type1: TI | TU, type2: TI | TU) { return `${type1} modi(const ${type1} x, const ${type2} y) { return x - y * (x / y); }`; }\nfunction stepi(type1: TI | TU, type2: TI | TU) { return `${type2} stepi(const ${type1} x, const ${type2} y) { return ${type2}(step(${floatTypeForIntType(type1)}(x), ${floatTypeForIntType(type2)}(y))); }`; }\nfunction bitshiftLeft(type1: TI | TU, type2: TI | TU) {\nreturn`${type1} bitshiftLeft(const ${type1} a, const ${type2} b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a << b;\n\t#else\n\t\treturn a * ${type1}(pow(${floatTypeForIntType(type2)}(2.0), ${floatTypeForIntType(type2)}(b)));\n\t#endif\n}`;\n}\nfunction bitshiftRight(type1: TI | TU, type2: TI | TU) {\nreturn `${type1} bitshiftRight(const ${type1} a, const ${type2} b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a >> b;\n\t#else\n\t\treturn ${type1}(round(${floatTypeForIntType(type1)}(a) / pow(${floatTypeForIntType(type2)}(2.0), ${floatTypeForIntType(type2)}(b))));\n\t#endif\n}`; }\n// Copied from https://github.com/gpujs/gpu.js/blob/master/src/backend/web-gl/fragment-shader.js\n// Seems like these could be optimized.\nfunction bitwiseOr(numBits: 8 | 16 | 32) {\nreturn `int bitwiseOr${numBits === 32 ? '' : numBits}(int a, int b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a | b;\n\t#else\n\t\tint result = 0;\n\t\tint n = 1;\n\t\t\n\t\tfor (int i = 0; i < ${numBits}; i++) {\n\t\t\tif ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\n\t\t\t\tresult += n;\n\t\t\t}\n\t\t\ta = a / 2;\n\t\t\tb = b / 2;\n\t\t\tn = n * 2;\n\t\t\tif(!(a > 0 || b > 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t#endif\n}`; };\nfunction bitwiseXOR(numBits: 8 | 16 | 32) {\nreturn `int bitwiseXOR${numBits === 32 ? '' : numBits}(int a, int b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a ^ b;\n\t#else\n\t\tint result = 0;\n\t\tint n = 1;\n\t\t\n\t\tfor (int i = 0; i < ${numBits}; i++) {\n\t\t\tif ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\n\t\t\t\tresult += n;\n\t\t\t}\n\t\t\ta = a / 2;\n\t\t\tb = b / 2;\n\t\t\tn = n * 2;\n\t\t\tif(!(a > 0 || b > 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t#endif\n}`; }\nfunction bitwiseAnd(numBits: 8 | 16 | 32) {\nreturn `int bitwiseAnd${numBits === 32 ? '' : numBits}(int a, int b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a & b;\n\t#else\n\t\tint result = 0;\n\t\tint n = 1;\n\t\tfor (int i = 0; i < ${numBits}; i++) {\n\t\t\tif ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n\t\t\t\tresult += n;\n\t\t\t}\n\t\t\ta = a / 2;\n\t\t\tb = b / 2;\n\t\t\tn = n * 2;\n\t\t\tif(!(a > 0 && b > 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t#endif\n}`; };\nfunction bitwiseNot(numBits: 8 | 16 | 32) {\nreturn `int bitwiseNot${numBits === 32 ? '' : numBits}(int a) {\n\t#if (__VERSION__ == 300)\n\t\treturn ~a;\n\t#else\n\t\tint result = 0;\n\t\tint n = 1;\n\n\t\tfor (int i = 0; i < ${numBits}; i++) {\n\t\t\tif (modi(a, 2) == 0) {\n\t\t\t\tresult += n;\n\t\t\t}\n\t\t\ta = a / 2;\n\t\t\tn = n * 2;\n\t\t}\n\t\treturn result;\n\t#endif\n}`; }\n\n/**\n * Polyfills to be make available for both GLSL1 and GLSL3 fragment shaders.\n * @private\n */\nexport function fragmentShaderPolyfills(shaderSource: string, glslVersion: GLSLVersion) {\n\t// We'll attempt to just add in what we need, but no worries if we add extraneous functions.\n\t// They will be removed by compiler.\n\tlet FRAGMENT_SHADER_POLYFILLS = '';\n\n\t// index1DToUV gives UV coords for 1D indices (for 1D GPULayers).\n\tif (shaderSource.includes('index1DToUV')) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${index1DToUV('int', 'ivec2')}\n${index1DToUV('int', 'vec2')}\n#if (__VERSION__ == 300)\n${index1DToUV('int', 'uvec2')}\n${index1DToUV('uint', 'uvec2')}\n${index1DToUV('uint', 'ivec2')}\n${index1DToUV('uint', 'vec2')}\n#endif\n`;\n\t}\n\n\t// modi is called from GLSL1 bitwise polyfills.\n\tif (shaderSource.includes('modi') || (glslVersion === GLSL1 && shaderSource.includes('bitwise'))) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${modi('int', 'int')}\n${modi('ivec2', 'ivec2')}\n${modi('ivec3', 'ivec3')}\n${modi('ivec4', 'ivec4')}\n${modi('ivec2', 'int')}\n${modi('ivec3', 'int')}\n${modi('ivec4', 'int')}\n#if (__VERSION__ == 300)\n${modi('uint', 'uint')}\n${modi('uvec2', 'uvec2')}\n${modi('uvec3', 'uvec3')}\n${modi('uvec4', 'uvec4')}\n${modi('uvec2', 'uint')}\n${modi('uvec3', 'uint')}\n${modi('uvec4', 'uint')}\n#endif\n`;\n\t}\n\tif (shaderSource.includes('stepi')) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${stepi('int', 'int')}\n${stepi('ivec2', 'ivec2')}\n${stepi('ivec3', 'ivec3')}\n${stepi('ivec4', 'ivec4')}\n${stepi('int', 'ivec2')}\n${stepi('int', 'ivec3')}\n${stepi('int', 'ivec4')}\n#if (__VERSION__ == 300)\n${stepi('uint', 'uint')}\n${stepi('uvec2', 'uvec2')}\n${stepi('uvec3', 'uvec3')}\n${stepi('uvec4', 'uvec4')}\n${stepi('uint', 'uvec2')}\n${stepi('uint', 'uvec3')}\n${stepi('uint', 'uvec4')}\n#endif\n`;\n\t}\n\n\tif (shaderSource.includes('bitshiftLeft')) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${bitshiftLeft('int', 'int')}\n${bitshiftLeft('ivec2', 'ivec2')}\n${bitshiftLeft('ivec3', 'ivec3')}\n${bitshiftLeft('ivec4', 'ivec4')}\n${bitshiftLeft('ivec2', 'int')}\n${bitshiftLeft('ivec3', 'int')}\n${bitshiftLeft('ivec4', 'int')}\n#if (__VERSION__ == 300)\n${bitshiftLeft('uint', 'uint')}\n${bitshiftLeft('uvec2', 'uvec2')}\n${bitshiftLeft('uvec3', 'uvec3')}\n${bitshiftLeft('uvec4', 'uvec4')}\n${bitshiftLeft('uvec2', 'uint')}\n${bitshiftLeft('uvec3', 'uint')}\n${bitshiftLeft('uvec4', 'uint')}\n#endif\n`;\n\t}\n\n\tif (shaderSource.includes('bitshiftRight')) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${bitshiftRight('int', 'int')}\n${bitshiftRight('ivec2', 'ivec2')}\n${bitshiftRight('ivec3', 'ivec3')}\n${bitshiftRight('ivec4', 'ivec4')}\n${bitshiftRight('ivec2', 'int')}\n${bitshiftRight('ivec3', 'int')}\n${bitshiftRight('ivec4', 'int')}\n#if (__VERSION__ == 300)\n${bitshiftRight('uint', 'uint')}\n${bitshiftRight('uvec2', 'uvec2')}\n${bitshiftRight('uvec3', 'uvec3')}\n${bitshiftRight('uvec4', 'uvec4')}\n${bitshiftRight('uvec2', 'uint')}\n${bitshiftRight('uvec3', 'uint')}\n${bitshiftRight('uvec4', 'uint')}\n#endif\n`;\n\t}\n\n\tif (shaderSource.includes('bitwiseOr')) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${bitwiseOr(8)}\n${bitwiseOr(16)}\n${bitwiseOr(32)}\n#if (__VERSION__ == 300)\n${ [8, 16, ''].map(suffix => {\nreturn `\nuint bitwiseOr${suffix}(uint a, uint b) {\n\treturn uint(bitwiseOr${suffix}(int(a), int(b)));\n}`;\n}).join('\\n') }\n#endif\n`;\n\t}\n\n\tif (shaderSource.includes('bitwiseXOR')) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${bitwiseXOR(8)}\n${bitwiseXOR(16)}\n${bitwiseXOR(32)}\n#if (__VERSION__ == 300)\n${ [8, 16, ''].map(suffix => {\nreturn `\nuint bitwiseXOR${suffix}(uint a, uint b) {\n\treturn uint(bitwiseXOR${suffix}(int(a), int(b)));\n}`;\n}).join('\\n') }\n#endif\n`;\n\t}\n\n\tif (shaderSource.includes('bitwiseAnd')) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${bitwiseAnd(8)}\n${bitwiseAnd(16)}\n${bitwiseAnd(32)}\n#if (__VERSION__ == 300)\n${ [8, 16, ''].map(suffix => {\nreturn `\nuint bitwiseAnd${suffix}(uint a, uint b) {\n\treturn uint(bitwiseAnd${suffix}(int(a), int(b)));\n}`;\n}).join('\\n') }\n#endif\n`;\n\t}\n\n\tif (shaderSource.includes('bitwiseNot')) {\n\t\tFRAGMENT_SHADER_POLYFILLS += `\\n\n${bitwiseNot(8)}\n${bitwiseNot(16)}\n${bitwiseNot(32)}\n#if (__VERSION__ == 300)\n${ [8, 16, ''].map(suffix => {\nreturn `\nuint bitwiseNot${suffix}(uint a) {\n\treturn uint(bitwiseNot${suffix}(int(a)));\n}`;\n}).join('\\n') }\n#endif\n`;\n\t}\n\n\treturn FRAGMENT_SHADER_POLYFILLS;\n}\n","import { GLSLVersion, GLSL3 } from './constants';\n\n/**\n * Helper functions for converting GLSL3 to GLSL1 and checking for valid shader code.\n * Note: there is no positive lookbehind support in some browsers, use capturing parens instead.\n * https://stackoverflow.com/questions/3569104/positive-look-behind-in-javascript-regular-expression/3569116#3569116\n */\n\ntype GLSLType = 'float' | 'int' | 'uint' | 'vec2' | 'vec3' | 'vec4' | 'ivec2' | 'ivec3' | 'ivec4' | 'uvec2' | 'uvec3' | 'uvec4';\n\n/**\n * Convert vertex shader \"in\" to \"attribute\".\n * @private\n */\nexport function glsl1VertexIn(shaderSource: string) {\n\treturn shaderSource.replace(/\\bin\\b/g, 'attribute');\n}\n\nfunction escapeRegExp(string: string){\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * Typecast variable assignment.\n * This is used in cases when e.g. varyings have to be converted to float in GLSL1.\n */\nfunction typecastVariable(shaderSource: string, variableName: string, type: string) {\n\t// \"s\" makes this work for multiline values.\n\t// Do this without lookbehind to support older browsers.\n\t// const regexMatch = new RegExp(`(?<=\\\\b${escapeRegExp(variableName)}\\\\s*=\\\\s*)\\\\S[^;]*(?=;)`, 'sg');\n\tconst regexMatch = new RegExp(`\\\\b${escapeRegExp(variableName)}\\\\s*=\\\\s*\\\\S[^;]*;`, 'sg');\n\tconst assignmentExpressions = shaderSource.match(regexMatch);\n\tif (assignmentExpressions) {\n\t\t// Loop through all places where variable is assigned and typecast.\n\t\tfor (let i = 0; i < assignmentExpressions.length; i++) {\n\t\t\tconst regexValueMatch = new RegExp(`\\\\b${escapeRegExp(variableName)}\\\\s*=\\\\s*(\\\\S[^;]*);`, 's');\n\t\t\tconst value = assignmentExpressions[i].match(regexValueMatch);\n\t\t\tif (value && value[1]) {\n\t\t\t\tconst regexReplace = new RegExp(`\\\\b${escapeRegExp(variableName)}\\\\s*=\\\\s*${escapeRegExp(value[1])}\\\\s*;`, 's');\n\t\t\t\tshaderSource = shaderSource.replace(regexReplace, `${variableName} = ${type}(${value[1]});`);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Could not find value in expression: \"${assignmentExpressions[i]}\"`);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconsole.warn(`No assignment found for shader variable ${variableName}.`);\n\t}\n\treturn shaderSource;\n}\n\n/**\n * Convert int varyings to float types.\n * Also update any variable assignments so that they are cast to float.\n * @private\n */\nfunction _castVaryingToFloat(shaderSource: string, regexString: string, type: string) {\n\t// Do this without lookbehind to support older browsers.\n\t// const regexMatch = new RegExp(`(?<=${regexString}\\\\s+)\\\\S[^;]*(?=;)`, 'g');\n\tconst regexMatch = new RegExp(`${regexString}\\\\s+\\\\S[^;]*;`, 'g');\n\tconst castToFloatExpressions = shaderSource.match(regexMatch);\n\tif (castToFloatExpressions) {\n\t\t// Replace all with new type.\n\t\tconst regexReplace = new RegExp(`${regexString}\\\\b`, 'g');\n\t\tshaderSource = shaderSource.replace(regexReplace, `varying ${type}`);\n\t\t// Loop through each expression, grab variable name, and cast all assignments.\n\t\tfor (let i = 0; i < castToFloatExpressions.length; i++) {\n\t\t\tconst regexVariableMatch = new RegExp(`${regexString}\\\\s+(\\\\S[^;]*);`);\n\t\t\tconst variable = castToFloatExpressions[i].match(regexVariableMatch);\n\t\t\tif (variable && variable[2]) {\n\t\t\t\tshaderSource = typecastVariable(shaderSource, variable[2], type);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Could not find variable name in expression: \"${castToFloatExpressions[i]}\"`);\n\t\t\t}\n\t\t}\n\t}\n\treturn shaderSource;\n}\n\n/**\n * Convert int varyings to float types.\n * Only exported for testing.\n * @private\n */\nexport function castVaryingToFloat(shaderSource: string) {\n\t// Need to init all expressions with the same number of capturing groups\n\t// so that this will work in _castVaryingToFloat.\n\tshaderSource = _castVaryingToFloat(shaderSource, '\\\\bvarying\\\\s+(u)?int', 'float');\n\tshaderSource = _castVaryingToFloat(shaderSource, '\\\\bvarying\\\\s+(i|u)vec2', 'vec2');\n\tshaderSource = _castVaryingToFloat(shaderSource, '\\\\bvarying\\\\s+(i|u)vec3', 'vec3');\n\tshaderSource = _castVaryingToFloat(shaderSource, '\\\\bvarying\\\\s+(i|u)vec4', 'vec4');\n\treturn shaderSource;\n}\n\n/**\n * Convert vertex shader \"out\" to \"varying\".\n * Also remove \"flat\" if necessary.\n * Also cast as float if necessary.\n * @private\n */\nexport function glsl1VertexOut(shaderSource: string) {\n\tshaderSource = shaderSource.replace(/(\\bflat\\s+)?\\bout\\b/g, 'varying');\n\tshaderSource = castVaryingToFloat(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Convert fragment shader \"in\" to \"varying\".\n * Also remove \"flat\" if necessary.\n * Also cast as float if necessary.\n * @private\n */\nexport function glsl1FragmentIn(shaderSource: string) {\n\tshaderSource = shaderSource.replace(/(\\bflat\\s+)?\\bin\\b/g, 'varying');\n\tshaderSource = castVaryingToFloat(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Get variable name, type, and layout number for out variables.\n * Only exported for testing.\n * @private\n */\nexport function getFragmentOuts(shaderSource: string, programName: string) {\n\tconst outs: { [key: string]: {\n\t\tlocation: number,\n\t\ttype: GLSLType,\n\t}} = {};\n\tlet maxLocation = 0;\n\twhile (true) {\n\t\t// Do this without lookbehind to support older browsers.\n\t\tconst match = shaderSource.match(/\\b(layout\\s*\\(\\s*location\\s*=\\s*([0-9]+)\\s*\\)\\s*)?out\\s+((lowp|mediump|highp)\\s+)?((float|int|uint|([iu]?vec[234]))\\s+)?([_$a-zA-Z0-9]+)\\s*;/);\n\t\tif (!match) {\n\t\t\tif (Object.keys(outs).length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\t// Sort by location.\n\t\t\tconst variableNames = Object.keys(outs);\n\t\t\tconst numVariables = variableNames.length;\n\t\t\tconst outsSorted: {\n\t\t\t\tname: string,\n\t\t\t\ttype: GLSLType,\n\t\t\t}[] = new Array(maxLocation).fill(undefined);\n\t\t\t\n\t\t\tfor (let i = 0; i < numVariables; i++) {\n\t\t\t\tconst name = variableNames[i];\n\t\t\t\tconst { location, type } = outs[name];\n\t\t\t\tif (outsSorted[location] !== undefined) {\n\t\t\t\t\tthrow new Error(`Must be exactly one out declaration per layout location in GPUProgram \"${programName}\", conflicting declarations found at location ${location}.`);\n\t\t\t\t}\n\t\t\t\toutsSorted[location] =  { name, type };\n\t\t\t}\n\t\t\tif (variableNames.length !== maxLocation + 1) {\n\t\t\t\tthrow new Error(`Must be exactly one out declaration per layout location in GPUProgram \"${programName}\", layout locations must be sequential (no missing location numbers) starting from 0.`);\n\t\t\t}\n\t\t\tfor (let i = 0; i <= maxLocation; i++) {\n\t\t\t\tif (outsSorted[i] === undefined) {\n\t\t\t\t\tthrow new Error(`Missing out declaration at location ${i} in GPUProgram \"${programName}\", layout locations must be sequential (no missing location numbers) starting from 0.`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn outsSorted;\n\t\t}\n\t\t// Save out parameters.\n\t\tconst name = match[8];\n\t\tconst location = parseInt(match[2] || '0');\n\t\tconst type = match[6] as GLSLType;\n\t\tif (!type) {\n\t\t\tthrow new Error(`No type found for out declaration \"${match[0]}\" for GPUProgram \"${programName}\".`);\n\t\t}\n\t\tif (!name) {\n\t\t\tthrow new Error(`No variable name found for out declaration \"${match[0]}\" for GPUProgram \"${programName}\".`);\n\t\t}\n\t\tif (outs[name]) {\n\t\t\tif (outs[name].location !== location) {\n\t\t\t\tthrow new Error(`All out declarations for variable \"${name}\" must have same location in GPUProgram \"${programName}\".`);\n\t\t\t}\n\t\t} else {\n\t\t\tif (location > maxLocation) maxLocation = location;\n\t\t\touts[name] = {\n\t\t\t\tlocation,\n\t\t\t\ttype,\n\t\t\t};\n\t\t}\n\t\t// Remove out definition so we can match to the next one.\n\t\tshaderSource = shaderSource.replace(match[0], '');\n\t}\n}\n\n/**\n * Convert out variables to gl_FragColor.\n * @private\n */\nexport function glsl1FragmentOut(shaderSource: string, programName: string) {\n\tconst outs = getFragmentOuts(shaderSource, programName);\n\tif (outs.length === 0) {\n\t\treturn [shaderSource];\n\t}\n\t// Remove layout declarations.\n\tshaderSource = shaderSource.replace(/\\blayout\\s*\\(\\s*location\\s*=\\s*([0-9]+)\\s*\\)\\s*/g, '');\n\t// If we detect multiple out declarations, we need to split the shader source.\n\n\tconst shaderSources: string[] = [];\n\tfor (let i = 0, numOuts = outs.length; i < numOuts; i++) {\n\t\tconst { type, name } = outs[i];\n\n\t\t// Remove out declaration for this variable.\n\t\tconst outRegex = new RegExp(`\\\\bout\\\\s+((lowp|mediump|highp)\\\\s+)?(float|int|uint|([iu]?vec[234]))\\\\s+${name}\\\\s*;`, 'g');\n\t\tlet outShaderSource = shaderSource.replace(outRegex, '');\n\t\t// Remove any other out declarations.\n\t\toutShaderSource = outShaderSource.replace(/\\bout\\b/g, '');\n\n\t\tlet assignmentFound = false;\n\t\t// Replace each instance of \"name =\" with gl_FragColor = and cast to vec4.\n\t\t// Do this without lookbehind to support older browsers.\n\t\t// const output = outShaderSource.match(/(?<=\\b${name}\\s*=\\s*)\\S.*(?=;)/s); // /s makes this work for multiline.\n\t\t// ? puts this in lazy mode (match shortest strings).\n\t\tconst regex = new RegExp(`\\\\b${name}\\\\s*=\\\\s*(\\\\S.*?);`, 's'); // 's' makes this work for multiline.\n\t\twhile (true) {\n\t\t\tconst output = outShaderSource.match(regex);\n\t\t\tif (output && output[1]) {\n\t\t\t\tassignmentFound = true;\n\t\t\t\tlet filler = '';\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'float':\n\t\t\t\t\tcase 'int':\n\t\t\t\t\tcase 'uint':\n\t\t\t\t\t\tfiller = ', 0, 0, 0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vec2':\n\t\t\t\t\tcase 'ivec2':\n\t\t\t\t\tcase 'uvec2':\n\t\t\t\t\t\tfiller = ', 0, 0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vec3':\n\t\t\t\t\tcase 'ivec3':\n\t\t\t\t\tcase 'uvec3':\n\t\t\t\t\t\tfiller = ', 0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toutShaderSource = outShaderSource.replace(regex, `gl_FragColor = vec4(${output[1]}${filler});`);\n\t\t\t} else {\n\t\t\t\tif (!assignmentFound) throw new Error(`No assignment found for out declaration in GPUProgram \"${programName}\".`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tshaderSources.push(outShaderSource);\n\t}\n\treturn shaderSources;\n}\n\n/**\n * Contains gl_FragColor.\n * @private\n */\n function containsGLFragColor(shaderSource: string) {\n\treturn !!shaderSource.match(/\\bgl_FragColor\\b/);\n}\n\n/**\n * Check for presence of gl_FragColor in fragment shader source.\n * @private \n */\n export function checkFragmentShaderForFragColor(shaderSource: string, glslVersion: GLSLVersion, name: string) {\n\tconst gl_FragColor = containsGLFragColor(shaderSource);\n\tif (glslVersion === GLSL3) {\n\t\t// Check that fragment shader source DOES NOT contain gl_FragColor\n\t\tif (gl_FragColor) {\n\t\t\tthrow new Error(`Found \"gl_FragColor\" declaration in fragment shader for GPUProgram \"${name}\": either init GPUComposer with glslVersion = GLSL1 or use GLSL3 syntax in your fragment shader.`);\n\t\t}\n\t}\n}\n\n/**\n * Convert texture to texture2D.\n * @private\n */\nexport function glsl1Texture(shaderSource: string) {\n\treturn shaderSource.replace(/\\btexture\\(/g, 'texture2D(');\n}\n\n/**\n * Convert isampler2D and usampler2D to sampler2D.\n * @private\n */\nexport function glsl1Sampler2D(shaderSource: string) {\n\treturn shaderSource.replace(/\\b(i|u)sampler2D\\b/g, 'sampler2D');\n}\n\n/**\n * Unsigned int types are not supported, use int types instead.\n * @private\n */\nexport function glsl1Uint(shaderSource: string) {\n\tshaderSource = shaderSource.replace(/\\buint\\b/g, 'int');\n\tshaderSource = shaderSource.replace(/\\buvec2\\b/g, 'ivec2');\n\tshaderSource = shaderSource.replace(/\\buvec3\\b/g, 'ivec3');\n\tshaderSource = shaderSource.replace(/\\buvec4\\b/g, 'ivec4');\n\tshaderSource = shaderSource.replace(/\\buint\\(/g, 'int(');\n\tshaderSource = shaderSource.replace(/\\buvec2\\(/g, 'ivec2(');\n\tshaderSource = shaderSource.replace(/\\buvec3\\(/g, 'ivec3(');\n\tshaderSource = shaderSource.replace(/\\buvec4\\(/g, 'ivec4(');\n\treturn shaderSource;\n}\n\n/**\n * Replace all highp with mediump.\n * @private\n */\nexport function highpToMediump(shaderSource: string) {\n\treturn shaderSource.replace(/\\bhighp\\b/, 'mediump');\n}\n\n/**\n * Strip out any version numbers.\n * https://github.com/Jam3/glsl-version-regex\n * @private\n */\nexport function stripVersion(shaderSource: string) {\n\tconst origLength = shaderSource.length;\n\tshaderSource = shaderSource.replace(/^\\s*\\#version\\s+([0-9]+(\\s+(es)+)?)\\s*/, '');\n\tif (shaderSource.length !== origLength) {\n\t\tconsole.warn('GPUIO expects shader source that does not contain #version declarations, removing....');\n\t}\n\treturn shaderSource;\n}\n\n/**\n * Strip out any precision declarations.\n * @private\n */\nexport function stripPrecision(shaderSource: string) {\n\tconst origLength = shaderSource.length;\n\tshaderSource = shaderSource.replace(/\\s*precision\\s+((highp)|(mediump)|(lowp))\\s+[a-zA-Z0-9]+\\s*;/g, '');\n\tif (shaderSource.length !== origLength) {\n\t\tconsole.warn('GPUIO expects shader source that does not contain precision declarations, removing....');\n\t}\n\treturn shaderSource;\n}\n\n/**\n * Strip out comments from shader code.\n * @private\n */\nexport function stripComments(shaderSource: string) {\n\tshaderSource = shaderSource.replace(/[\\t ]*\\/\\/.*\\n/g, ''); // Remove single-line comments.\n\t// ? puts this in lazy mode (match shortest strings).\n\tshaderSource = shaderSource.replace(/\\/\\*.*?\\*\\//gs, ''); /* Remove multi-line comments */\n\treturn shaderSource;\n}\n\n/**\n * Get the number of sampler2D's in a fragment shader program.\n * @private\n */\nexport function getSampler2DsInProgram(shaderSource: string) {\n\t// Do this without lookbehind to support older browsers.\n\t// const samplers = shaderSource.match(/(?<=\\buniform\\s+(((highp)|(mediump)|(lowp))\\s+)?(i|u)?sampler2D\\s+)\\w+(?=\\s?;)/g);\n\tconst samplersNoDuplicates: {[key: string]: boolean} = {};\n\tconst regex = '\\\\buniform\\\\s+(((highp)|(mediump)|(lowp))\\\\s+)?(i|u)?sampler2D\\\\s+(\\\\w+)\\\\s*;';\n\tconst samplers = shaderSource.match(new RegExp(regex, 'g'));\n\tif (!samplers || samplers.length === 0) return [];\n\t// We need to be a bit careful as same sampler could be declared multiple times if compile time conditionals are used.\n\t// Extract uniform name.\n\tconst uniformMatch = new RegExp(regex);\n\tsamplers.forEach(sampler => {\n\t\tconst uniform = sampler.match(uniformMatch);\n\t\tif (!uniform || !uniform[7]) {\n\t\t\tconsole.warn(`Could not find sampler2D uniform name in string \"${sampler}\".`);\n\t\t\treturn;\n\t\t}\n\t\tsamplersNoDuplicates[uniform[7]] = true;\n\t})\n\treturn Object.keys(samplersNoDuplicates);\n}","import {\n\tisArray,\n\tisBoolean,\n\tisFiniteNumber,\n\tisInteger,\n\tisNonNegativeInteger,\n\tisString,\n} from '@amandaghassaei/type-checks';\nimport {\n\tBOOL,\n\tBOOL_1D_UNIFORM,\n\tBOOL_2D_UNIFORM,\n\tBOOL_3D_UNIFORM,\n\tBOOL_4D_UNIFORM,\n\tBYTE,\n\tCompileTimeConstants,\n\tDEFAULT_ERROR_CALLBACK,\n\tErrorCallback,\n\tFLOAT,\n\tFLOAT_1D_UNIFORM,\n\tFLOAT_2D_UNIFORM,\n\tFLOAT_3D_UNIFORM,\n\tFLOAT_4D_UNIFORM,\n\tGLSL1,\n\tGLSL3,\n\tGLSLPrecision,\n\tGLSLVersion,\n\tGPUIO_FLOAT_PRECISION,\n\tGPUIO_INT_PRECISION,\n\tGPULayerState,\n\tGPULayerType,\n\tHALF_FLOAT,\n\tINT,\n\tINT_1D_UNIFORM,\n\tINT_2D_UNIFORM,\n\tINT_3D_UNIFORM,\n\tINT_4D_UNIFORM,\n\tPRECISION_HIGH_P,\n\tPRECISION_MEDIUM_P,\n\tSHORT,\n\tUINT,\n\tUINT_1D_UNIFORM,\n\tUINT_2D_UNIFORM,\n\tUINT_3D_UNIFORM,\n\tUINT_4D_UNIFORM,\n\tUniformType,\n\tUniformValue,\n\tUNSIGNED_BYTE,\n\tUNSIGNED_INT,\n\tUNSIGNED_SHORT,\n\tWEBGL1,\n\tWEBGL2,\n} from './constants';\nimport { intForPrecision } from './conversions';\nimport { PRECISION_SOURCE } from './glsl/common/precision';\nimport type { GPUComposer } from './GPUComposer';\nimport type { GPULayer } from './GPULayer';\nimport { fragmentShaderPolyfills, GLSL1Polyfills, texturePolyfill } from './polyfills';\nimport {\n\tcheckFragmentShaderForFragColor,\n\tglsl1FragmentIn,\n\tglsl1FragmentOut,\n\tglsl1Sampler2D,\n\tglsl1Texture,\n\tglsl1Uint,\n\tglsl1VertexIn,\n\tglsl1VertexOut,\n\thighpToMediump,\n\tstripComments,\n\tstripPrecision,\n\tstripVersion,\n} from './regex';\n\n/**\n * Memoize results of more complex WebGL tests (that require allocations/deallocations).\n * @private\n */\nconst results = {\n\tsupportsWebGL2: undefined as undefined | boolean,\n\tsupportsHighpVertex: undefined as  undefined | boolean,\n\tsupportsHighpFragment: undefined as undefined | boolean,\n\tmediumpVertexPrecision: undefined as undefined | typeof PRECISION_HIGH_P | typeof PRECISION_MEDIUM_P,\n\tmediumpFragmentPrecision: undefined as undefined | typeof PRECISION_HIGH_P | typeof PRECISION_MEDIUM_P,\n}\n\n/**\n * Test whether a GPULayer type is a float type.\n * @private\n */\nexport function isFloatType(type: GPULayerType) {\n\treturn type === FLOAT || type === HALF_FLOAT;\n}\n\n/**\n * Test whether a GPULayer type is an unsigned int type.\n * @private\n */\n export function isUnsignedIntType(type: GPULayerType) {\n\treturn type === UNSIGNED_BYTE || type === UNSIGNED_SHORT || type === UNSIGNED_INT;\n}\n\n/**\n * Test whether a GPULayer type is a signed int type.\n * @private\n */\n export function isSignedIntType(type: GPULayerType) {\n\treturn type === BYTE || type === SHORT || type === INT;\n}\n\n/**\n * Test whether a GPULayer type is a int type.\n * @private\n */\n export function isIntType(type: GPULayerType) {\n\treturn isUnsignedIntType(type) || isSignedIntType(type);\n}\n\n/**\n * Create a string to pass compile time constants into shader.\n * @private\n */\nfunction convertCompileTimeConstantsToString(compileTimeConstants: CompileTimeConstants) {\n\tlet CTCSource = '';\n\tconst keys = Object.keys(compileTimeConstants);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\t// Check that define is passed in as a string.\n\t\tif (!isString(key) || !isString(compileTimeConstants[key])) {\n\t\t\tthrow new Error(`GPUProgram compile time constants must be passed in as key value pairs that are both strings, got key value pair of type [${typeof key} : ${typeof compileTimeConstants[key]}] for key ${key}.`)\n\t\t}\n\t\tCTCSource += `#define ${key} ${compileTimeConstants[key]}\\n`;\n\t}\n\treturn CTCSource;\n}\n\n/**\n * Create header string for fragment and vertex shaders.\n * Export this for testing purposes.\n * @private\n */\nexport function makeShaderHeader(\n\tglslVersion: GLSLVersion,\n\tintPrecision: GLSLPrecision,\n\tfloatPrecision: GLSLPrecision,\n\tcompileTimeConstants?: CompileTimeConstants,\n\textensions?: string,\n) {\n\tconst versionSource = glslVersion === GLSL3 ? `#version ${GLSL3}\\n` : '';\n\tconst compileTimeConstantsSource = compileTimeConstants ? convertCompileTimeConstantsToString(compileTimeConstants) : '';\n\tconst precisionConstantsSource = convertCompileTimeConstantsToString({\n\t\t[GPUIO_INT_PRECISION]: `${intForPrecision(intPrecision)}`,\n\t\t[GPUIO_FLOAT_PRECISION]: `${intForPrecision(floatPrecision)}`,\n\t});\n\treturn `${versionSource}${extensions ? extensions : ''}${compileTimeConstantsSource}${precisionConstantsSource}${PRECISION_SOURCE}`;\n}\n\n/**\n * Compile vertex or fragment shaders.\n * Fragment shaders may be compiled on the fly, so keep this efficient.\n * Copied from http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html\n * @private\n */\nexport function compileShader(\n\tgl: WebGLRenderingContext | WebGL2RenderingContext,\n\tglslVersion: GLSLVersion,\n\tintPrecision: GLSLPrecision,\n\tfloatPrecision: GLSLPrecision,\n\tshaderSource: string,\n\tshaderType: number,\n\tprogramName: string,\n\terrorCallback: ErrorCallback,\n\tcompileTimeConstants?: CompileTimeConstants,\n\textensions?: string,\n\tcheckCompileStatus = false,\n) {\n\t// Create the shader object\n\tconst shader = gl.createShader(shaderType);\n\tif (!shader) {\n\t\terrorCallback('Unable to init gl shader.');\n\t\treturn null;\n\t}\n\n\t// Set the shader source code.\n\tconst shaderHeader = makeShaderHeader(\n\t\tglslVersion,\n\t\tintPrecision,\n\t\tfloatPrecision,\n\t\tcompileTimeConstants,\n\t\textensions,\n\t);\n\tconst fullShaderSource = `${shaderHeader}${shaderSource}`;\n\tgl.shaderSource(shader, fullShaderSource);\n\n\t// Compile the shader\n\tgl.compileShader(shader);\n\n\tif (checkCompileStatus) {\n\t\t// Check if shaders compiled - do this only on the first compilation bc of:\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#dont_check_shader_compile_status_unless_linking_fails\n\t\tconst success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t\tif (!success) {\n\t\t\t// Something went wrong during compilation - print shader source (with line number) and the error.\n\t\t\tconsole.log(fullShaderSource.split('\\n').map((line, i) => `${i}\\t${line}`).join('\\n'));\n\t\t\terrorCallback(`Could not compile ${shaderType === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'} shader for program \"${programName}\": ${gl.getShaderInfoLog(shader)}.`);\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn shader;\n}\n\n/**\n * Init a WebGL program from vertex and fragment shaders.\n * GLPrograms may be inited on the fly, so keep this efficient.\n * @private\n */\nexport function initGLProgram(\n\tgl: WebGLRenderingContext | WebGL2RenderingContext,\n\tvertexShader: WebGLShader,\n\tfragmentShader: WebGLShader,\n\tname: string,\n\terrorCallback: ErrorCallback,\n) {\n\t// Create a program.\n\tconst program = gl.createProgram();\n\tif (!program) {\n\t\terrorCallback(`Unable to init GL program for GPUProgram \"${name}\", gl.createProgram() has failed.`);\n\t\treturn;\n\t}\n\t// Link the program.\n\tgl.attachShader(program, vertexShader);\n\tgl.attachShader(program, fragmentShader);\n\tgl.linkProgram(program);\n\t// Check if it linked.\n\tconst success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\tif (!success) {\n\t\t// Something went wrong with the link.\n\t\terrorCallback(`GPUProgram \"${name}\" failed to link: ${gl.getProgramInfoLog(program)}`);\n\t\treturn;\n\t}\n\treturn program;\n}\n\n/**\n * Returns whether a WebGL context is WebGL2.\n * This code is pulled from https://github.com/mrdoob/three.js/blob/master/src/renderers/webgl/WebGLCapabilities.js\n * @param gl - WebGL context to test.\n * @returns - true if WebGL2 context, else false.\n */\nexport function isWebGL2(gl: WebGLRenderingContext | WebGL2RenderingContext) {\n\t// @ts-ignore\n\treturn (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) || (typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext);\n}\n\n/**\n * Returns whether WebGL2 is supported by the current browser.\n * @returns - true if WebGL2 is supported, else false.\n*/\nexport function isWebGL2Supported() {\n\tif (results.supportsWebGL2 === undefined) {\n\t\tconst gl = document.createElement('canvas').getContext(WEBGL2);\n\t\t// GL context and canvas will be garbage collected.\n\t\tresults.supportsWebGL2 = isWebGL2(gl!); // Will return false in case of gl = null.\n\t}\n\treturn results.supportsWebGL2;\n}\n\n/**\n * Checks if the framebuffer is ready to read.\n * @private\n */\nexport function readyToRead(gl: WebGLRenderingContext | WebGL2RenderingContext) {\n\treturn gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE;\n};\n\n/**\n * Detects whether highp is supported by this browser.\n * This is supposed to be relatively easy. You call gl.getShaderPrecisionFormat, you pass in the shader type,\n * VERTEX_SHADER or FRAGMENT_SHADER and you pass in one of LOW_FLOAT, MEDIUM_FLOAT, HIGH_FLOAT, LOW_INT, MEDIUM_INT, HIGH_INT,\n * and it returns the precision info.\n * Unfortunately Safari has a bug here which means checking this way will fail on iPhone, at least as of April 2020.\n * https://webglfundamentals.org/webgl/webgl-precision-lowp-mediump-highp.html\n * @private\n */\nfunction isHighpSupported(vsSource: string, fsSource: string) {\n\tconst gl = document.createElement('canvas').getContext(WEBGL1);\n\tif (!gl) {\n\t\tthrow new Error(`Unable to init webgl context.`);\n\t}\n\ttry {\n\t\tconst vs = compileShader(\n\t\t\tgl,\n\t\t\tGLSL1,\n\t\t\tPRECISION_HIGH_P,\n\t\t\tPRECISION_HIGH_P,\n\t\t\tvsSource,\n\t\t\tgl.VERTEX_SHADER,\n\t\t\t'highpFragmentTest',\n\t\t\tDEFAULT_ERROR_CALLBACK,\n\t\t)!;\n\t\tconst fs = compileShader(\n\t\t\tgl,\n\t\t\tGLSL1,\n\t\t\tPRECISION_HIGH_P,\n\t\t\tPRECISION_HIGH_P,\n\t\t\tfsSource,\n\t\t\tgl.FRAGMENT_SHADER,\n\t\t\t'highpFragmentTest',\n\t\t\tDEFAULT_ERROR_CALLBACK,\n\t\t)!;\n\t\tconst program = initGLProgram(gl, vs, fs, 'highpFragmentTest', DEFAULT_ERROR_CALLBACK)!;\n\t\t// Deallocate everything.\n\t\tgl.deleteProgram(program);\n\t\tgl.deleteShader(vs);\n\t\tgl.deleteShader(fs);\n\t\t// GL context and canvas will be garbage collected.\n\t} catch {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/**\n * Detects whether highp precision is supported in vertex shaders in the current browser.\n * @returns - true is highp is supported in vertex shaders, else false.\n */\nexport function isHighpSupportedInVertexShader() {\n\tif (results.supportsHighpVertex === undefined) {\n\t\tconst vertexSupport = isHighpSupported(\n\t\t\t'void main() { highp float test = 0.524; gl_Position = vec4(test, test, 0, 1); }',\n\t\t\t'void main() { gl_FragColor = vec4(0); }',\n\t\t);\n\t\tresults.supportsHighpVertex = vertexSupport;\n\t}\n\treturn results.supportsHighpVertex;\n}\n\n/**\n * Detects whether highp precision is supported in fragment shaders in the current browser.\n * @returns - true is highp is supported in fragment shaders, else false.\n */\nexport function isHighpSupportedInFragmentShader() {\n\tif (results.supportsHighpFragment === undefined) {\n\t\tconst fragmentSupport = isHighpSupported(\n\t\t\t'void main() { gl_Position = vec4(0.5, 0.5, 0, 1); }',\n\t\t\t'void main() { highp float test = 1.35; gl_FragColor = vec4(test); }',\n\t\t);\n\t\tresults.supportsHighpFragment = fragmentSupport;\n\t}\n\treturn results.supportsHighpFragment;\n}\n\n/**\n * Helper function to perform a 1px math calculation in order to determine WebGL capabilities.\n * From https://webglfundamentals.org/\n * @private\n */\nfunction test1PxCalc(\n\tname: string,\n\tgl: WebGL2RenderingContext | WebGLRenderingContext,\n\tfs: WebGLShader,\n\tvs: WebGLShader,\n\taddUniforms: (program: WebGLProgram) => void,\n) {\n\tconst program = initGLProgram(gl, vs, fs, name, DEFAULT_ERROR_CALLBACK);\n\tif (!program) {\n\t\tthrow new Error(`Unable to init WebGLProgram.`);\n\t}\n\tconst positionLocation = gl.getAttribLocation(program, 'position');\n\n\t// create a buffer and setup an attribute\n\t// We wouldn't need this except for a bug in Safari.\n\t// See https://webglfundamentals.org/webgl/lessons/webgl-smallest-programs.html\n\t// and https://bugs.webkit.org/show_bug.cgi?id=197592\n\tconst buffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, 1, gl.STATIC_DRAW);\n\tgl.enableVertexAttribArray(positionLocation);\n\tgl.vertexAttribPointer(\n\t\tpositionLocation,\n\t\t1, // pull 1 value per vertex shader iteration from buffer\n\t\tgl.UNSIGNED_BYTE, // type of data in buffer,\n\t\tfalse, // don't normalize\n\t\t0, // bytes to advance per iteration (0 = compute from size and type)\n\t\t0, // offset into buffer\n\t);\n\n\tgl.viewport(0, 0, 1, 1);\n\tgl.useProgram(program);\n\n\taddUniforms(program);\n\t\n\tgl.drawArrays(\n\t\tgl.POINTS,\n\t\t0, // offset\n\t\t1, // number of vertices to process\n\t);\n\n\tconst pixel = new Uint8Array(4);\n\tgl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n\t// Deallocate everything.\n\tgl.disableVertexAttribArray(positionLocation);\n\tgl.deleteProgram(program);\n\tgl.deleteShader(vs);\n\tgl.deleteShader(fs);\n\tgl.deleteBuffer(buffer);\n\t// GL context and canvas will be garbage collected.\n\n\treturn pixel;\n}\n\n/**\n * Returns the actual precision of mediump inside vertex shader.\n * From https://webglfundamentals.org/webgl/lessons/webgl-precision-issues.html\n * @returns - Vertex shader mediump precision.\n */\nexport function getVertexShaderMediumpPrecision() {\n\tif (results.mediumpVertexPrecision === undefined) {\n\t\t// This entire program is only needed because of a bug in Safari.\n\t\t// Safari doesn't correctly report precision from getShaderPrecisionFormat\n\t\t// at least as of April 2020\n\t\t// see: https://bugs.webkit.org/show_bug.cgi?id=211013\n\n\t\t// Get A WebGL context\n\t\t/** @type {HTMLCanvasElement} */\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tconst gl = canvas.getContext(\"webgl\");\n\t\tif (!gl) {\n\t\t\tthrow new Error(`Unable to init webgl context.`);\n\t\t}\n\n\t\tconst vs = compileShader(gl, GLSL1, PRECISION_MEDIUM_P, PRECISION_MEDIUM_P, `\n\tattribute vec4 position;  // needed because of another bug in Safari\n\tuniform mediump vec3 v;\n\tvarying mediump vec4 v_result;\n\tvoid main() {\n\t\tgl_Position = position;\n\t\tgl_PointSize = 1.0;\n\t\tv_result = vec4(normalize(v) * 0.5 + 0.5, 1);\n\t}\n\t\t`, gl.VERTEX_SHADER, 'mediumpPrecisionVertexTest', DEFAULT_ERROR_CALLBACK);\n\t\tif (!vs) {\n\t\t\tthrow new Error(`Unable to init vertex shader.`);\n\t\t}\n\n\t\tconst fs = compileShader(gl, GLSL1, PRECISION_MEDIUM_P, PRECISION_MEDIUM_P, `\n\tvarying mediump vec4 v_result;\n\tvoid main() {\n\t\tgl_FragColor = v_result;\n\t}\n\t\t`, gl.FRAGMENT_SHADER, 'mediumpPrecisionVertexTest', DEFAULT_ERROR_CALLBACK);\n\t\tif (!fs) {\n\t\t\tthrow new Error(`Unable to init fragment shader.`);\n\t\t}\n\n\t\t// we're going to compute the normalize vector of\n\t\t// (sqrt(2^31-1), sqrt(2^31-1), sqrt(2^31-1))\n\t\t// which should be impossible on mediump\n\t\tconst value = 2 ** 31 - 1;\n\t\tconst input = Math.sqrt(value);\n\t\tconst expected = ((input / Math.sqrt(input * input * 3)) * 0.5 + 0.5) * 255 | 0;\n\n\t\tconst pixel = test1PxCalc(\n\t\t\t'mediumpPrecisionVertexTest',\n\t\t\tgl,\n\t\t\tfs,\n\t\t\tvs,\n\t\t\t(program: WebGLProgram) => {\n\t\t\t\tconst vLocation = gl.getUniformLocation(program, 'v');\n\t\t\t\tgl.uniform3f(vLocation, input, input, input);\n\t\t\t},\n\t\t);\n\n\t\tconst mediumpPrecision = Math.abs(pixel[0] - expected) > 16;\n\t\tresults.mediumpVertexPrecision = mediumpPrecision ? PRECISION_MEDIUM_P : PRECISION_HIGH_P;\n\t}\n\treturn results.mediumpVertexPrecision;\n}\n\n/**\n * Returns the actual precision of mediump inside fragment shader.\n * From https://webglfundamentals.org/webgl/lessons/webgl-precision-issues.html\n * @returns - Fragment shader supported mediump precision.\n */\nexport function getFragmentShaderMediumpPrecision() {\n\tif (results.mediumpFragmentPrecision === undefined) {\n\t\t// This entire program is only needed because of a bug in Safari.\n\t\t// Safari doesn't correctly report precision from getShaderPrecisionFormat\n\t\t// at least as of April 2020\n\t\t// see: https://bugs.webkit.org/show_bug.cgi?id=211013\n\n\t\t// Get A WebGL context\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tconst gl = canvas.getContext(\"webgl\");\n\t\tif (!gl) {\n\t\t\tthrow new Error(`Unable to init webgl context.`);\n\t\t}\n\n\t\tconst vs = compileShader(gl, GLSL1, PRECISION_MEDIUM_P, PRECISION_MEDIUM_P,`\n\tattribute vec4 position;  // needed because of another bug in Safari\n\tvoid main() {\n\t\tgl_Position = position;\n\t\tgl_PointSize = 1.0;\n\t}\n\t\t`, gl.VERTEX_SHADER, 'mediumpPrecisionFragmentTest', DEFAULT_ERROR_CALLBACK);\n\t\tif (!vs) {\n\t\t\tthrow new Error(`Unable to init vertex shader.`);\n\t\t}\n\n\t\tconst fs = compileShader(gl, GLSL1, PRECISION_MEDIUM_P, PRECISION_MEDIUM_P, `\n\tuniform mediump vec3 v;\n\tvoid main() {\n\t\tgl_FragColor = vec4(normalize(v) * 0.5 + 0.5, 1);\n\t}\n\t\t`, gl.FRAGMENT_SHADER, 'mediumpPrecisionFragmentTest', DEFAULT_ERROR_CALLBACK);\n\t\tif (!fs) {\n\t\t\tthrow new Error(`Unable to init fragment shader.`);\n\t\t}\n\n\t\t// we're going to compute the normalize vector of\n\t\t// (sqrt(2^31-1), sqrt(2^31-1), sqrt(2^31-1))\n\t\t// which should be impossible on mediump\n\t\tconst value = 2 ** 31 - 1;\n\t\tconst input = Math.sqrt(value);\n\t\tconst expected = ((input / Math.sqrt(input * input * 3)) * 0.5 + 0.5) * 255 | 0;\n\n\t\tconst pixel = test1PxCalc(\n\t\t\t'mediumpPrecisionFragmentTest',\n\t\t\tgl,\n\t\t\tfs,\n\t\t\tvs,\n\t\t\t(program: WebGLProgram) => {\n\t\t\t\tconst vLocation = gl.getUniformLocation(program, 'v');\n\t\t\t\tgl.uniform3f(vLocation, input, input, input);\n\t\t\t},\n\t\t);\n\n\t\tconst mediumpPrecision = Math.abs(pixel[0] - expected) > 16;\n\t\tresults.mediumpFragmentPrecision =  mediumpPrecision ? PRECISION_MEDIUM_P : PRECISION_HIGH_P;\n\t}\n\treturn results.mediumpFragmentPrecision;\n}\n\n/**\n * Returns whether a number is a power of 2.\n * @private\n */\nexport function isPowerOf2(value: number) {\n\t// Use bitwise operation to evaluate this.\n\treturn value > 0 && (value & (value - 1)) == 0;\n}\n\n/**\n * Returns a Float32 array with sequential values [0, 1, 2, 3...].\n * @private\n */\nexport function initSequentialFloatArray(length: number) {\n\tconst array = new Float32Array(length);\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = i;\n\t}\n\treturn array;\n}\n\n/**\n * Strip out any unnecessary elements in shader source, e.g. #version and precision declarations.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nfunction preprocessShader(shaderSource: string) {\n\t// Strip out any version numbers.\n\tshaderSource = stripVersion(shaderSource);\n\t// Strip out any precision declarations.\n\tshaderSource = stripPrecision(shaderSource);\n\t// Strip out comments.\n\tshaderSource = stripComments(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Common code for converting vertex/fragment shader source to GLSL1.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nfunction convertShaderToGLSL1(shaderSource: string) {\n\t// No isampler2D or usampler2D.\n\tshaderSource = glsl1Sampler2D(shaderSource);\n\t// Unsigned int types are not supported, use int types instead.\n\tshaderSource = glsl1Uint(shaderSource);\n\t// Convert texture to texture2D.\n\tshaderSource = glsl1Texture(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Convert vertex shader source to GLSL1.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nfunction convertVertexShaderToGLSL1(shaderSource: string) {\n\tshaderSource = convertShaderToGLSL1(shaderSource);\n\t// Convert in to attribute.\n\tshaderSource = glsl1VertexIn(shaderSource);\n\t// Convert out to varying.\n\tshaderSource = glsl1VertexOut(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Convert fragment shader source to GLSL1.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nexport function convertFragmentShaderToGLSL1(shaderSource: string, name: string) {\n\tshaderSource = convertShaderToGLSL1(shaderSource);\n\t// Convert in to varying.\n\tshaderSource = glsl1FragmentIn(shaderSource);\n\t// Convert out to gl_FragColor.\n\treturn glsl1FragmentOut(shaderSource, name);\n}\n\n/**\n * Preprocess vertex shader for glslVersion and browser capabilities.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nexport function preprocessVertexShader(shaderSource: string, glslVersion: GLSLVersion) {\n\tshaderSource = preprocessShader(shaderSource);\n\t// Check if highp supported in vertex shaders.\n\tif (!isHighpSupportedInVertexShader()) {\n\t\tconsole.warn('highp not supported in vertex shader in this browser, falling back to mediump.');\n\t\t// Replace all highp with mediump.\n\t\tshaderSource = highpToMediump(shaderSource);\n\t}\n\tif (glslVersion === GLSL3) {\n\t\treturn shaderSource;\n\t}\n\treturn convertVertexShaderToGLSL1(shaderSource);\n}\n\n\n\n/**\n * Preprocess fragment shader for glslVersion and browser capabilities.\n * This is called once on initialization of GPUProgram, so doesn't need to be extremely efficient.\n * @private\n */\nexport function preprocessFragmentShader(shaderSource: string, glslVersion: GLSLVersion, name: string) {\n\tshaderSource = preprocessShader(shaderSource);\n\tcheckFragmentShaderForFragColor(shaderSource, glslVersion, name);\n\t// Check if highp supported in fragment shaders.\n\tif (!isHighpSupportedInFragmentShader()) {\n\t\tconsole.warn('highp not supported in fragment shader in this browser, falling back to mediump.');\n\t\t// Replace all highp with mediump.\n\t\tshaderSource = highpToMediump(shaderSource);\n\t}\n\t// Add function/operator polyfills.\n\tshaderSource = fragmentShaderPolyfills(shaderSource, glslVersion) + shaderSource;\n\t// Add texture() polyfills.\n\tlet samplerUniforms: string[];\n\t({ shaderSource, samplerUniforms } = texturePolyfill(shaderSource));\n\tif (glslVersion !== GLSL3) {\n\t\tconst sources = convertFragmentShaderToGLSL1(shaderSource, name);\n\t\t// If this shader has multiple outputs, it is split into multiple sources.\n\t\tfor (let i = 0, numSources = sources.length; i < numSources; i++) {\n\t\t\t// Add glsl1 specific polyfills.\n\t\t\tsources[i] = GLSL1Polyfills(sources[i]) + sources[i];\n\t\t}\n\t\tshaderSource = sources.shift()!;\n\t\tif (sources.length) {\n\t\t\treturn { shaderSource, samplerUniforms, additionalSources: sources };\n\t\t}\n\t}\n\treturn { shaderSource, samplerUniforms };\n}\n\n/**\n * Check uniforms and return internal WebGL type (e.g. [1234][u]?[if])\n * @private\n */\nexport function uniformInternalTypeForValue(\n\tvalue: UniformValue,\n\ttype: UniformType,\n\tuniformName: string,\n\tprogramName: string,\n) {\n\tif (type === FLOAT) {\n\t\t// Check that we are dealing with a number.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < (value as number[]).length; i++) {\n\t\t\t\tif (!isFiniteNumber((value as number[])[i])) {\n\t\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected float or float[] of length 1-4.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isFiniteNumber(value)) {\n\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected float or float[] of length 1-4.`);\n\t\t\t}\n\t\t}\n\t\tif (!isArray(value) || (value as number[]).length === 1) {\n\t\t\treturn FLOAT_1D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 2) {\n\t\t\treturn FLOAT_2D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 3) {\n\t\t\treturn FLOAT_3D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 4) {\n\t\t\treturn FLOAT_4D_UNIFORM;\n\t\t}\n\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected float or float[] of length 1-4.`);\n\t} else if (type === INT) {\n\t\t// Check that we are dealing with an int.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < (value as number[]).length; i++) {\n\t\t\t\tif (!isInteger((value as number[])[i])) {\n\t\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected int or int[] of length 1-4.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isInteger(value)) {\n\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected int or int[] of length 1-4.`);\n\t\t\t}\n\t\t}\n\t\tif (!isArray(value) || (value as number[]).length === 1) {\n\t\t\treturn INT_1D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 2) {\n\t\t\treturn INT_2D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 3) {\n\t\t\treturn INT_3D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 4) {\n\t\t\treturn INT_4D_UNIFORM;\n\t\t}\n\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected int or int[] of length 1-4.`);\n\t} else if (type === UINT) {\n\t\t// Check that we are dealing with a uint.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < (value as number[]).length; i++) {\n\t\t\t\tif (!isNonNegativeInteger((value as number[])[i])) {\n\t\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected uint or uint[] of length 1-4.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isNonNegativeInteger(value)) {\n\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected uint or uint[] of length 1-4.`);\n\t\t\t}\n\t\t}\n\t\tif (!isArray(value) || (value as number[]).length === 1) {\n\t\t\treturn UINT_1D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 2) {\n\t\t\treturn UINT_2D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 3) {\n\t\t\treturn UINT_3D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 4) {\n\t\t\treturn UINT_4D_UNIFORM;\n\t\t}\n\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected uint or uint[] of length 1-4.`);\n\t} else if (type === BOOL) {\n\t\t// Check that we are dealing with a boolean.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < (value as boolean[]).length; i++) {\n\t\t\t\tif (!isBoolean((value as boolean[])[i])) {\n\t\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected bool or bool[] of length 1-4.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isBoolean(value)) {\n\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected bool or bool[] of length 1-4.`);\n\t\t\t}\n\t\t}\n\t\tif (!isArray(value) || (value as number[]).length === 1) {\n\t\t\treturn BOOL_1D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 2) {\n\t\t\treturn BOOL_2D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 3) {\n\t\t\treturn BOOL_3D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 4) {\n\t\t\treturn BOOL_4D_UNIFORM;\n\t\t}\n\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected boolean.`);\n\t} else {\n\t\tthrow new Error(`Invalid type \"${type}\" for uniform \"${uniformName}\" in program \"${programName}\", expected ${FLOAT} or ${INT} or ${BOOL}.`);\n\t}\n}\n\n/**\n * Get index of GPULayer in array of inputs.\n * Used by GPUComposer.\n * @private\n */\nexport function indexOfLayerInArray(layer: GPULayer, array: (GPULayer | GPULayerState)[]) {\n\treturn array.findIndex(item => item === layer || (item as GPULayerState).layer === layer);\n}\n\nfunction clientWaitAsync(\n\tgl: WebGL2RenderingContext,\n\tsync: WebGLSync,\n\tflags: number,\n\tinterval_ms: number,\n) {\n\treturn new Promise<void>((resolve, reject) => {\n\t  function test() {\n\t\tconst res = gl.clientWaitSync(sync, flags, 0);\n\t\tif (res === gl.WAIT_FAILED) {\n\t\t  reject();\n\t\t  return;\n\t\t}\n\t\tif (res === gl.TIMEOUT_EXPIRED) {\n\t\t  setTimeout(test, interval_ms);\n\t\t  return;\n\t\t}\n\t\tresolve();\n\t  }\n\t  test();\n\t});\n  }\n  \n async function getBufferSubDataAsync(\n\tgl: WebGL2RenderingContext,\n\ttarget: number,\n\tbuffer: WebGLBuffer,\n\tsrcByteOffset: number,\n\tdstBuffer: ArrayBufferView,\n) {\n\tconst sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0)!;\n\tgl.flush();\n  \n\tawait clientWaitAsync(gl, sync, 0, 10);\n\tgl.deleteSync(sync);\n  \n\tgl.bindBuffer(target, buffer);\n\tgl.getBufferSubData(target, srcByteOffset, dstBuffer);\n\tgl.bindBuffer(target, null);\n}\n\n/**\n * Non-blocking version of gl.readPixels for WebGL2 only.\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#use_non-blocking_async_data_readback\n * @param gl - WebGL2 Rendering Context\n * @param x - The first horizontal pixel that is read from the lower left corner of a rectangular block of pixels.\n * @param y - The first vertical pixel that is read from the lower left corner of a rectangular block of pixels.\n * @param w - The width of the rectangle.\n * @param h - The height of the rectangle.\n * @param format - The GLenum format of the pixel data.\n * @param type - The GLenum data type of the pixel data.\n * @param dstBuffer - An object to read data into. The array type must match the type of the type parameter.\n * @returns \n */\nexport async function readPixelsAsync(\n\tgl: WebGL2RenderingContext,\n\tx: number, y: number,\n\tw: number, h: number,\n\tformat: number,\n\ttype: number,\n\tdstBuffer: ArrayBufferView,\n) {\n\tconst buf = gl.createBuffer()!;\n\tgl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n\tgl.bufferData(gl.PIXEL_PACK_BUFFER, dstBuffer.byteLength, gl.STREAM_READ);\n\tgl.readPixels(x, y, w, h, format, type, 0);\n\tgl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n  \n\tawait getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dstBuffer);\n  \n\tgl.deleteBuffer(buf);\n\treturn dstBuffer;\n  }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFloat16 = getFloat16;\nexports.setFloat16 = setFloat16;\n\nvar _arrayIterator = require(\"./_util/arrayIterator.cjs\");\n\nvar _converter = require(\"./_util/converter.cjs\");\n\nvar _primordials = require(\"./_util/primordials.cjs\");\n\nfunction getFloat16(dataView, byteOffset, ...opts) {\n  return (0, _converter.convertToNumber)((0, _primordials.DataViewPrototypeGetUint16)(dataView, byteOffset, ...(0, _arrayIterator.safeIfNeeded)(opts)));\n}\n\nfunction setFloat16(dataView, byteOffset, value, ...opts) {\n  return (0, _primordials.DataViewPrototypeSetUint16)(dataView, byteOffset, (0, _converter.roundToFloat16Bits)(value), ...(0, _arrayIterator.safeIfNeeded)(opts));\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFloat16Array = isFloat16Array;\n\nvar _arrayIterator = require(\"./_util/arrayIterator.cjs\");\n\nvar _brand = require(\"./_util/brand.cjs\");\n\nvar _converter = require(\"./_util/converter.cjs\");\n\nvar _is = require(\"./_util/is.cjs\");\n\nvar _messages = require(\"./_util/messages.cjs\");\n\nvar _primordials = require(\"./_util/primordials.cjs\");\n\nvar _spec = require(\"./_util/spec.cjs\");\n\nconst BYTES_PER_ELEMENT = 2;\nconst float16bitsArrays = new _primordials.NativeWeakMap();\n\nfunction isFloat16Array(target) {\n  return (0, _primordials.WeakMapPrototypeHas)(float16bitsArrays, target) || !(0, _primordials.ArrayBufferIsView)(target) && (0, _brand.hasFloat16ArrayBrand)(target);\n}\n\nfunction assertFloat16Array(target) {\n  if (!isFloat16Array(target)) {\n    throw (0, _primordials.NativeTypeError)(_messages.THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT);\n  }\n}\n\nfunction assertSpeciesTypedArray(target, count) {\n  const isTargetFloat16Array = isFloat16Array(target);\n  const isTargetTypedArray = (0, _is.isNativeTypedArray)(target);\n\n  if (!isTargetFloat16Array && !isTargetTypedArray) {\n    throw (0, _primordials.NativeTypeError)(_messages.SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT);\n  }\n\n  if (typeof count === \"number\") {\n    let length;\n\n    if (isTargetFloat16Array) {\n      const float16bitsArray = getFloat16BitsArray(target);\n      length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    } else {\n      length = (0, _primordials.TypedArrayPrototypeGetLength)(target);\n    }\n\n    if (length < count) {\n      throw (0, _primordials.NativeTypeError)(_messages.DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH);\n    }\n  }\n\n  if ((0, _is.isNativeBigIntTypedArray)(target)) {\n    throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n  }\n}\n\nfunction getFloat16BitsArray(float16) {\n  const float16bitsArray = (0, _primordials.WeakMapPrototypeGet)(float16bitsArrays, float16);\n\n  if (float16bitsArray !== undefined) {\n    const buffer = (0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray);\n\n    if ((0, _spec.IsDetachedBuffer)(buffer)) {\n      throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n    }\n\n    return float16bitsArray;\n  }\n\n  const buffer = float16.buffer;\n\n  if ((0, _spec.IsDetachedBuffer)(buffer)) {\n    throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n  }\n\n  const cloned = (0, _primordials.ReflectConstruct)(Float16Array, [buffer, float16.byteOffset, float16.length], float16.constructor);\n  return (0, _primordials.WeakMapPrototypeGet)(float16bitsArrays, cloned);\n}\n\nfunction copyToArray(float16bitsArray) {\n  const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n  const array = [];\n\n  for (let i = 0; i < length; ++i) {\n    array[i] = (0, _converter.convertToNumber)(float16bitsArray[i]);\n  }\n\n  return array;\n}\n\nconst TypedArrayPrototypeGetters = new _primordials.NativeWeakSet();\n\nfor (const key of (0, _primordials.ReflectOwnKeys)(_primordials.TypedArrayPrototype)) {\n  if (key === _primordials.SymbolToStringTag) {\n    continue;\n  }\n\n  const descriptor = (0, _primordials.ReflectGetOwnPropertyDescriptor)(_primordials.TypedArrayPrototype, key);\n\n  if ((0, _primordials.ObjectHasOwn)(descriptor, \"get\") && typeof descriptor.get === \"function\") {\n    (0, _primordials.WeakSetPrototypeAdd)(TypedArrayPrototypeGetters, descriptor.get);\n  }\n}\n\nconst handler = (0, _primordials.ObjectFreeze)({\n  get(target, key, receiver) {\n    if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {\n      return (0, _converter.convertToNumber)((0, _primordials.ReflectGet)(target, key));\n    }\n\n    if ((0, _primordials.WeakSetPrototypeHas)(TypedArrayPrototypeGetters, (0, _primordials.ObjectPrototype__lookupGetter__)(target, key))) {\n      return (0, _primordials.ReflectGet)(target, key);\n    }\n\n    return (0, _primordials.ReflectGet)(target, key, receiver);\n  },\n\n  set(target, key, value, receiver) {\n    if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {\n      return (0, _primordials.ReflectSet)(target, key, (0, _converter.roundToFloat16Bits)(value));\n    }\n\n    return (0, _primordials.ReflectSet)(target, key, value, receiver);\n  },\n\n  getOwnPropertyDescriptor(target, key) {\n    if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key)) {\n      const descriptor = (0, _primordials.ReflectGetOwnPropertyDescriptor)(target, key);\n      descriptor.value = (0, _converter.convertToNumber)(descriptor.value);\n      return descriptor;\n    }\n\n    return (0, _primordials.ReflectGetOwnPropertyDescriptor)(target, key);\n  },\n\n  defineProperty(target, key, descriptor) {\n    if ((0, _is.isCanonicalIntegerIndexString)(key) && (0, _primordials.ObjectHasOwn)(target, key) && (0, _primordials.ObjectHasOwn)(descriptor, \"value\")) {\n      descriptor.value = (0, _converter.roundToFloat16Bits)(descriptor.value);\n      return (0, _primordials.ReflectDefineProperty)(target, key, descriptor);\n    }\n\n    return (0, _primordials.ReflectDefineProperty)(target, key, descriptor);\n  }\n\n});\n\nclass Float16Array {\n  constructor(input, _byteOffset, _length) {\n    let float16bitsArray;\n\n    if (isFloat16Array(input)) {\n      float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [getFloat16BitsArray(input)], new.target);\n    } else if ((0, _is.isObject)(input) && !(0, _is.isArrayBuffer)(input)) {\n      let list;\n      let length;\n\n      if ((0, _is.isNativeTypedArray)(input)) {\n        list = input;\n        length = (0, _primordials.TypedArrayPrototypeGetLength)(input);\n        const buffer = (0, _primordials.TypedArrayPrototypeGetBuffer)(input);\n        const BufferConstructor = !(0, _is.isSharedArrayBuffer)(buffer) ? (0, _spec.SpeciesConstructor)(buffer, _primordials.NativeArrayBuffer) : _primordials.NativeArrayBuffer;\n\n        if ((0, _spec.IsDetachedBuffer)(buffer)) {\n          throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n        }\n\n        if ((0, _is.isNativeBigIntTypedArray)(input)) {\n          throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n        }\n\n        const data = new BufferConstructor(length * BYTES_PER_ELEMENT);\n        float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [data], new.target);\n      } else {\n        const iterator = input[_primordials.SymbolIterator];\n\n        if (iterator != null && typeof iterator !== \"function\") {\n          throw (0, _primordials.NativeTypeError)(_messages.ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n        }\n\n        if (iterator != null) {\n          if ((0, _is.isOrdinaryArray)(input)) {\n            list = input;\n            length = input.length;\n          } else {\n            list = [...input];\n            length = list.length;\n          }\n        } else {\n          list = input;\n          length = (0, _spec.ToLength)(list.length);\n        }\n\n        float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, [length], new.target);\n      }\n\n      for (let i = 0; i < length; ++i) {\n        float16bitsArray[i] = (0, _converter.roundToFloat16Bits)(list[i]);\n      }\n    } else {\n      float16bitsArray = (0, _primordials.ReflectConstruct)(_primordials.NativeUint16Array, arguments, new.target);\n    }\n\n    const proxy = new _primordials.NativeProxy(float16bitsArray, handler);\n    (0, _primordials.WeakMapPrototypeSet)(float16bitsArrays, proxy, float16bitsArray);\n    return proxy;\n  }\n\n  static from(src, ...opts) {\n    const Constructor = this;\n\n    if (!(0, _primordials.ReflectHas)(Constructor, _brand.brand)) {\n      throw (0, _primordials.NativeTypeError)(_messages.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY);\n    }\n\n    if (Constructor === Float16Array) {\n      if (isFloat16Array(src) && opts.length === 0) {\n        const float16bitsArray = getFloat16BitsArray(src);\n        const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));\n        return new Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16)));\n      }\n\n      if (opts.length === 0) {\n        return new Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.Uint16ArrayFrom)(src, _converter.roundToFloat16Bits)));\n      }\n\n      const mapFunc = opts[0];\n      const thisArg = opts[1];\n      return new Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.Uint16ArrayFrom)(src, function (val, ...args) {\n        return (0, _converter.roundToFloat16Bits)((0, _primordials.ReflectApply)(mapFunc, this, [val, ...(0, _arrayIterator.safeIfNeeded)(args)]));\n      }, thisArg)));\n    }\n\n    let list;\n    let length;\n    const iterator = src[_primordials.SymbolIterator];\n\n    if (iterator != null && typeof iterator !== \"function\") {\n      throw (0, _primordials.NativeTypeError)(_messages.ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n    }\n\n    if (iterator != null) {\n      if ((0, _is.isOrdinaryArray)(src)) {\n        list = src;\n        length = src.length;\n      } else if ((0, _is.isOrdinaryNativeTypedArray)(src)) {\n        list = src;\n        length = (0, _primordials.TypedArrayPrototypeGetLength)(src);\n      } else {\n        list = [...src];\n        length = list.length;\n      }\n    } else {\n      if (src == null) {\n        throw (0, _primordials.NativeTypeError)(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);\n      }\n\n      list = (0, _primordials.NativeObject)(src);\n      length = (0, _spec.ToLength)(list.length);\n    }\n\n    const array = new Constructor(length);\n\n    if (opts.length === 0) {\n      for (let i = 0; i < length; ++i) {\n        array[i] = list[i];\n      }\n    } else {\n      const mapFunc = opts[0];\n      const thisArg = opts[1];\n\n      for (let i = 0; i < length; ++i) {\n        array[i] = (0, _primordials.ReflectApply)(mapFunc, thisArg, [list[i], i]);\n      }\n    }\n\n    return array;\n  }\n\n  static of(...items) {\n    const Constructor = this;\n\n    if (!(0, _primordials.ReflectHas)(Constructor, _brand.brand)) {\n      throw (0, _primordials.NativeTypeError)(_messages.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY);\n    }\n\n    const length = items.length;\n\n    if (Constructor === Float16Array) {\n      const proxy = new Float16Array(length);\n      const float16bitsArray = getFloat16BitsArray(proxy);\n\n      for (let i = 0; i < length; ++i) {\n        float16bitsArray[i] = (0, _converter.roundToFloat16Bits)(items[i]);\n      }\n\n      return proxy;\n    }\n\n    const array = new Constructor(length);\n\n    for (let i = 0; i < length; ++i) {\n      array[i] = items[i];\n    }\n\n    return array;\n  }\n\n  keys() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    return (0, _primordials.TypedArrayPrototypeKeys)(float16bitsArray);\n  }\n\n  values() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    return (0, _arrayIterator.wrap)(function* () {\n      for (const val of (0, _primordials.TypedArrayPrototypeValues)(float16bitsArray)) {\n        yield (0, _converter.convertToNumber)(val);\n      }\n    }());\n  }\n\n  entries() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    return (0, _arrayIterator.wrap)(function* () {\n      for (const [i, val] of (0, _primordials.TypedArrayPrototypeEntries)(float16bitsArray)) {\n        yield [i, (0, _converter.convertToNumber)(val)];\n      }\n    }());\n  }\n\n  at(index) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const relativeIndex = (0, _spec.ToIntegerOrInfinity)(index);\n    const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n\n    if (k < 0 || k >= length) {\n      return;\n    }\n\n    return (0, _converter.convertToNumber)(float16bitsArray[k]);\n  }\n\n  map(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n    const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, Float16Array);\n\n    if (Constructor === Float16Array) {\n      const proxy = new Float16Array(length);\n      const array = getFloat16BitsArray(proxy);\n\n      for (let i = 0; i < length; ++i) {\n        const val = (0, _converter.convertToNumber)(float16bitsArray[i]);\n        array[i] = (0, _converter.roundToFloat16Bits)((0, _primordials.ReflectApply)(callback, thisArg, [val, i, this]));\n      }\n\n      return proxy;\n    }\n\n    const array = new Constructor(length);\n    assertSpeciesTypedArray(array, length);\n\n    for (let i = 0; i < length; ++i) {\n      const val = (0, _converter.convertToNumber)(float16bitsArray[i]);\n      array[i] = (0, _primordials.ReflectApply)(callback, thisArg, [val, i, this]);\n    }\n\n    return array;\n  }\n\n  filter(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n    const kept = [];\n\n    for (let i = 0; i < length; ++i) {\n      const val = (0, _converter.convertToNumber)(float16bitsArray[i]);\n\n      if ((0, _primordials.ReflectApply)(callback, thisArg, [val, i, this])) {\n        (0, _primordials.ArrayPrototypePush)(kept, val);\n      }\n    }\n\n    const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, Float16Array);\n    const array = new Constructor(kept);\n    assertSpeciesTypedArray(array);\n    return array;\n  }\n\n  reduce(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n\n    if (length === 0 && opts.length === 0) {\n      throw (0, _primordials.NativeTypeError)(_messages.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n    }\n\n    let accumulator, start;\n\n    if (opts.length === 0) {\n      accumulator = (0, _converter.convertToNumber)(float16bitsArray[0]);\n      start = 1;\n    } else {\n      accumulator = opts[0];\n      start = 0;\n    }\n\n    for (let i = start; i < length; ++i) {\n      accumulator = callback(accumulator, (0, _converter.convertToNumber)(float16bitsArray[i]), i, this);\n    }\n\n    return accumulator;\n  }\n\n  reduceRight(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n\n    if (length === 0 && opts.length === 0) {\n      throw (0, _primordials.NativeTypeError)(_messages.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n    }\n\n    let accumulator, start;\n\n    if (opts.length === 0) {\n      accumulator = (0, _converter.convertToNumber)(float16bitsArray[length - 1]);\n      start = length - 2;\n    } else {\n      accumulator = opts[0];\n      start = length - 1;\n    }\n\n    for (let i = start; i >= 0; --i) {\n      accumulator = callback(accumulator, (0, _converter.convertToNumber)(float16bitsArray[i]), i, this);\n    }\n\n    return accumulator;\n  }\n\n  forEach(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      (0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i]), i, this]);\n    }\n  }\n\n  find(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      const value = (0, _converter.convertToNumber)(float16bitsArray[i]);\n\n      if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i, this])) {\n        return value;\n      }\n    }\n  }\n\n  findIndex(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      const value = (0, _converter.convertToNumber)(float16bitsArray[i]);\n\n      if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i, this])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  findLast(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = length - 1; i >= 0; --i) {\n      const value = (0, _converter.convertToNumber)(float16bitsArray[i]);\n\n      if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i, this])) {\n        return value;\n      }\n    }\n  }\n\n  findLastIndex(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = length - 1; i >= 0; --i) {\n      const value = (0, _converter.convertToNumber)(float16bitsArray[i]);\n\n      if ((0, _primordials.ReflectApply)(callback, thisArg, [value, i, this])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  every(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      if (!(0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i]), i, this])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  some(callback, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const thisArg = opts[0];\n\n    for (let i = 0; i < length; ++i) {\n      if ((0, _primordials.ReflectApply)(callback, thisArg, [(0, _converter.convertToNumber)(float16bitsArray[i]), i, this])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  set(input, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const targetOffset = (0, _spec.ToIntegerOrInfinity)(opts[0]);\n\n    if (targetOffset < 0) {\n      throw (0, _primordials.NativeRangeError)(_messages.OFFSET_IS_OUT_OF_BOUNDS);\n    }\n\n    if (input == null) {\n      throw (0, _primordials.NativeTypeError)(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);\n    }\n\n    if ((0, _is.isNativeBigIntTypedArray)(input)) {\n      throw (0, _primordials.NativeTypeError)(_messages.CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n    }\n\n    if (isFloat16Array(input)) {\n      return (0, _primordials.TypedArrayPrototypeSet)(getFloat16BitsArray(this), getFloat16BitsArray(input), targetOffset);\n    }\n\n    if ((0, _is.isNativeTypedArray)(input)) {\n      const buffer = (0, _primordials.TypedArrayPrototypeGetBuffer)(input);\n\n      if ((0, _spec.IsDetachedBuffer)(buffer)) {\n        throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n      }\n    }\n\n    const targetLength = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const src = (0, _primordials.NativeObject)(input);\n    const srcLength = (0, _spec.ToLength)(src.length);\n\n    if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {\n      throw (0, _primordials.NativeRangeError)(_messages.OFFSET_IS_OUT_OF_BOUNDS);\n    }\n\n    for (let i = 0; i < srcLength; ++i) {\n      float16bitsArray[i + targetOffset] = (0, _converter.roundToFloat16Bits)(src[i]);\n    }\n  }\n\n  reverse() {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    (0, _primordials.TypedArrayPrototypeReverse)(float16bitsArray);\n    return this;\n  }\n\n  fill(value, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    (0, _primordials.TypedArrayPrototypeFill)(float16bitsArray, (0, _converter.roundToFloat16Bits)(value), ...(0, _arrayIterator.safeIfNeeded)(opts));\n    return this;\n  }\n\n  copyWithin(target, start, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    (0, _primordials.TypedArrayPrototypeCopyWithin)(float16bitsArray, target, start, ...(0, _arrayIterator.safeIfNeeded)(opts));\n    return this;\n  }\n\n  sort(compareFn) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const sortCompare = compareFn !== undefined ? compareFn : _spec.defaultCompare;\n    (0, _primordials.TypedArrayPrototypeSort)(float16bitsArray, (x, y) => {\n      return sortCompare((0, _converter.convertToNumber)(x), (0, _converter.convertToNumber)(y));\n    });\n    return this;\n  }\n\n  slice(start, end) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, Float16Array);\n\n    if (Constructor === Float16Array) {\n      const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));\n      return new Float16Array((0, _primordials.TypedArrayPrototypeGetBuffer)((0, _primordials.TypedArrayPrototypeSlice)(uint16, start, end)));\n    }\n\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    const relativeStart = (0, _spec.ToIntegerOrInfinity)(start);\n    const relativeEnd = end === undefined ? length : (0, _spec.ToIntegerOrInfinity)(end);\n    let k;\n\n    if (relativeStart === -Infinity) {\n      k = 0;\n    } else if (relativeStart < 0) {\n      k = length + relativeStart > 0 ? length + relativeStart : 0;\n    } else {\n      k = length < relativeStart ? length : relativeStart;\n    }\n\n    let final;\n\n    if (relativeEnd === -Infinity) {\n      final = 0;\n    } else if (relativeEnd < 0) {\n      final = length + relativeEnd > 0 ? length + relativeEnd : 0;\n    } else {\n      final = length < relativeEnd ? length : relativeEnd;\n    }\n\n    const count = final - k > 0 ? final - k : 0;\n    const array = new Constructor(count);\n    assertSpeciesTypedArray(array, count);\n\n    if (count === 0) {\n      return array;\n    }\n\n    const buffer = (0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray);\n\n    if ((0, _spec.IsDetachedBuffer)(buffer)) {\n      throw (0, _primordials.NativeTypeError)(_messages.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n    }\n\n    let n = 0;\n\n    while (k < final) {\n      array[n] = (0, _converter.convertToNumber)(float16bitsArray[k]);\n      ++k;\n      ++n;\n    }\n\n    return array;\n  }\n\n  subarray(begin, end) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const Constructor = (0, _spec.SpeciesConstructor)(float16bitsArray, Float16Array);\n    const uint16 = new _primordials.NativeUint16Array((0, _primordials.TypedArrayPrototypeGetBuffer)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(float16bitsArray), (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray));\n    const uint16Subarray = (0, _primordials.TypedArrayPrototypeSubarray)(uint16, begin, end);\n    const array = new Constructor((0, _primordials.TypedArrayPrototypeGetBuffer)(uint16Subarray), (0, _primordials.TypedArrayPrototypeGetByteOffset)(uint16Subarray), (0, _primordials.TypedArrayPrototypeGetLength)(uint16Subarray));\n    assertSpeciesTypedArray(array);\n    return array;\n  }\n\n  indexOf(element, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    let from = (0, _spec.ToIntegerOrInfinity)(opts[0]);\n\n    if (from === Infinity) {\n      return -1;\n    }\n\n    if (from < 0) {\n      from += length;\n\n      if (from < 0) {\n        from = 0;\n      }\n    }\n\n    for (let i = from; i < length; ++i) {\n      if ((0, _primordials.ObjectHasOwn)(float16bitsArray, i) && (0, _converter.convertToNumber)(float16bitsArray[i]) === element) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  lastIndexOf(element, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    let from = opts.length >= 1 ? (0, _spec.ToIntegerOrInfinity)(opts[0]) : length - 1;\n\n    if (from === -Infinity) {\n      return -1;\n    }\n\n    if (from >= 0) {\n      from = from < length - 1 ? from : length - 1;\n    } else {\n      from += length;\n    }\n\n    for (let i = from; i >= 0; --i) {\n      if ((0, _primordials.ObjectHasOwn)(float16bitsArray, i) && (0, _converter.convertToNumber)(float16bitsArray[i]) === element) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  includes(element, ...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const length = (0, _primordials.TypedArrayPrototypeGetLength)(float16bitsArray);\n    let from = (0, _spec.ToIntegerOrInfinity)(opts[0]);\n\n    if (from === Infinity) {\n      return false;\n    }\n\n    if (from < 0) {\n      from += length;\n\n      if (from < 0) {\n        from = 0;\n      }\n    }\n\n    const isNaN = (0, _primordials.NumberIsNaN)(element);\n\n    for (let i = from; i < length; ++i) {\n      const value = (0, _converter.convertToNumber)(float16bitsArray[i]);\n\n      if (isNaN && (0, _primordials.NumberIsNaN)(value)) {\n        return true;\n      }\n\n      if (value === element) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  join(separator) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const array = copyToArray(float16bitsArray);\n    return (0, _primordials.ArrayPrototypeJoin)(array, separator);\n  }\n\n  toLocaleString(...opts) {\n    assertFloat16Array(this);\n    const float16bitsArray = getFloat16BitsArray(this);\n    const array = copyToArray(float16bitsArray);\n    return (0, _primordials.ArrayPrototypeToLocaleString)(array, ...(0, _arrayIterator.safeIfNeeded)(opts));\n  }\n\n  get [_primordials.SymbolToStringTag]() {\n    if (isFloat16Array(this)) {\n      return \"Float16Array\";\n    }\n  }\n\n}\n\nexports.Float16Array = Float16Array;\n(0, _primordials.ObjectDefineProperty)(Float16Array, \"BYTES_PER_ELEMENT\", {\n  value: BYTES_PER_ELEMENT\n});\n(0, _primordials.ObjectDefineProperty)(Float16Array, _brand.brand, {});\n(0, _primordials.ReflectSetPrototypeOf)(Float16Array, _primordials.TypedArray);\nconst Float16ArrayPrototype = Float16Array.prototype;\n(0, _primordials.ObjectDefineProperty)(Float16ArrayPrototype, \"BYTES_PER_ELEMENT\", {\n  value: BYTES_PER_ELEMENT\n});\n(0, _primordials.ObjectDefineProperty)(Float16ArrayPrototype, _primordials.SymbolIterator, {\n  value: Float16ArrayPrototype.values,\n  writable: true,\n  configurable: true\n});\n(0, _primordials.ReflectSetPrototypeOf)(Float16ArrayPrototype, _primordials.TypedArrayPrototype);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.safeIfNeeded = safeIfNeeded;\nexports.wrap = wrap;\n\nvar _primordials = require(\"./primordials.cjs\");\n\nconst arrayIterators = new _primordials.NativeWeakMap();\nconst SafeIteratorPrototype = (0, _primordials.ObjectCreate)(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = (0, _primordials.WeakMapPrototypeGet)(arrayIterators, this);\n      return (0, _primordials.ArrayIteratorPrototypeNext)(arrayIterator);\n    }\n  },\n  [_primordials.SymbolIterator]: {\n    value: function values() {\n      return this;\n    }\n  }\n});\n\nfunction safeIfNeeded(array) {\n  if (array[_primordials.SymbolIterator] === _primordials.NativeArrayPrototypeSymbolIterator) {\n    return array;\n  }\n\n  const safe = (0, _primordials.ObjectCreate)(SafeIteratorPrototype);\n  (0, _primordials.WeakMapPrototypeSet)(arrayIterators, safe, (0, _primordials.ArrayPrototypeSymbolIterator)(array));\n  return safe;\n}\n\nconst generators = new _primordials.NativeWeakMap();\nconst DummyArrayIteratorPrototype = (0, _primordials.ObjectCreate)(_primordials.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = (0, _primordials.WeakMapPrototypeGet)(generators, this);\n      return (0, _primordials.GeneratorPrototypeNext)(generator);\n    },\n    writable: true,\n    configurable: true\n  }\n});\n\nfor (const key of (0, _primordials.ReflectOwnKeys)(_primordials.ArrayIteratorPrototype)) {\n  if (key === \"next\") {\n    continue;\n  }\n\n  (0, _primordials.ObjectDefineProperty)(DummyArrayIteratorPrototype, key, (0, _primordials.ReflectGetOwnPropertyDescriptor)(_primordials.ArrayIteratorPrototype, key));\n}\n\nfunction wrap(generator) {\n  const dummy = (0, _primordials.ObjectCreate)(DummyArrayIteratorPrototype);\n  (0, _primordials.WeakMapPrototypeSet)(generators, dummy, generator);\n  return dummy;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasFloat16ArrayBrand = hasFloat16ArrayBrand;\n\nvar _is = require(\"./is.cjs\");\n\nvar _messages = require(\"./messages.cjs\");\n\nvar _primordials = require(\"./primordials.cjs\");\n\nconst brand = (0, _primordials.SymbolFor)(\"__Float16Array__\");\nexports.brand = brand;\n\nfunction hasFloat16ArrayBrand(target) {\n  if (!(0, _is.isObjectLike)(target)) {\n    return false;\n  }\n\n  const prototype = (0, _primordials.ReflectGetPrototypeOf)(target);\n\n  if (!(0, _is.isObjectLike)(prototype)) {\n    return false;\n  }\n\n  const constructor = prototype.constructor;\n\n  if (constructor === undefined) {\n    return false;\n  }\n\n  if (!(0, _is.isObject)(constructor)) {\n    throw (0, _primordials.NativeTypeError)(_messages.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n  }\n\n  return (0, _primordials.ReflectHas)(constructor, brand);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convertToNumber = convertToNumber;\nexports.roundToFloat16Bits = roundToFloat16Bits;\n\nvar _primordials = require(\"./primordials.cjs\");\n\nconst buffer = new _primordials.NativeArrayBuffer(4);\nconst floatView = new _primordials.NativeFloat32Array(buffer);\nconst uint32View = new _primordials.NativeUint32Array(buffer);\nconst baseTable = new _primordials.NativeUint32Array(512);\nconst shiftTable = new _primordials.NativeUint32Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  if (e < -27) {\n    baseTable[i] = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i] = 24;\n    shiftTable[i | 0x100] = 24;\n  } else if (e < -14) {\n    baseTable[i] = 0x0400 >> -e - 14;\n    baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;\n    shiftTable[i] = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n  } else if (e <= 15) {\n    baseTable[i] = e + 15 << 10;\n    baseTable[i | 0x100] = e + 15 << 10 | 0x8000;\n    shiftTable[i] = 13;\n    shiftTable[i | 0x100] = 13;\n  } else if (e < 128) {\n    baseTable[i] = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i] = 24;\n    shiftTable[i | 0x100] = 24;\n  } else {\n    baseTable[i] = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i] = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\nfunction roundToFloat16Bits(num) {\n  floatView[0] = num;\n  const f = uint32View[0];\n  const e = f >> 23 & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new _primordials.NativeUint32Array(2048);\nconst exponentTable = new _primordials.NativeUint32Array(64);\nconst offsetTable = new _primordials.NativeUint32Array(64);\n\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13;\n  let e = 0;\n\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000;\n  }\n\n  m &= ~0x00800000;\n  e += 0x38800000;\n  mantissaTable[i] = m | e;\n}\n\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + (i - 1024 << 13);\n}\n\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\n\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\n\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + (i - 32 << 23);\n}\n\nexponentTable[63] = 0xc7800000;\n\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\nfunction convertToNumber(float16bits) {\n  const m = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];\n  return floatView[0];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isArrayBuffer = isArrayBuffer;\nexports.isCanonicalIntegerIndexString = isCanonicalIntegerIndexString;\nexports.isNativeBigIntTypedArray = isNativeBigIntTypedArray;\nexports.isNativeTypedArray = isNativeTypedArray;\nexports.isObject = isObject;\nexports.isObjectLike = isObjectLike;\nexports.isOrdinaryArray = isOrdinaryArray;\nexports.isOrdinaryNativeTypedArray = isOrdinaryNativeTypedArray;\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nvar _primordials = require(\"./primordials.cjs\");\n\nfunction isObject(value) {\n  return value !== null && typeof value === \"object\" || typeof value === \"function\";\n}\n\nfunction isObjectLike(value) {\n  return value !== null && typeof value === \"object\";\n}\n\nfunction isNativeTypedArray(value) {\n  return (0, _primordials.TypedArrayPrototypeGetSymbolToStringTag)(value) !== undefined;\n}\n\nfunction isNativeBigIntTypedArray(value) {\n  const typedArrayName = (0, _primordials.TypedArrayPrototypeGetSymbolToStringTag)(value);\n  return typedArrayName === \"BigInt64Array\" || typedArrayName === \"BigUint64Array\";\n}\n\nfunction isArrayBuffer(value) {\n  try {\n    (0, _primordials.ArrayBufferPrototypeGetByteLength)(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isSharedArrayBuffer(value) {\n  if (_primordials.NativeSharedArrayBuffer === null) {\n    return false;\n  }\n\n  try {\n    (0, _primordials.SharedArrayBufferPrototypeGetByteLength)(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isOrdinaryArray(value) {\n  if (!(0, _primordials.ArrayIsArray)(value)) {\n    return false;\n  }\n\n  if (value[_primordials.SymbolIterator] === _primordials.NativeArrayPrototypeSymbolIterator) {\n    return true;\n  }\n\n  const iterator = value[_primordials.SymbolIterator]();\n\n  return iterator[_primordials.SymbolToStringTag] === \"Array Iterator\";\n}\n\nfunction isOrdinaryNativeTypedArray(value) {\n  if (!isNativeTypedArray(value)) {\n    return false;\n  }\n\n  if (value[_primordials.SymbolIterator] === _primordials.NativeTypedArrayPrototypeSymbolIterator) {\n    return true;\n  }\n\n  const iterator = value[_primordials.SymbolIterator]();\n\n  return iterator[_primordials.SymbolToStringTag] === \"Array Iterator\";\n}\n\nfunction isCanonicalIntegerIndexString(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n\n  const number = +value;\n\n  if (value !== number + \"\") {\n    return false;\n  }\n\n  if (!(0, _primordials.NumberIsFinite)(number)) {\n    return false;\n  }\n\n  return number === (0, _primordials.MathTrunc)(number);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\nexports.THIS_IS_NOT_AN_OBJECT = THIS_IS_NOT_AN_OBJECT;\nconst THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\nexports.THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT;\nconst THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY = \"This constructor is not a subclass of Float16Array\";\nexports.THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY = THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY;\nconst THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT = \"The constructor property value is not an object\";\nexports.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT = THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT;\nconst SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT = \"Species constructor didn't return TypedArray object\";\nexports.SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT = SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT;\nconst DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH = \"Derived constructor created TypedArray object which was too small length\";\nexports.DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH = DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH;\nconst ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER = \"Attempting to access detached ArrayBuffer\";\nexports.ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER = ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER;\nconst CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT = \"Cannot convert undefined or null to object\";\nexports.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT = CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT;\nconst CANNOT_MIX_BIGINT_AND_OTHER_TYPES = \"Cannot mix BigInt and other types, use explicit conversions\";\nexports.CANNOT_MIX_BIGINT_AND_OTHER_TYPES = CANNOT_MIX_BIGINT_AND_OTHER_TYPES;\nconst ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\nexports.ITERATOR_PROPERTY_IS_NOT_CALLABLE = ITERATOR_PROPERTY_IS_NOT_CALLABLE;\nconst REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE = \"Reduce of empty array with no initial value\";\nexports.REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE = REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE;\nconst OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\nexports.OFFSET_IS_OUT_OF_BOUNDS = OFFSET_IS_OUT_OF_BOUNDS;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _messages = require(\"./messages.cjs\");\n\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(ReflectGetOwnPropertyDescriptor(target, key).get);\n}\n\nconst {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf\n} = Reflect;\nexports.ReflectSetPrototypeOf = ReflectSetPrototypeOf;\nexports.ReflectSet = ReflectSet;\nexports.ReflectOwnKeys = ReflectOwnKeys;\nexports.ReflectHas = ReflectHas;\nexports.ReflectGetPrototypeOf = ReflectGetPrototypeOf;\nexports.ReflectGetOwnPropertyDescriptor = ReflectGetOwnPropertyDescriptor;\nexports.ReflectGet = ReflectGet;\nexports.ReflectDefineProperty = ReflectDefineProperty;\nexports.ReflectConstruct = ReflectConstruct;\nexports.ReflectApply = ReflectApply;\nconst NativeProxy = Proxy;\nexports.NativeProxy = NativeProxy;\nconst {\n  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN\n} = Number;\nexports.NumberIsNaN = NumberIsNaN;\nexports.NumberIsFinite = NumberIsFinite;\nexports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nconst {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor\n} = Symbol;\nexports.SymbolFor = SymbolFor;\nexports.SymbolToStringTag = SymbolToStringTag;\nexports.SymbolSpecies = SymbolSpecies;\nexports.SymbolIterator = SymbolIterator;\nconst NativeObject = Object;\nexports.NativeObject = NativeObject;\nconst {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs\n} = NativeObject;\nexports.ObjectIs = ObjectIs;\nexports.ObjectFreeze = ObjectFreeze;\nexports.ObjectDefineProperty = ObjectDefineProperty;\nexports.ObjectCreate = ObjectCreate;\nconst ObjectPrototype = NativeObject.prototype;\nconst ObjectPrototype__lookupGetter__ = ObjectPrototype.__lookupGetter__ ? uncurryThis(ObjectPrototype.__lookupGetter__) : (object, key) => {\n  if (object == null) {\n    throw NativeTypeError(_messages.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT);\n  }\n\n  let target = NativeObject(object);\n\n  do {\n    const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n\n    if (descriptor !== undefined) {\n      if (ObjectHasOwn(descriptor, \"get\")) {\n        return descriptor.get;\n      }\n\n      return;\n    }\n  } while ((target = ReflectGetPrototypeOf(target)) !== null);\n};\nexports.ObjectPrototype__lookupGetter__ = ObjectPrototype__lookupGetter__;\nconst ObjectHasOwn = NativeObject.hasOwn || uncurryThis(ObjectPrototype.hasOwnProperty);\nexports.ObjectHasOwn = ObjectHasOwn;\nconst NativeArray = Array;\nconst ArrayIsArray = NativeArray.isArray;\nexports.ArrayIsArray = ArrayIsArray;\nconst ArrayPrototype = NativeArray.prototype;\nconst ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\nexports.ArrayPrototypeJoin = ArrayPrototypeJoin;\nconst ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\nexports.ArrayPrototypePush = ArrayPrototypePush;\nconst ArrayPrototypeToLocaleString = uncurryThis(ArrayPrototype.toLocaleString);\nexports.ArrayPrototypeToLocaleString = ArrayPrototypeToLocaleString;\nconst NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\nexports.NativeArrayPrototypeSymbolIterator = NativeArrayPrototypeSymbolIterator;\nconst ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\nexports.ArrayPrototypeSymbolIterator = ArrayPrototypeSymbolIterator;\nconst MathTrunc = Math.trunc;\nexports.MathTrunc = MathTrunc;\nconst NativeArrayBuffer = ArrayBuffer;\nexports.NativeArrayBuffer = NativeArrayBuffer;\nconst ArrayBufferIsView = NativeArrayBuffer.isView;\nexports.ArrayBufferIsView = ArrayBufferIsView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\nconst ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\nexports.ArrayBufferPrototypeSlice = ArrayBufferPrototypeSlice;\nconst ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\nexports.ArrayBufferPrototypeGetByteLength = ArrayBufferPrototypeGetByteLength;\nconst NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\nexports.NativeSharedArrayBuffer = NativeSharedArrayBuffer;\nconst SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\nexports.SharedArrayBufferPrototypeGetByteLength = SharedArrayBufferPrototypeGetByteLength;\nconst TypedArray = ReflectGetPrototypeOf(Uint8Array);\nexports.TypedArray = TypedArray;\nconst TypedArrayFrom = TypedArray.from;\nconst TypedArrayPrototype = TypedArray.prototype;\nexports.TypedArrayPrototype = TypedArrayPrototype;\nconst NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\nexports.NativeTypedArrayPrototypeSymbolIterator = NativeTypedArrayPrototypeSymbolIterator;\nconst TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\nexports.TypedArrayPrototypeKeys = TypedArrayPrototypeKeys;\nconst TypedArrayPrototypeValues = uncurryThis(TypedArrayPrototype.values);\nexports.TypedArrayPrototypeValues = TypedArrayPrototypeValues;\nconst TypedArrayPrototypeEntries = uncurryThis(TypedArrayPrototype.entries);\nexports.TypedArrayPrototypeEntries = TypedArrayPrototypeEntries;\nconst TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\nexports.TypedArrayPrototypeSet = TypedArrayPrototypeSet;\nconst TypedArrayPrototypeReverse = uncurryThis(TypedArrayPrototype.reverse);\nexports.TypedArrayPrototypeReverse = TypedArrayPrototypeReverse;\nconst TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\nexports.TypedArrayPrototypeFill = TypedArrayPrototypeFill;\nconst TypedArrayPrototypeCopyWithin = uncurryThis(TypedArrayPrototype.copyWithin);\nexports.TypedArrayPrototypeCopyWithin = TypedArrayPrototypeCopyWithin;\nconst TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\nexports.TypedArrayPrototypeSort = TypedArrayPrototypeSort;\nconst TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\nexports.TypedArrayPrototypeSlice = TypedArrayPrototypeSlice;\nconst TypedArrayPrototypeSubarray = uncurryThis(TypedArrayPrototype.subarray);\nexports.TypedArrayPrototypeSubarray = TypedArrayPrototypeSubarray;\nconst TypedArrayPrototypeGetBuffer = uncurryThisGetter(TypedArrayPrototype, \"buffer\");\nexports.TypedArrayPrototypeGetBuffer = TypedArrayPrototypeGetBuffer;\nconst TypedArrayPrototypeGetByteOffset = uncurryThisGetter(TypedArrayPrototype, \"byteOffset\");\nexports.TypedArrayPrototypeGetByteOffset = TypedArrayPrototypeGetByteOffset;\nconst TypedArrayPrototypeGetLength = uncurryThisGetter(TypedArrayPrototype, \"length\");\nexports.TypedArrayPrototypeGetLength = TypedArrayPrototypeGetLength;\nconst TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(TypedArrayPrototype, SymbolToStringTag);\nexports.TypedArrayPrototypeGetSymbolToStringTag = TypedArrayPrototypeGetSymbolToStringTag;\nconst NativeUint16Array = Uint16Array;\nexports.NativeUint16Array = NativeUint16Array;\n\nconst Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\nexports.Uint16ArrayFrom = Uint16ArrayFrom;\nconst NativeUint32Array = Uint32Array;\nexports.NativeUint32Array = NativeUint32Array;\nconst NativeFloat32Array = Float32Array;\nexports.NativeFloat32Array = NativeFloat32Array;\nconst ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\nexports.ArrayIteratorPrototype = ArrayIteratorPrototype;\nconst ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\nexports.ArrayIteratorPrototypeNext = ArrayIteratorPrototypeNext;\nconst GeneratorPrototypeNext = uncurryThis(function* () {}().next);\nexports.GeneratorPrototypeNext = GeneratorPrototypeNext;\nconst IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\nexports.IteratorPrototype = IteratorPrototype;\nconst DataViewPrototype = DataView.prototype;\nconst DataViewPrototypeGetUint16 = uncurryThis(DataViewPrototype.getUint16);\nexports.DataViewPrototypeGetUint16 = DataViewPrototypeGetUint16;\nconst DataViewPrototypeSetUint16 = uncurryThis(DataViewPrototype.setUint16);\nexports.DataViewPrototypeSetUint16 = DataViewPrototypeSetUint16;\nconst NativeTypeError = TypeError;\nexports.NativeTypeError = NativeTypeError;\nconst NativeRangeError = RangeError;\nexports.NativeRangeError = NativeRangeError;\nconst NativeWeakSet = WeakSet;\nexports.NativeWeakSet = NativeWeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\nconst WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\nexports.WeakSetPrototypeAdd = WeakSetPrototypeAdd;\nconst WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\nexports.WeakSetPrototypeHas = WeakSetPrototypeHas;\nconst NativeWeakMap = WeakMap;\nexports.NativeWeakMap = NativeWeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\nconst WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\nexports.WeakMapPrototypeGet = WeakMapPrototypeGet;\nconst WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\nexports.WeakMapPrototypeHas = WeakMapPrototypeHas;\nconst WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\nexports.WeakMapPrototypeSet = WeakMapPrototypeSet;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IsDetachedBuffer = IsDetachedBuffer;\nexports.SpeciesConstructor = SpeciesConstructor;\nexports.ToIntegerOrInfinity = ToIntegerOrInfinity;\nexports.ToLength = ToLength;\nexports.defaultCompare = defaultCompare;\n\nvar _is = require(\"./is.cjs\");\n\nvar _messages = require(\"./messages.cjs\");\n\nvar _primordials = require(\"./primordials.cjs\");\n\nfunction ToIntegerOrInfinity(target) {\n  const number = +target;\n\n  if ((0, _primordials.NumberIsNaN)(number) || number === 0) {\n    return 0;\n  }\n\n  return (0, _primordials.MathTrunc)(number);\n}\n\nfunction ToLength(target) {\n  const length = ToIntegerOrInfinity(target);\n\n  if (length < 0) {\n    return 0;\n  }\n\n  return length < _primordials.MAX_SAFE_INTEGER ? length : _primordials.MAX_SAFE_INTEGER;\n}\n\nfunction SpeciesConstructor(target, defaultConstructor) {\n  if (!(0, _is.isObject)(target)) {\n    throw (0, _primordials.NativeTypeError)(_messages.THIS_IS_NOT_AN_OBJECT);\n  }\n\n  const constructor = target.constructor;\n\n  if (constructor === undefined) {\n    return defaultConstructor;\n  }\n\n  if (!(0, _is.isObject)(constructor)) {\n    throw (0, _primordials.NativeTypeError)(_messages.THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n  }\n\n  const species = constructor[_primordials.SymbolSpecies];\n\n  if (species == null) {\n    return defaultConstructor;\n  }\n\n  return species;\n}\n\nfunction IsDetachedBuffer(buffer) {\n  if ((0, _is.isSharedArrayBuffer)(buffer)) {\n    return false;\n  }\n\n  try {\n    (0, _primordials.ArrayBufferPrototypeSlice)(buffer, 0, 0);\n    return false;\n  } catch (e) {}\n\n  return true;\n}\n\nfunction defaultCompare(x, y) {\n  const isXNaN = (0, _primordials.NumberIsNaN)(x);\n  const isYNaN = (0, _primordials.NumberIsNaN)(y);\n\n  if (isXNaN && isYNaN) {\n    return 0;\n  }\n\n  if (isXNaN) {\n    return 1;\n  }\n\n  if (isYNaN) {\n    return -1;\n  }\n\n  if (x < y) {\n    return -1;\n  }\n\n  if (x > y) {\n    return 1;\n  }\n\n  if (x === 0 && y === 0) {\n    const isXPlusZero = (0, _primordials.ObjectIs)(x, 0);\n    const isYPlusZero = (0, _primordials.ObjectIs)(y, 0);\n\n    if (!isXPlusZero && isYPlusZero) {\n      return -1;\n    }\n\n    if (isXPlusZero && !isYPlusZero) {\n      return 1;\n    }\n  }\n\n  return 0;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hfround = hfround;\n\nvar _converter = require(\"./_util/converter.cjs\");\n\nvar _primordials = require(\"./_util/primordials.cjs\");\n\nfunction hfround(x) {\n  const number = +x;\n\n  if (!(0, _primordials.NumberIsFinite)(number) || number === 0) {\n    return number;\n  }\n\n  const x16 = (0, _converter.roundToFloat16Bits)(number);\n  return (0, _converter.convertToNumber)(x16);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Float16Array = require(\"./Float16Array.cjs\");\n\nexports.Float16Array = _Float16Array.Float16Array;\nexports.isFloat16Array = _Float16Array.isFloat16Array;\n\nvar _isTypedArray = require(\"./isTypedArray.cjs\");\n\nexports.isTypedArray = _isTypedArray.isTypedArray;\n\nvar _DataView = require(\"./DataView.cjs\");\n\nexports.getFloat16 = _DataView.getFloat16;\nexports.setFloat16 = _DataView.setFloat16;\n\nvar _hfround = require(\"./hfround.cjs\");\n\nexports.hfround = _hfround.hfround;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTypedArray = isTypedArray;\n\nvar _Float16Array = require(\"./Float16Array.cjs\");\n\nvar _is = require(\"./_util/is.cjs\");\n\nfunction isTypedArray(target) {\n  return (0, _is.isNativeTypedArray)(target) || (0, _Float16Array.isFloat16Array)(target);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["root","factory","exports","module","define","amd","self","isNumber","value","Number","isNaN","isFiniteNumber","isFinite","isInteger","isPositiveNumber","isPositiveInteger","isNegativeNumber","isNegativeInteger","isNonNegativeNumber","isNonNegativeInteger","isNonPositiveNumber","isNonPositiveInteger","isNumberInRange","min","max","isIntegerInRange","isString","isTypedArray","ArrayBuffer","isView","DataView","isArray","Array","isObject","isBoolean","Object","defineProperty","calcCrc","buf","c","pngDataTable","crcTable","Int32Array","n","k","createPngDataTable","length","changeDpiBlob","blob","dpi","headerChunk","slice","Promise","resolve","reject","fileReader","FileReader","onload","dataArray","Uint8Array","result","tail","changedArray","changeDpiOnArray","type","Blob","readAsArrayBuffer","changeDpiDataUrl","base64Image","dataSplitted","split","format","body","headerLength","overwritepHYs","indexOf","PNG","b64Index","data","b64index","b64PhysSignature1","b64PhysSignature2","b64PhysSignature3","detectPhysChunkFromDataUrl","Math","ceil","JPEG","stringHeader","substring","restOfData","headerBytes","atob","i","charCodeAt","finalArray","base64Header","btoa","String","fromCharCode","apply","arr","arr2","from","_toConsumableArray","join","_P","_H","_Y","_S","physChunk","crc","crcChunk","startingIndex","searchStartOfPhys","set","chunkLength","finalHeader","b","a","autoBom","console","warn","test","d","XMLHttpRequest","open","responseType","g","response","onerror","error","send","status","e","dispatchEvent","MouseEvent","document","createEvent","initMouseEvent","window","f","global","navigator","userAgent","saveAs","HTMLAnchorElement","prototype","h","URL","webkitURL","j","createElement","name","download","rel","href","origin","location","target","createObjectURL","setTimeout","revokeObjectURL","msSaveOrOpenBlob","title","innerText","HTMLElement","safari","onloadend","replace","readAsDataURL","l","m","params","_errorState","_circlePositionsBuffer","_vertexAttributeLocations","_enabledVertexAttributes","_extensions","_clearValue","_copyPrograms","_setValuePrograms","_vertexShaders","DEFAULT_PROGRAM_NAME","src","DEFAULT_VERT_SHADER_SOURCE","compiledShaders","SEGMENT_PROGRAM_NAME","SEGMENT_VERTEX_SHADER_SOURCE","LAYER_POINTS_PROGRAM_NAME","LAYER_POINTS_VERTEX_SHADER_SOURCE","LAYER_VECTOR_FIELD_PROGRAM_NAME","LAYER_VECTOR_FIELD_VERTEX_SHADER_SOURCE","LAYER_LINES_PROGRAM_NAME","LAYER_LINES_VERTEX_SHADER_SOURCE","LAYER_MESH_PROGRAM_NAME","LAYER_MESH_VERTEX_SHADER_SOURCE","verboseLogging","_numTicks","keys","checkValidKeys","checkRequiredKeys","undefined","this","_errorCallback","message","errorCallback","DEFAULT_ERROR_CALLBACK","canvas","gl","context","_gl","contextID","getContext","contextAttributes","WEBGL2","WEBGL1","EXPERIMENTAL_WEBGL2","EXPERIMENTAL_WEBGL","isWebGL2","log","glslVersion","GLSL3","GLSL1","intPrecision","PRECISION_HIGH_P","floatPrecision","disable","DEPTH_TEST","pixelStorei","UNPACK_ALIGNMENT","bindVertexArray","getExtension","OES_VERTEX_ARRAY_OBJECT","bindVertexArrayOES","bindBuffer","ARRAY_BUFFER","clearValue","resize","clientWidth","clientHeight","getParameter","MAX_TEXTURE_IMAGE_UNITS","initWithThreeRenderer","renderer","composer","GPUComposer","capabilities","precision","domElement","_threeRenderer","_setValueProgramForType","key","uniformTypeForType","setValueProgram","_copyProgramForType","copyProgram","_initVertexBuffer","buffer","createBuffer","bufferData","STATIC_DRAW","_getQuadPositionsBuffer","_quadPositionsBuffer","fsQuadPositions","Float32Array","_getBoundaryPositionsBuffer","_boundaryPositionsBuffer","boundaryPositions","_getCirclePositionsBuffer","numSegments","unitCirclePoints","push","cos","PI","sin","circlePositions","_cloneGPULayer","gpuLayer","dimensions","is1D","width","height","clone","GPULayer","numComponents","filter","wrapX","wrapY","numBuffers","incrementBufferIndex","step","program","input","getStateAtIndex","output","bufferIndex","_getVertexShader","vertexID","vertexCompileConstants","programName","Error","preprocessedSrc","preprocessVertexShader","shader","compileShader","VERTEX_SHADER","JSON","stringify","_width","_height","_drawSetup","gpuProgram","fullscreenRender","inputTextures","layer","constructor","currentState","_getProgramWithName","_setOutputLayer","useProgram","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texture","_setInternalFragmentUniforms","_setBlendMode","blendAlpha","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","_addLayerToInputs","indexOfLayerInArray","_passThroughLayerDataFromInputToOutput","state","_internalType","outputArray","numOutputs","outputLayer","_prepareForWrite","_usingTextureOverrideForCurrentBuffer","layer0","additionalTextures","drawBuffers","COLOR_ATTACHMENT0","_currentTexture","bindFrameBuffer","_widthHeightForOutput","viewport","bindFramebuffer","FRAMEBUFFER","_setVertexAttribute","size","locations","WeakMap","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","_disableVertexAttributes","numAttributes","disableVertexAttribArray","_setPositionAttribute","_setIndexAttribute","_setUVAttribute","firstOutput","nextOutput","_iterateOverOutputsIfNeeded","methodName","_childPrograms","_drawFinish","glProgram","_setVertexUniform","drawArrays","TRIANGLE_STRIP","stepBoundary","onePx","edges","numEdges","edge","BOUNDARY_LEFT","LINES","BOUNDARY_RIGHT","BOUNDARY_TOP","BOUNDARY_BOTTOM","LINE_LOOP","stepNonBoundary","stepCircle","position","diameter","useOutputScale","DEFAULT_CIRCLE_NUM_SEGMENTS","TRIANGLE_FAN","stepSegment","position1","position2","thickness","diffX","diffY","angle","atan2","centerX","centerY","sqrt","numCapSegments","endCaps","stepRect","drawLayerAsPoints","_pointIndexArray","count","MAX_FLOAT_INT","color","setUniform","vertexShaderOptions","GPUIO_VS_POSITION_W_ACCUM","GPUIO_VS_WRAP_X","GPUIO_VS_WRAP_Y","INT","pointSize","positionLayerDimensions","_pointIndexBuffer","indices","initSequentialFloatArray","POINTS","drawLayerAsVectorField","_vectorFieldIndexArray","vectorScale","vectorSpacing","spacedDimensions","floor","_vectorFieldIndexBuffer","drawLayerAsMesh","_meshIndexBuffer","_meshIndexArray","positionsCount","glType","ELEMENT_ARRAY_BUFFER","drawElements","TRIANGLES","isValidClearValue","_clearValueVec4","clear","clearValueVec4","undoThreeState","resetThreeState","getViewport","ThreejsUtils","Vector4","x","y","resetState","savePNG","filename","callback","toBlob","then","tick","_lastTickTime","_lastTickFPS","currentTime","performance","now","fps","numTicks","currentFPS","parseFloat","toFixed","dispose","deleteBuffer","forEach","_indexedLinesIndexBuffer","values","deleteShader","_wrappedLineColorProgram","_composer","indexBuffer","Uint32Array","UNSIGNED_BYTE","Uint16Array","UNSIGNED_SHORT","OES_ELEMENT_INDEX_UINT","UNSIGNED_INT","GPUIndexBuffer","_bufferIndex","_buffers","calcGPULayerSize","_length","defaultFilter","HALF_FLOAT","NEAREST","LINEAR","isValidFilter","validFilters","CLAMP_TO_EDGE","isValidWrap","validWraps","isValidDataType","validDataTypes","internalType","getGPULayerInternalType","getGLTextureParameters","glFormat","glInternalFormat","glNumChannels","_glInternalFormat","_glFormat","_glType","_glNumChannels","internalFilter","getGPULayerInternalFilter","_internalFilter","_glFilter","_internalWrapX","getGPULayerInternalWrap","wrap","_glWrapS","_internalWrapY","_glWrapT","_initBuffers","array","initFromImageURL","url","isValidImageType","validImageTypes","isValidImageFormat","validImageFormats","image","Image","is2D","_textureOverrides","copyCurrentStateToGPULayer","arrayOrImage","validatedArrayOrImage","validateGPULayerArray","HTMLImageElement","createTexture","getError","texParameteri","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","decrementBufferIndex","index","abs","setFromArray","validatedArray","_destroyBuffers","applyToAllBuffers","endIndex","_getValuesSetup","_valuesRaw","RGBA","RGBA_INTEGER","BYTE","SHORT","readyToRead","checkFramebufferStatus","_getValuesPost","OUTPUT_LENGTH","handleFloat16Conversion","_valuesBufferView","arrayConstructorForType","_values","initArrayForType","index1","index2","getFloat16","getValues","readPixels","getValuesAsync","readPixelsAsync","_getCanvasWithImageData","multiplier","imageData","getImageData","indexFlipped","putImageData","getImage","toDataURL","attachToThreeTexture","offsetTextureProperties","properties","get","deleteTexture","__webglTexture","__webglInit","disposeFramebuffers","results","writeSupport","filterWrapSupport","shouldCastIntTypeAsFloat","testWriteSupport","framebuffer","createFramebuffer","framebufferTexture2D","validStatus","FRAMEBUFFER_COMPLETE","deleteFramebuffer","testFilterWrap","glWrap","glFilter","valuesTyped","valuesTyped16","float16View","setFloat16","offset","fragmentShaderSource","convertFragmentShaderToGLSL1","fragmentShader","FRAGMENT_SHADER","isUnsignedIntType","isIntType","wrapValue","val","vertexShader","initGLProgram","uniform2fv","getUniformLocation","filtered","supported","tol","expected","_x","deleteProgram","minMaxValuesForType","Infinity","MIN_UNSIGNED_BYTE","MAX_UNSIGNED_BYTE","MIN_BYTE","MAX_BYTE","MIN_UNSIGNED_SHORT","MAX_UNSIGNED_SHORT","MIN_SHORT","MAX_SHORT","MIN_UNSIGNED_INT","MAX_UNSIGNED_INT","MIN_INT","MAX_INT","halfFloatsAsFloats","OES_TEXTURE_HAlF_FLOAT_LINEAR","OES_TEXTURE_FLOAT_LINEAR","RED","RG","RED_INTEGER","RG_INTEGER","R16F","RG16F","RGBA16F","R32F","RG32F","RGBA32F","R8UI","RG8UI","RGBA8UI","R8I","RG8I","RGBA8I","R16I","RG16I","RGBA16I","R16UI","RG16UI","RGBA16UI","R32I","RG32I","RGBA32I","R32UI","RG32UI","RGBA32UI","OES_TEXTURE_HALF_FLOAT","HALF_FLOAT_OES","missingParams","EXT_COLOR_BUFFER_FLOAT","EXT_COLOR_BUFFER_HALF_FLOAT","OES_TEXTURE_FLOAT","shouldTypeCast","Int8Array","Int16Array","validArrayTypes","map","arrayLength","shouldResize","view","_len","origValue","clipped","_fragmentShaders","_compileTimeConstants","_uniforms","_programs","_programsKeyLookup","_samplerUniformsIndices","uniforms","compileTimeConstants","preprocessFragmentShader","shaderSource","samplerUniforms","additionalSources","_fragmentShaderSource","inputIndex","shaderIndex","GPUProgram","numChildren","GPUProgramChild","includes","OES_STANDARD_DERIVATIVES","recompile","needsRecompile","programKeys","numPrograms","delete","fragmentShaderKeys","numFragmentShaders","numUniforms","_getFragmentShader","fragmentId","internalCompileTimeConstants","fragmentID","fragmentCompileConstants","wrapXVal","REPEAT","wrapYVal","filterVal","SAMPLER2D_WRAP_X","SAMPLER2D_WRAP_Y","SAMPLER2D_FILTER","SAMPLER2D_CAST_INT","uniformNames","uniformName","uniform","_setProgramUniform","isGLSL3","_location","getUniform","badType","BOOL_1D_UNIFORM","BOOL_2D_UNIFORM","BOOL_3D_UNIFORM","BOOL_4D_UNIFORM","FLOAT_1D_UNIFORM","FLOAT_2D_UNIFORM","FLOAT_3D_UNIFORM","FLOAT_4D_UNIFORM","INT_1D_UNIFORM","INT_2D_UNIFORM","INT_3D_UNIFORM","INT_4D_UNIFORM","UINT_1D_UNIFORM","UINT_2D_UNIFORM","UINT_3D_UNIFORM","UINT_4D_UNIFORM","uniform1i","uniform2i","uniform3i","uniform4i","uniform1f","uniform3fv","uniform4fv","uniform2iv","uniform3iv","uniform4iv","uniform1ui","uniform2uiv","uniform3uiv","uniform4uiv","_cacheUniformValue","oldValue","currentType","uniformInternalTypeForValue","samplerUniform","find","programNames","indexLookup","fill","filterMismatch","halfPxSize","halfPxUniform","SAMPLER2D_HALF_PX_UNIFORM","dimensionsUniform","SAMPLER2D_DIMENSIONS_UNIFORM","_gpuio_child_params","valueLength","valueType","glslTypeForType","outputType","glslType","glslPrefixForType","numInputs","components","arrayOfLengthNumInputs","el","componentSelection","glslComponentSelectionForNumComponents","opacity","glslFloatType","glslPrefix","shouldCast","scale","colorMax","colorMin","castFloat","component","bias","colorCenter","z","w","copy","v","isNumberOfType","validKeys","requiredKeys","BOOL","UINT","RGB","PRECISION_LOW_P","PRECISION_MEDIUM_P","GPUIO_VS_INDEXED_POSITIONS","GPUIO_VS_UV_ATTRIBUTE","GPUIO_VS_NORMAL_ATTRIBUTE","MIN_HALF_FLOAT_INT","MAX_HALF_FLOAT_INT","MIN_FLOAT_INT","GPUIO_INT_PRECISION","GPUIO_FLOAT_PRECISION","WEBGL_DEPTH_TEXTURE","extensionName","optional","extension","framebufferMap","allTextureFramebuffersMap","texture0","numTextures","initFrameBuffer","allFramebuffers","numFramebuffers","PRECISION_SOURCE","intForPrecision","VERTEX_SHADER_HELPERS_SOURCE","_testing","isFloatType","utils","isSignedIntType","makeShaderHeader","isPowerOf2","extensions","regex","checks","GPULayerHelpers","polyfills","conversions","isWebGL2Supported","isHighpSupportedInVertexShader","isHighpSupportedInFragmentShader","getVertexShaderMediumpPrecision","getFragmentShaderMediumpPrecision","Programs","addLayersProgram","addValueProgram","multiplyValueProgram","setColorProgram","zeroProgram","renderRGBProgram","renderAmplitudeProgram","renderSignedAmplitudeProgram","floatTypeForIntType","sign","trunc","round","roundEven","type1","type2","clamp","mix","floatTypeForBoolType","det2","det3","index1DToUV","modi","stepi","bitshiftLeft","bitshiftRight","bitwiseOr","numBits","bitwiseXOR","bitwiseAnd","bitwiseNot","textureCalls","match","getSampler2DsInProgram","RegExp","remainingTextureCalls","polyfillUniforms","make_GPUIO_TEXTURE_POLYFILL","prefix","castOpening","castEnding","make_GPUIO_TEXTURE_WRAP","lookupFunction","wrapType","extraParams","GLSL1_POLYFILLS","E","FRAGMENT_SHADER_POLYFILLS","suffix","escapeRegExp","string","typecastVariable","variableName","regexMatch","assignmentExpressions","regexValueMatch","regexReplace","_castVaryingToFloat","regexString","castToFloatExpressions","regexVariableMatch","variable","castVaryingToFloat","getFragmentOuts","outs","maxLocation","variableNames","numVariables","outsSorted","parseInt","shaderSources","numOuts","outRegex","outShaderSource","assignmentFound","filler","gl_FragColor","containsGLFragColor","origLength","samplersNoDuplicates","samplers","uniformMatch","sampler","supportsWebGL2","supportsHighpVertex","supportsHighpFragment","mediumpVertexPrecision","mediumpFragmentPrecision","convertCompileTimeConstantsToString","CTCSource","versionSource","compileTimeConstantsSource","precisionConstantsSource","shaderType","checkCompileStatus","createShader","shaderHeader","fullShaderSource","getShaderParameter","COMPILE_STATUS","line","getShaderInfoLog","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","WebGL2RenderingContext","WebGL2ComputeRenderingContext","isHighpSupported","vsSource","fsSource","vs","fs","vertexSupport","fragmentSupport","test1PxCalc","addUniforms","positionLocation","pixel","preprocessShader","stripVersion","stripPrecision","stripComments","convertShaderToGLSL1","glsl1Sampler2D","glsl1Uint","glsl1Texture","glsl1FragmentIn","glsl1FragmentOut","clientWaitAsync","sync","flags","interval_ms","res","clientWaitSync","WAIT_FAILED","TIMEOUT_EXPIRED","getBufferSubDataAsync","srcByteOffset","dstBuffer","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","deleteSync","getBufferSubData","vLocation","uniform3f","mediumpPrecision","highpToMediump","glsl1VertexIn","glsl1VertexOut","convertVertexShaderToGLSL1","checkFragmentShaderForFragColor","fragmentShaderPolyfills","texturePolyfill","sources","numSources","GLSL1Polyfills","shift","findIndex","item","PIXEL_PACK_BUFFER","byteLength","STREAM_READ","dataView","byteOffset","opts","_converter","convertToNumber","_primordials","DataViewPrototypeGetUint16","_arrayIterator","safeIfNeeded","DataViewPrototypeSetUint16","roundToFloat16Bits","isFloat16Array","_brand","_is","_messages","_spec","float16bitsArrays","NativeWeakMap","WeakMapPrototypeHas","ArrayBufferIsView","hasFloat16ArrayBrand","assertFloat16Array","NativeTypeError","THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT","assertSpeciesTypedArray","isTargetFloat16Array","isTargetTypedArray","isNativeTypedArray","SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT","float16bitsArray","getFloat16BitsArray","TypedArrayPrototypeGetLength","DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH","isNativeBigIntTypedArray","CANNOT_MIX_BIGINT_AND_OTHER_TYPES","float16","WeakMapPrototypeGet","TypedArrayPrototypeGetBuffer","IsDetachedBuffer","ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER","cloned","ReflectConstruct","Float16Array","copyToArray","TypedArrayPrototypeGetters","NativeWeakSet","ReflectOwnKeys","TypedArrayPrototype","SymbolToStringTag","descriptor","ReflectGetOwnPropertyDescriptor","ObjectHasOwn","WeakSetPrototypeAdd","handler","ObjectFreeze","receiver","isCanonicalIntegerIndexString","ReflectGet","WeakSetPrototypeHas","ObjectPrototype__lookupGetter__","ReflectSet","getOwnPropertyDescriptor","ReflectDefineProperty","_byteOffset","NativeUint16Array","isArrayBuffer","list","BufferConstructor","isSharedArrayBuffer","NativeArrayBuffer","SpeciesConstructor","iterator","SymbolIterator","ITERATOR_PROPERTY_IS_NOT_CALLABLE","isOrdinaryArray","ToLength","arguments","proxy","NativeProxy","WeakMapPrototypeSet","static","Constructor","ReflectHas","brand","THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY","uint16","TypedArrayPrototypeGetByteOffset","TypedArrayPrototypeSlice","Uint16ArrayFrom","mapFunc","thisArg","args","ReflectApply","isOrdinaryNativeTypedArray","CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT","NativeObject","items","TypedArrayPrototypeKeys","TypedArrayPrototypeValues","entries","TypedArrayPrototypeEntries","at","relativeIndex","ToIntegerOrInfinity","kept","ArrayPrototypePush","reduce","REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE","accumulator","start","reduceRight","findLast","findLastIndex","every","some","targetOffset","NativeRangeError","OFFSET_IS_OUT_OF_BOUNDS","TypedArrayPrototypeSet","targetLength","srcLength","reverse","TypedArrayPrototypeReverse","TypedArrayPrototypeFill","copyWithin","TypedArrayPrototypeCopyWithin","sort","compareFn","sortCompare","defaultCompare","TypedArrayPrototypeSort","end","relativeStart","relativeEnd","final","subarray","begin","uint16Subarray","TypedArrayPrototypeSubarray","element","lastIndexOf","NumberIsNaN","separator","ArrayPrototypeJoin","toLocaleString","ArrayPrototypeToLocaleString","ObjectDefineProperty","ReflectSetPrototypeOf","TypedArray","Float16ArrayPrototype","writable","configurable","NativeArrayPrototypeSymbolIterator","safe","ObjectCreate","SafeIteratorPrototype","arrayIterators","ArrayPrototypeSymbolIterator","generator","dummy","DummyArrayIteratorPrototype","generators","next","arrayIterator","ArrayIteratorPrototypeNext","IteratorPrototype","GeneratorPrototypeNext","ArrayIteratorPrototype","isObjectLike","ReflectGetPrototypeOf","THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT","SymbolFor","float16bits","uint32View","mantissaTable","offsetTable","exponentTable","floatView","num","baseTable","shiftTable","NativeFloat32Array","NativeUint32Array","ArrayBufferPrototypeGetByteLength","number","NumberIsFinite","MathTrunc","typedArrayName","TypedArrayPrototypeGetSymbolToStringTag","ArrayIsArray","NativeTypedArrayPrototypeSymbolIterator","NativeSharedArrayBuffer","SharedArrayBufferPrototypeGetByteLength","THIS_IS_NOT_AN_OBJECT","uncurryThis","uncurryThisGetter","construct","getPrototypeOf","has","ownKeys","setPrototypeOf","Reflect","Proxy","MAX_SAFE_INTEGER","species","SymbolSpecies","toStringTag","for","Symbol","create","freeze","is","ObjectIs","ObjectPrototype","__lookupGetter__","object","hasOwn","hasOwnProperty","NativeArray","ArrayPrototype","ArrayBufferPrototype","ArrayBufferPrototypeSlice","SharedArrayBuffer","TypedArrayFrom","DataViewPrototype","getUint16","setUint16","TypeError","RangeError","WeakSet","WeakSetPrototype","add","WeakMapPrototype","defaultConstructor","isXNaN","isYNaN","isXPlusZero","isYPlusZero","hfround","x16","_Float16Array","_isTypedArray","_DataView","_hfround","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","globalThis","Function"],"sourceRoot":""}