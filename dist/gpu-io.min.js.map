{"version":3,"file":"gpu-io.min.js","mappings":"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","sources":["webpack://GPUIO/webpack/universalModuleDefinition","webpack://GPUIO/./node_modules/@amandaghassaei/type-checks/dist/type-checks.js","webpack://GPUIO/./node_modules/@petamoriken/float16/src/lib.js","webpack://GPUIO/./node_modules/@petamoriken/float16/src/hfround.js","webpack://GPUIO/./node_modules/lodash-es/_freeGlobal.js","webpack://GPUIO/./node_modules/lodash-es/_root.js","webpack://GPUIO/./node_modules/lodash-es/_Symbol.js","webpack://GPUIO/./node_modules/lodash-es/_getRawTag.js","webpack://GPUIO/./node_modules/lodash-es/_objectToString.js","webpack://GPUIO/./node_modules/lodash-es/_baseGetTag.js","webpack://GPUIO/./node_modules/lodash-es/isObject.js","webpack://GPUIO/./node_modules/lodash-es/isFunction.js","webpack://GPUIO/./node_modules/lodash-es/_coreJsData.js","webpack://GPUIO/./node_modules/lodash-es/_isMasked.js","webpack://GPUIO/./node_modules/lodash-es/_toSource.js","webpack://GPUIO/./node_modules/lodash-es/_baseIsNative.js","webpack://GPUIO/./node_modules/lodash-es/_getValue.js","webpack://GPUIO/./node_modules/lodash-es/_getNative.js","webpack://GPUIO/./node_modules/lodash-es/_nativeCreate.js","webpack://GPUIO/./node_modules/lodash-es/_hashClear.js","webpack://GPUIO/./node_modules/lodash-es/_hashDelete.js","webpack://GPUIO/./node_modules/lodash-es/_hashGet.js","webpack://GPUIO/./node_modules/lodash-es/_hashHas.js","webpack://GPUIO/./node_modules/lodash-es/_hashSet.js","webpack://GPUIO/./node_modules/lodash-es/_Hash.js","webpack://GPUIO/./node_modules/lodash-es/_listCacheClear.js","webpack://GPUIO/./node_modules/lodash-es/eq.js","webpack://GPUIO/./node_modules/lodash-es/_assocIndexOf.js","webpack://GPUIO/./node_modules/lodash-es/_listCacheDelete.js","webpack://GPUIO/./node_modules/lodash-es/_listCacheGet.js","webpack://GPUIO/./node_modules/lodash-es/_listCacheHas.js","webpack://GPUIO/./node_modules/lodash-es/_listCacheSet.js","webpack://GPUIO/./node_modules/lodash-es/_ListCache.js","webpack://GPUIO/./node_modules/lodash-es/_Map.js","webpack://GPUIO/./node_modules/lodash-es/_mapCacheClear.js","webpack://GPUIO/./node_modules/lodash-es/_isKeyable.js","webpack://GPUIO/./node_modules/lodash-es/_getMapData.js","webpack://GPUIO/./node_modules/lodash-es/_mapCacheDelete.js","webpack://GPUIO/./node_modules/lodash-es/_mapCacheGet.js","webpack://GPUIO/./node_modules/lodash-es/_mapCacheHas.js","webpack://GPUIO/./node_modules/lodash-es/_mapCacheSet.js","webpack://GPUIO/./node_modules/lodash-es/_MapCache.js","webpack://GPUIO/./node_modules/lodash-es/memoize.js","webpack://GPUIO/./node_modules/@petamoriken/float16/src/bug.js","webpack://GPUIO/./node_modules/@petamoriken/float16/src/spec.js","webpack://GPUIO/./node_modules/@petamoriken/float16/src/is.js","webpack://GPUIO/./node_modules/lodash-es/isObjectLike.js","webpack://GPUIO/./node_modules/lodash-es/_baseIsArrayBuffer.js","webpack://GPUIO/./node_modules/lodash-es/_baseUnary.js","webpack://GPUIO/./node_modules/lodash-es/_nodeUtil.js","webpack://GPUIO/./node_modules/lodash-es/isArrayBuffer.js","webpack://GPUIO/./node_modules/@petamoriken/float16/src/Float16Array.js","webpack://GPUIO/./node_modules/@petamoriken/float16/src/private.js","webpack://GPUIO/./node_modules/@petamoriken/float16/src/dataView.js","webpack://GPUIO/./node_modules/changedpi/dist/index.js","webpack://GPUIO/./node_modules/file-saver/dist/FileSaver.min.js","webpack://GPUIO/./src/GPUComposer.ts","webpack://GPUIO/./src/GPULayer.ts","webpack://GPUIO/./src/GPULayerHelpers.ts","webpack://GPUIO/./src/GPUProgram.ts","webpack://GPUIO/./src/Programs.ts","webpack://GPUIO/./src/Vector4.ts","webpack://GPUIO/./src/checks.ts","webpack://GPUIO/./src/constants.ts","webpack://GPUIO/./src/conversions.ts","webpack://GPUIO/./src/extensions.ts","webpack://GPUIO/./src/framebuffers.ts","webpack://GPUIO/./src/glsl/common/precision.ts","webpack://GPUIO/./src/glsl/vertex/DefaultVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/LayerLinesVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/LayerPointsVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/LayerVectorFieldVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/SegmentVertexShader.ts","webpack://GPUIO/./src/glsl/vertex/VertexShaderHelpers.ts","webpack://GPUIO/./src/index.ts","webpack://GPUIO/./src/polyfills.ts","webpack://GPUIO/./src/regex.ts","webpack://GPUIO/./src/utils.ts","webpack://GPUIO/webpack/bootstrap","webpack://GPUIO/webpack/runtime/define property getters","webpack://GPUIO/webpack/runtime/global","webpack://GPUIO/webpack/runtime/hasOwnProperty shorthand","webpack://GPUIO/webpack/runtime/make namespace object","webpack://GPUIO/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GPUIO\"] = factory();\n\telse\n\t\troot[\"GPUIO\"] = factory();\n})(self, () => {\nreturn ","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TypeChecks = {}));\n})(this, (function (exports) { 'use strict';\n\n\t/**\n\t * Checks if value is a number (including Infinity).\n\t */\n\tfunction isNumber(value) {\n\t    return !Number.isNaN(value) && typeof value === 'number';\n\t}\n\t/**\n\t * Checks if value is finite number.\n\t */\n\tfunction isFiniteNumber(value) {\n\t    return isNumber(value) && Number.isFinite(value);\n\t}\n\t/**\n\t * Checks if value is finite integer.\n\t */\n\tfunction isInteger(value) {\n\t    return isFiniteNumber(value) && (value % 1 === 0);\n\t}\n\t/**\n\t * Checks if value is finite positive integer (> 0).\n\t */\n\tfunction isPositiveInteger(value) {\n\t    return isInteger(value) && value > 0;\n\t}\n\t/**\n\t * Checks if value is finite non-negative integer (>= 0).\n\t */\n\tfunction isNonNegativeInteger(value) {\n\t    return isInteger(value) && value >= 0;\n\t}\n\t/**\n\t * Checks if value is string.\n\t */\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t/**\n\t * Checks if value is TypedArray.\n\t */\n\tfunction isTypedArray(value) {\n\t    return ArrayBuffer.isView(value) && !(value instanceof DataView);\n\t}\n\t/**\n\t * Checks if value is Array or TypedArray.\n\t */\n\tfunction isArray(value) {\n\t    return Array.isArray(value) || isTypedArray(value);\n\t}\n\t/**\n\t * Checks if value is Javascript object.\n\t */\n\tfunction isObject(value) {\n\t    return typeof value === 'object' && !isArray(value) && value !== null && !(value instanceof ArrayBuffer) && !(value instanceof DataView);\n\t}\n\t/**\n\t * Checks if value is boolean.\n\t */\n\tfunction isBoolean(value) {\n\t    return typeof value === 'boolean';\n\t}\n\n\texports.isArray = isArray;\n\texports.isBoolean = isBoolean;\n\texports.isFiniteNumber = isFiniteNumber;\n\texports.isInteger = isInteger;\n\texports.isNonNegativeInteger = isNonNegativeInteger;\n\texports.isNumber = isNumber;\n\texports.isObject = isObject;\n\texports.isPositiveInteger = isPositiveInteger;\n\texports.isString = isString;\n\texports.isTypedArray = isTypedArray;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=type-checks.js.map\n","// algorithm: ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf\n\nconst buffer = new ArrayBuffer(4);\nconst floatView = new Float32Array(buffer);\nconst uint32View = new Uint32Array(buffer);\n\n\nconst baseTable = new Uint32Array(512);\nconst shiftTable = new Uint32Array(512);\n\nfor(let i = 0; i < 256; ++i) {\n    const e = i - 127;\n\n    // very small number (0, -0)\n    if (e < -27) {\n        baseTable[i | 0x000] = 0x0000;\n        baseTable[i | 0x100] = 0x8000;\n        shiftTable[i | 0x000] = 24;\n        shiftTable[i | 0x100] = 24;\n\n    // small number (denorm)\n    } else if (e < -14) {\n        baseTable[i | 0x000] =  0x0400 >> (-e - 14);\n        baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n        shiftTable[i | 0x000] = -e - 1;\n        shiftTable[i | 0x100] = -e - 1;\n\n    // normal number\n    } else if (e <= 15) {\n        baseTable[i | 0x000] =  (e + 15) << 10;\n        baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n        shiftTable[i | 0x000] = 13;\n        shiftTable[i | 0x100] = 13;\n\n    // large number (Infinity, -Infinity)\n    } else if (e < 128) {\n        baseTable[i | 0x000] = 0x7c00;\n        baseTable[i | 0x100] = 0xfc00;\n        shiftTable[i | 0x000] = 24;\n        shiftTable[i | 0x100] = 24;\n\n    // stay (NaN, Infinity, -Infinity)\n    } else {\n        baseTable[i | 0x000] = 0x7c00;\n        baseTable[i | 0x100] = 0xfc00;\n        shiftTable[i | 0x000] = 13;\n        shiftTable[i | 0x100] = 13;\n    }\n}\n\n/**\n * round a number to a half float number bits.\n * @param {number} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n    floatView[0] = num;\n\n    const f = uint32View[0];\n    const e = (f >> 23) & 0x1ff;\n    return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\n\nconst mantissaTable = new Uint32Array(2048);\nconst exponentTable = new Uint32Array(64);\nconst offsetTable = new Uint32Array(64);\n\nmantissaTable[0] = 0;\nfor(let i = 1; i < 1024; ++i) {\n    let m = i << 13;    // zero pad mantissa bits\n    let e = 0;          // zero exponent\n\n    // normalized\n    while((m & 0x00800000) === 0) {\n        e -= 0x00800000;    // decrement exponent\n        m <<= 1;\n    }\n\n    m &= ~0x00800000;   // clear leading 1 bit\n    e += 0x38800000;    // adjust bias\n\n    mantissaTable[i] = m | e;\n}\nfor(let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nexponentTable[0] = 0;\nfor(let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor(let i = 33; i < 63; ++i) {\n    exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\noffsetTable[0] = 0;\nfor(let i = 1; i < 64; ++i) {\n    if (i === 32) {\n        offsetTable[i] = 0;\n    } else {\n        offsetTable[i] = 1024;\n    }\n}\n\n/**\n * convert a half float number bits to a number.\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n    const m = float16bits >> 10;\n    uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];\n    return floatView[0];\n}\n","import { convertToNumber, roundToFloat16Bits } from \"./lib\";\n\n/**\n * returns the nearest half precision float representation of a number.\n * @param {number} num\n * @returns {number}\n */\nexport default function hfround(num) {\n    num = Number(num);\n\n    // for optimization\n    if (!Number.isFinite(num) || num === 0) {\n        return num;\n    }\n\n    const x16 = roundToFloat16Bits(num);\n    return convertToNumber(x16);\n}\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n","import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n","import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n","import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n","import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n","import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n","import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n","import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n","import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n","import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n","import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n","import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n","import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n","import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n","import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n","import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n","import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n","import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n","/**\n * JavaScriptCore <= 12 bug\n * @see https://bugs.webkit.org/show_bug.cgi?id=171606\n */\nexport const isTypedArrayIndexedPropertyWritable = Object.getOwnPropertyDescriptor(new Uint8Array(1), 0).writable;\n","/**\n * @param {unknown} target\n * @returns {number}\n */\nexport function ToInteger(target) {\n    let number = typeof target !== \"number\" ? Number(target) : target;\n    if (Number.isNaN(number)) {\n        number = 0;\n    }\n    return Math.trunc(number);\n}\n\n/**\n * @param {number} x\n * @param {number} y\n * @returns {-1 | 0 | 1}\n */\nexport function defaultCompareFunction(x, y) {\n    const [isNaN_x, isNaN_y] = [Number.isNaN(x), Number.isNaN(y)];\n\n    if (isNaN_x && isNaN_y) {\n        return 0;\n    }\n\n    if (isNaN_x) {\n        return 1;\n    }\n\n    if (isNaN_y) {\n        return -1;\n    }\n\n    if (x < y) {\n        return -1;\n    }\n\n    if (x > y) {\n        return 1;\n    }\n\n    if (x === 0 && y === 0) {\n        const [isPlusZero_x, isPlusZero_y] = [Object.is(x, 0), Object.is(y, 0)];\n\n        if (!isPlusZero_x && isPlusZero_y) {\n            return -1;\n        }\n\n        if (isPlusZero_x && !isPlusZero_y) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n","import { ToInteger } from \"./spec\";\n\nexport { default as isArrayBuffer } from \"lodash-es/isArrayBuffer\";\n\n/**\n * @param {unknown} view\n * @returns {boolean}\n */\nexport function isDataView(view) {\n    return view instanceof DataView;\n}\n\n/**\n * @param {unknown} key\n * @returns {boolean}\n */\nexport function isStringNumberKey(key) {\n    return typeof key === \"string\" && key === ToInteger(key) + \"\";\n}\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\n\n/**\n * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n */\nfunction baseIsArrayBuffer(value) {\n  return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n}\n\nexport default baseIsArrayBuffer;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nexport default baseUnary;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nexport default nodeUtil;\n","import baseIsArrayBuffer from './_baseIsArrayBuffer.js';\nimport baseUnary from './_baseUnary.js';\nimport nodeUtil from './_nodeUtil.js';\n\n/* Node.js helper references. */\nvar nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;\n\n/**\n * Checks if `value` is classified as an `ArrayBuffer` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n * @example\n *\n * _.isArrayBuffer(new ArrayBuffer(2));\n * // => true\n *\n * _.isArrayBuffer(new Array(2));\n * // => false\n */\nvar isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\nexport default isArrayBuffer;\n","import memoize from \"lodash-es/memoize\";\nimport { isTypedArrayIndexedPropertyWritable } from \"./bug\";\nimport { isArrayBuffer, isStringNumberKey } from \"./is\";\nimport { convertToNumber, roundToFloat16Bits } from \"./lib\";\nimport { createPrivateStorage } from \"./private\";\nimport { ToInteger, defaultCompareFunction } from \"./spec\";\n\nconst _ = createPrivateStorage();\n\n/**\n * @param {unknown} target\n * @returns {boolean}\n */\nfunction isFloat16Array(target) {\n    return target instanceof Float16Array;\n}\n\n/**\n * @param {unknown} target\n * @throws {TypeError}\n */\nfunction assertFloat16Array(target) {\n    if (!isFloat16Array(target)) {\n        throw new TypeError(\"This is not a Float16Array\");\n    }\n}\n\n/**\n * @param {unknown} target\n * @returns {boolean}\n */\nfunction isDefaultFloat16ArrayMethods(target) {\n    return typeof target === \"function\" && defaultFloat16ArrayMethods.has(target);\n}\n\n/**\n * @param {Float16Array} float16bits\n * @return {number[]}\n */\nfunction copyToArray(float16bits) {\n    const length = float16bits.length;\n\n    const array = new Array(length);\n    for(let i = 0; i < length; ++i) {\n        array[i] = convertToNumber(float16bits[i]);\n    }\n\n    return array;\n}\n\n/** @type {ProxyHandler<Function>} */\nconst applyHandler = {\n    apply(func, thisArg, args) {\n        // peel off proxy\n        if (isFloat16Array(thisArg) && isDefaultFloat16ArrayMethods(func)) {\n            return Reflect.apply(func, _(thisArg).target ,args);\n        }\n\n        return Reflect.apply(func, thisArg, args);\n    },\n};\n\n/** @type {ProxyHandler<Float16Array>} */\nconst handler = {\n    get(target, key) {\n        let wrapper = null;\n        if (!isTypedArrayIndexedPropertyWritable) {\n            wrapper = target;\n            target = _(wrapper).target;\n        }\n\n        if (isStringNumberKey(key)) {\n            return Reflect.has(target, key) ? convertToNumber(Reflect.get(target, key)) : undefined;\n        } else {\n            const ret = wrapper !== null && Reflect.has(wrapper, key) ? Reflect.get(wrapper, key) : Reflect.get(target, key);\n\n            if (typeof ret !== \"function\") {\n                return ret;\n            }\n\n            // TypedArray methods can't be called by Proxy Object\n            let proxy = _(ret).proxy;\n\n            if (proxy === undefined) {\n                proxy = _(ret).proxy = new Proxy(ret, applyHandler);\n            }\n\n            return proxy;\n        }\n    },\n\n    set(target, key, value) {\n        let wrapper = null;\n        if (!isTypedArrayIndexedPropertyWritable) {\n            wrapper = target;\n            target = _(wrapper).target;\n        }\n\n        if (isStringNumberKey(key)) {\n            return Reflect.set(target, key, roundToFloat16Bits(value));\n        } else {\n            // frozen object can't change prototype property\n            if (wrapper !== null && (!Reflect.has(target, key) || Object.isFrozen(wrapper))) {\n                return Reflect.set(wrapper, key, value);\n            } else {\n                return Reflect.set(target, key, value);\n            }\n        }\n    },\n};\n\nif (!isTypedArrayIndexedPropertyWritable) {\n    handler.getPrototypeOf = (wrapper) => { return Reflect.getPrototypeOf(_(wrapper).target); };\n    handler.setPrototypeOf = (wrapper, prototype) => { return Reflect.setPrototypeOf(_(wrapper).target, prototype); };\n\n    handler.defineProperty = (wrapper, key, descriptor) => {\n        const target = _(wrapper).target;\n        return !Reflect.has(target, key) || Object.isFrozen(wrapper) ? Reflect.defineProperty(wrapper, key, descriptor) : Reflect.defineProperty(target, key, descriptor);\n    };\n    handler.deleteProperty = (wrapper, key) => {\n        const target = _(wrapper).target;\n        return Reflect.has(wrapper, key) ? Reflect.deleteProperty(wrapper, key) : Reflect.deleteProperty(target, key);\n    };\n\n    handler.has = (wrapper, key) => { return Reflect.has(wrapper, key) || Reflect.has(_(wrapper).target, key); };\n\n    handler.isExtensible = (wrapper) => { return Reflect.isExtensible(wrapper); };\n    handler.preventExtensions = (wrapper) => { return Reflect.preventExtensions(wrapper); };\n\n    handler.getOwnPropertyDescriptor = (wrapper, key) => { return Reflect.getOwnPropertyDescriptor(wrapper, key); };\n    handler.ownKeys = (wrapper) => { return Reflect.ownKeys(wrapper); };\n}\n\nexport default class Float16Array extends Uint16Array {\n\n    constructor(input, byteOffset, length) {\n        // input Float16Array\n        if (isFloat16Array(input)) {\n            super(_(input).target);\n\n        // 22.2.1.3, 22.2.1.4 TypedArray, Array, ArrayLike, Iterable\n        } else if (input !== null && typeof input === \"object\" && !isArrayBuffer(input)) {\n            // if input is not ArrayLike and Iterable, get Array\n            const arrayLike = !Reflect.has(input, \"length\") && input[Symbol.iterator] !== undefined ? [...input] : input;\n\n            const length = arrayLike.length;\n            super(length);\n\n            for(let i = 0; i < length; ++i) {\n                // super (Uint16Array)\n                this[i] = roundToFloat16Bits(arrayLike[i]);\n            }\n\n        // 22.2.1.2, 22.2.1.5 primitive, ArrayBuffer\n        } else {\n            switch(arguments.length) {\n                case 0:\n                    super();\n                    break;\n\n                case 1:\n                    super(input);\n                    break;\n\n                case 2:\n                    super(input, byteOffset);\n                    break;\n\n                case 3:\n                    super(input, byteOffset, length);\n                    break;\n\n                default:\n                    // @ts-ignore\n                    super(...arguments);\n            }\n        }\n\n        let proxy;\n\n        if (isTypedArrayIndexedPropertyWritable) {\n            proxy = new Proxy(this, handler);\n        } else {\n            const wrapper = Object.create(null);\n            _(wrapper).target = this;\n            proxy = new Proxy(wrapper, handler);\n        }\n\n        // proxy private storage\n        _(proxy).target = this;\n\n        // this private storage\n        _(this).proxy = proxy;\n\n        return proxy;\n    }\n\n    // static methods\n    static from(src, ...opts) {\n        if (opts.length === 0) {\n            return new Float16Array(Uint16Array.from(src, roundToFloat16Bits).buffer);\n        }\n\n        const mapFunc = opts[0];\n        const thisArg = opts[1];\n\n        return new Float16Array(Uint16Array.from(src, function (val, ...args) {\n            return roundToFloat16Bits(mapFunc.call(this, val, ...args));\n        }, thisArg).buffer);\n    }\n\n    static of(...args) {\n        return new Float16Array(args);\n    }\n\n    // iterate methods\n    * [Symbol.iterator]() {\n        for(const val of super[Symbol.iterator]()) {\n            yield convertToNumber(val);\n        }\n    }\n\n    keys() {\n        return super.keys();\n    }\n\n    * values() {\n        for(const val of super.values()) {\n            yield convertToNumber(val);\n        }\n    }\n\n    /** @type {() => IterableIterator<[number, number]>} */\n    * entries() {\n        for(const [i, val] of super.entries()) {\n            yield [i, convertToNumber(val)];\n        }\n    }\n\n    // functional methods\n    // @ts-ignore\n    map(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        const array = [];\n        for(let i = 0, l = this.length; i < l; ++i) {\n            const val = convertToNumber(this[i]);\n            array.push(callback.call(thisArg, val, i, _(this).proxy));\n        }\n\n        return new Float16Array(array);\n    }\n\n    // @ts-ignore\n    filter(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        const array = [];\n        for(let i = 0, l = this.length; i < l; ++i) {\n            const val = convertToNumber(this[i]);\n            if (callback.call(thisArg, val, i, _(this).proxy)) {\n                array.push(val);\n            }\n        }\n\n        return new Float16Array(array);\n    }\n\n    reduce(callback, ...opts) {\n        assertFloat16Array(this);\n\n        let val, start;\n\n        if (opts.length === 0) {\n            val = convertToNumber(this[0]);\n            start = 1;\n        } else {\n            val = opts[0];\n            start = 0;\n        }\n\n        for(let i = start, l = this.length; i < l; ++i) {\n            val = callback(val, convertToNumber(this[i]), i, _(this).proxy);\n        }\n\n        return val;\n    }\n\n    reduceRight(callback, ...opts) {\n        assertFloat16Array(this);\n\n        let val, start;\n\n        const length = this.length;\n        if (opts.length === 0) {\n            val = convertToNumber(this[length - 1]);\n            start = length - 1;\n        } else {\n            val = opts[0];\n            start = length;\n        }\n\n        for(let i = start; i--;) {\n            val = callback(val, convertToNumber(this[i]), i, _(this).proxy);\n        }\n\n        return val;\n    }\n\n    forEach(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy);\n        }\n    }\n\n    find(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            const value = convertToNumber(this[i]);\n            if (callback.call(thisArg, value, i, _(this).proxy)) {\n                return value;\n            }\n        }\n    }\n\n    findIndex(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            const value = convertToNumber(this[i]);\n            if (callback.call(thisArg, value, i, _(this).proxy)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    every(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            if (!callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    some(callback, ...opts) {\n        assertFloat16Array(this);\n\n        const thisArg = opts[0];\n\n        for(let i = 0, l = this.length; i < l; ++i) {\n            if (callback.call(thisArg, convertToNumber(this[i]), i, _(this).proxy)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // change element methods\n    set(input, ...opts) {\n        assertFloat16Array(this);\n\n        const offset = opts[0];\n\n        let float16bits;\n\n        // input Float16Array\n        if (isFloat16Array(input)) {\n            float16bits = _(input).target;\n\n        // input others\n        } else {\n            const arrayLike = !Reflect.has(input, \"length\") && input[Symbol.iterator] !== undefined ? [...input] : input;\n            const length = arrayLike.length;\n\n            float16bits = new Uint16Array(length);\n            for(let i = 0, l = arrayLike.length; i < l; ++i) {\n                float16bits[i] = roundToFloat16Bits(arrayLike[i]);\n            }\n        }\n\n        super.set(float16bits, offset);\n    }\n\n    reverse() {\n        assertFloat16Array(this);\n\n        super.reverse();\n\n        return _(this).proxy;\n    }\n\n    fill(value, ...opts) {\n        assertFloat16Array(this);\n\n        super.fill(roundToFloat16Bits(value), ...opts);\n\n        return _(this).proxy;\n    }\n\n    copyWithin(target, start, ...opts) {\n        assertFloat16Array(this);\n\n        super.copyWithin(target, start, ...opts);\n\n        return _(this).proxy;\n    }\n\n    sort(...opts) {\n        assertFloat16Array(this);\n\n        let compareFunction = opts[0];\n\n        if (compareFunction === undefined) {\n            compareFunction = defaultCompareFunction;\n        }\n\n        const _convertToNumber = memoize(convertToNumber);\n\n        super.sort((x, y) => { return compareFunction(_convertToNumber(x), _convertToNumber(y)); });\n\n        return _(this).proxy;\n    }\n\n    // copy element methods\n    // @ts-ignore\n    slice(...opts) {\n        assertFloat16Array(this);\n\n        let float16bits;\n\n        // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError\n        try {\n            float16bits = super.slice(...opts);\n        } catch(e) {\n            if (e instanceof TypeError) {\n                const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);\n                float16bits = uint16.slice(...opts);\n            } else {\n                throw e;\n            }\n        }\n\n        return new Float16Array(float16bits.buffer);\n    }\n\n    // @ts-ignore\n    subarray(...opts) {\n        assertFloat16Array(this);\n\n        let float16bits;\n\n        // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError\n        try {\n            float16bits = super.subarray(...opts);\n        } catch(e) {\n            if (e instanceof TypeError) {\n                const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);\n                float16bits = uint16.subarray(...opts);\n            } else {\n                throw e;\n            }\n        }\n\n        return new Float16Array(float16bits.buffer, float16bits.byteOffset, float16bits.length);\n    }\n\n    // contains methods\n    indexOf(element, ...opts) {\n        assertFloat16Array(this);\n\n        const length = this.length;\n\n        let from = ToInteger(opts[0]);\n\n        if (from < 0) {\n            from += length;\n            if (from < 0) {\n                from = 0;\n            }\n        }\n\n        for(let i = from, l = length; i < l; ++i) {\n            if (convertToNumber(this[i]) === element) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    lastIndexOf(element, ...opts) {\n        assertFloat16Array(this);\n\n        const length = this.length;\n\n        let from = ToInteger(opts[0]);\n\n        from = from === 0 ? length : from + 1;\n\n        if (from >= 0) {\n            from = from < length ? from : length;\n        } else {\n            from += length;\n        }\n\n        for(let i = from; i--;) {\n            if (convertToNumber(this[i]) === element) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    includes(element, ...opts) {\n        assertFloat16Array(this);\n\n        const length = this.length;\n\n        let from = ToInteger(opts[0]);\n\n        if (from < 0) {\n            from += length;\n            if (from < 0) {\n                from = 0;\n            }\n        }\n\n        const isNaN = Number.isNaN(element);\n        for(let i = from, l = length; i < l; ++i) {\n            const value = convertToNumber(this[i]);\n\n            if (isNaN && Number.isNaN(value)) {\n                return true;\n            }\n\n            if (value === element) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // string methods\n    join(...opts) {\n        assertFloat16Array(this);\n\n        const array = copyToArray(this);\n\n        return array.join(...opts);\n    }\n\n    toLocaleString(...opts) {\n        assertFloat16Array(this);\n\n        const array = copyToArray(this);\n\n        // @ts-ignore\n        return array.toLocaleString(...opts);\n    }\n\n    // @ts-ignore\n    get [Symbol.toStringTag]() {\n        if (isFloat16Array(this)) {\n            return \"Float16Array\";\n        }\n    }\n}\n\nconst Float16Array$prototype = Float16Array.prototype;\n\nconst defaultFloat16ArrayMethods = new WeakSet();\nfor(const key of Reflect.ownKeys(Float16Array$prototype)) {\n    const val = Float16Array$prototype[key];\n    if (typeof val === \"function\") {\n        defaultFloat16ArrayMethods.add(val);\n    }\n}\n","/**\n * @returns {(self:object) => object}\n */\nexport function createPrivateStorage() {\n\tconst wm = new WeakMap();\n\treturn (self) => {\n\t\tlet obj = wm.get(self);\n\t\tif (obj) {\n\t\t\treturn obj;\n\t\t} else {\n\t\t\tobj = Object.create(null);\n\t\t\twm.set(self, obj);\n\t\t\treturn obj;\n\t\t}\n\t};\n}\n","import { isDataView } from \"./is\";\nimport { convertToNumber, roundToFloat16Bits } from \"./lib\";\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView.\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nexport function getFloat16(dataView, byteOffset, ...opts) {\n    if (!isDataView(dataView)) {\n        throw new TypeError(\"First argument to getFloat16 function must be a DataView\");\n    }\n\n    return convertToNumber( dataView.getUint16(byteOffset, ...opts) );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView.\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nexport function setFloat16(dataView, byteOffset, value, ...opts) {\n    if (!isDataView(dataView)) {\n        throw new TypeError(\"First argument to setFloat16 function must be a DataView\");\n    }\n\n    dataView.setUint16(byteOffset, roundToFloat16Bits(value), ...opts);\n}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.changeDpiBlob = changeDpiBlob;\nexports.changeDpiDataUrl = changeDpiDataUrl;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction createPngDataTable() {\n  /* Table of CRCs of all 8-bit messages. */\n  var crcTable = new Int32Array(256);\n  for (var n = 0; n < 256; n++) {\n    var c = n;\n    for (var k = 0; k < 8; k++) {\n      c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n    }\n    crcTable[n] = c;\n  }\n  return crcTable;\n}\n\nfunction calcCrc(buf) {\n  var c = -1;\n  if (!pngDataTable) pngDataTable = createPngDataTable();\n  for (var n = 0; n < buf.length; n++) {\n    c = pngDataTable[(c ^ buf[n]) & 0xFF] ^ c >>> 8;\n  }\n  return c ^ -1;\n}\n\nvar pngDataTable = void 0;\n\nvar PNG = 'image/png';\nvar JPEG = 'image/jpeg';\n\n// those are 3 possible signature of the physBlock in base64.\n// the pHYs signature block is preceed by the 4 bytes of lenght. The length of\n// the block is always 9 bytes. So a phys block has always this signature:\n// 0 0 0 9 p H Y s.\n// However the data64 encoding aligns we will always find one of those 3 strings.\n// this allow us to find this particular occurence of the pHYs block without\n// converting from b64 back to string\nvar b64PhysSignature1 = 'AAlwSFlz';\nvar b64PhysSignature2 = 'AAAJcEhZ';\nvar b64PhysSignature3 = 'AAAACXBI';\n\nvar _P = 'p'.charCodeAt(0);\nvar _H = 'H'.charCodeAt(0);\nvar _Y = 'Y'.charCodeAt(0);\nvar _S = 's'.charCodeAt(0);\n\nfunction changeDpiBlob(blob, dpi) {\n  // 33 bytes are ok for pngs and jpegs\n  // to contain the information.\n  var headerChunk = blob.slice(0, 33);\n  return new Promise(function (resolve, reject) {\n    var fileReader = new FileReader();\n    fileReader.onload = function () {\n      var dataArray = new Uint8Array(fileReader.result);\n      var tail = blob.slice(33);\n      var changedArray = changeDpiOnArray(dataArray, dpi, blob.type);\n      resolve(new Blob([changedArray, tail], { type: blob.type }));\n    };\n    fileReader.readAsArrayBuffer(headerChunk);\n  });\n}\n\nfunction changeDpiDataUrl(base64Image, dpi) {\n  var dataSplitted = base64Image.split(',');\n  var format = dataSplitted[0];\n  var body = dataSplitted[1];\n  var type = void 0;\n  var headerLength = void 0;\n  var overwritepHYs = false;\n  if (format.indexOf(PNG) !== -1) {\n    type = PNG;\n    var b64Index = detectPhysChunkFromDataUrl(body);\n    // 28 bytes in dataUrl are 21bytes, length of phys chunk with everything inside.\n    if (b64Index >= 0) {\n      headerLength = Math.ceil((b64Index + 28) / 3) * 4;\n      overwritepHYs = true;\n    } else {\n      headerLength = 33 / 3 * 4;\n    }\n  }\n  if (format.indexOf(JPEG) !== -1) {\n    type = JPEG;\n    headerLength = 18 / 3 * 4;\n  }\n  // 33 bytes are ok for pngs and jpegs\n  // to contain the information.\n  var stringHeader = body.substring(0, headerLength);\n  var restOfData = body.substring(headerLength);\n  var headerBytes = atob(stringHeader);\n  var dataArray = new Uint8Array(headerBytes.length);\n  for (var i = 0; i < dataArray.length; i++) {\n    dataArray[i] = headerBytes.charCodeAt(i);\n  }\n  var finalArray = changeDpiOnArray(dataArray, dpi, type, overwritepHYs);\n  var base64Header = btoa(String.fromCharCode.apply(String, _toConsumableArray(finalArray)));\n  return [format, ',', base64Header, restOfData].join('');\n}\n\nfunction detectPhysChunkFromDataUrl(data) {\n  var b64index = data.indexOf(b64PhysSignature1);\n  if (b64index === -1) {\n    b64index = data.indexOf(b64PhysSignature2);\n  }\n  if (b64index === -1) {\n    b64index = data.indexOf(b64PhysSignature3);\n  }\n  // if b64index === -1 chunk is not found\n  return b64index;\n}\n\nfunction searchStartOfPhys(data) {\n  var length = data.length - 1;\n  // we check from the end since we cut the string in proximity of the header\n  // the header is within 21 bytes from the end.\n  for (var i = length; i >= 4; i--) {\n    if (data[i - 4] === 9 && data[i - 3] === _P && data[i - 2] === _H && data[i - 1] === _Y && data[i] === _S) {\n      return i - 3;\n    }\n  }\n}\n\nfunction changeDpiOnArray(dataArray, dpi, format, overwritepHYs) {\n  if (format === JPEG) {\n    dataArray[13] = 1; // 1 pixel per inch or 2 pixel per cm\n    dataArray[14] = dpi >> 8; // dpiX high byte\n    dataArray[15] = dpi & 0xff; // dpiX low byte\n    dataArray[16] = dpi >> 8; // dpiY high byte\n    dataArray[17] = dpi & 0xff; // dpiY low byte\n    return dataArray;\n  }\n  if (format === PNG) {\n    var physChunk = new Uint8Array(13);\n    // chunk header pHYs\n    // 9 bytes of data\n    // 4 bytes of crc\n    // this multiplication is because the standard is dpi per meter.\n    dpi *= 39.3701;\n    physChunk[0] = _P;\n    physChunk[1] = _H;\n    physChunk[2] = _Y;\n    physChunk[3] = _S;\n    physChunk[4] = dpi >>> 24; // dpiX highest byte\n    physChunk[5] = dpi >>> 16; // dpiX veryhigh byte\n    physChunk[6] = dpi >>> 8; // dpiX high byte\n    physChunk[7] = dpi & 0xff; // dpiX low byte\n    physChunk[8] = physChunk[4]; // dpiY highest byte\n    physChunk[9] = physChunk[5]; // dpiY veryhigh byte\n    physChunk[10] = physChunk[6]; // dpiY high byte\n    physChunk[11] = physChunk[7]; // dpiY low byte\n    physChunk[12] = 1; // dot per meter....\n\n    var crc = calcCrc(physChunk);\n\n    var crcChunk = new Uint8Array(4);\n    crcChunk[0] = crc >>> 24;\n    crcChunk[1] = crc >>> 16;\n    crcChunk[2] = crc >>> 8;\n    crcChunk[3] = crc & 0xff;\n\n    if (overwritepHYs) {\n      var startingIndex = searchStartOfPhys(dataArray);\n      dataArray.set(physChunk, startingIndex);\n      dataArray.set(crcChunk, startingIndex + 13);\n      return dataArray;\n    } else {\n      // i need to give back an array of data that is divisible by 3 so that\n      // dataurl encoding gives me integers, for luck this chunk is 17 + 4 = 21\n      // if it was we could add a text chunk contaning some info, untill desired\n      // length is met.\n\n      // chunk structur 4 bytes for length is 9\n      var chunkLength = new Uint8Array(4);\n      chunkLength[0] = 0;\n      chunkLength[1] = 0;\n      chunkLength[2] = 0;\n      chunkLength[3] = 9;\n\n      var finalHeader = new Uint8Array(54);\n      finalHeader.set(dataArray, 0);\n      finalHeader.set(chunkLength, 33);\n      finalHeader.set(physChunk, 37);\n      finalHeader.set(crcChunk, 50);\n      return finalHeader;\n    }\n  }\n}","(function(a,b){if(\"function\"==typeof define&&define.amd)define([],b);else if(\"undefined\"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof global&&global.global===global?global:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,\"undefined\"!=typeof module&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map","// @ts-ignore\nimport { changeDpiBlob } from 'changedpi';\nimport { isArray } from '@amandaghassaei/type-checks';\nimport { GPULayer } from './GPULayer';\nimport './GPULayerHelpers';\nimport {\n\tGPULayerType,\n\tFLOAT,\n\tINT,\n\tGLSLVersion,\n\tGLSL1,\n\tGLSL3,\n\tWEBGL2,\n\tWEBGL1,\n\tEXPERIMENTAL_WEBGL,\n\tPROGRAM_NAME_INTERNAL,\n\tCompileTimeConstants,\n\tDEFAULT_PROGRAM_NAME,\n\tSEGMENT_PROGRAM_NAME,\n\tLAYER_POINTS_PROGRAM_NAME,\n\tLAYER_VECTOR_FIELD_PROGRAM_NAME,\n\tLAYER_LINES_PROGRAM_NAME,\n\tErrorCallback,\n\tDEFAULT_CIRCLE_NUM_SEGMENTS,\n\tUINT,\n\tGLSLPrecision,\n\tPRECISION_HIGH_P,\n\tDEFAULT_ERROR_CALLBACK,\n\tGPULayerState,\n\tGPUIO_VS_POSITION_W_ACCUM,\n\tGPUIO_VS_WRAP_X,\n\tGPUIO_VS_WRAP_Y,\n\tMAX_FLOAT_INT,\n\tEXPERIMENTAL_WEBGL2,\n\tBoundaryEdge,\n\tBOUNDARY_LEFT,\n\tBOUNDARY_RIGHT,\n\tBOUNDARY_TOP,\n\tBOUNDARY_BOTTOM,\n} from './constants';\nimport { GPUProgram } from './GPUProgram';\n// Just importing the types here.\n// Only @types/three is installed as dev dependency.\nimport type {\n\tWebGLRenderer,\n\tVector4,\n} from 'three';\nimport * as ThreejsUtils from './Vector4';\nimport {\n\tisWebGL2,\n\tinitSequentialFloatArray,\n\tpreprocessVertexShader,\n\tcompileShader,\n\tindexOfLayerInArray,\n} from './utils';\nimport { DEFAULT_VERT_SHADER_SOURCE } from './glsl/vertex/DefaultVertexShader';\nimport { LAYER_LINES_VERTEX_SHADER_SOURCE } from './glsl/vertex/LayerLinesVertexShader';\nimport { SEGMENT_VERTEX_SHADER_SOURCE } from './glsl/vertex/SegmentVertexShader';\nimport { LAYER_POINTS_VERTEX_SHADER_SOURCE } from './glsl/vertex/LayerPointsVertexShader';\nimport { LAYER_VECTOR_FIELD_VERTEX_SHADER_SOURCE } from './glsl/vertex/LayerVectorFieldVertexShader';\nimport { uniformTypeForType } from './conversions';\nimport {\n\tcopyProgram,\n\tsetValueProgram,\n} from './Programs';\nimport { checkRequiredKeys, checkValidKeys } from './checks';\nimport { bindFrameBuffer } from './framebuffers';\n\nexport class GPUComposer {\n\t/**\n\t * The WebGL context associated with this GPUcomposer.\n\t */\n\treadonly gl!: WebGLRenderingContext | WebGL2RenderingContext;\n\t/**\n\t * The GLSL version being used by the GPUComposer.\n\t */\n\treadonly glslVersion!: GLSLVersion;\n\t/**\n\t * Flag for WebGL version.\n\t */\n\treadonly isWebGL2!: boolean;\n\t/**\n\t * The global integer precision to apply to shader programs.\n\t */\n\treadonly intPrecision!: GLSLPrecision;\n\t/**\n\t * The global float precision to apply to shader programs.\n\t */\n\treadonly floatPrecision!: GLSLPrecision;\n\t/**\n\t * Store the width and height of the current canvas at full res.\n\t */\n\tprivate _width!: number;\n\tprivate _height!: number;\n\n\t/**\n\t * @private\n\t */\n\treadonly _errorCallback: ErrorCallback;\n\tprivate _errorState = false;\n\n\t// Save threejs renderer if passed in.\n\t/**\n\t * @private\n\t */\n\treadonly _renderer?: WebGLRenderer;\n\t\n\t/**\n\t * Precomputed vertex buffers (inited as needed).\n\t */\n\tprivate _quadPositionsBuffer?: WebGLBuffer;\n\tprivate _boundaryPositionsBuffer?: WebGLBuffer;\n\t// Cache multiple circle positions buffers for various num segments, use numSegments as key.\n\tprivate _circlePositionsBuffer: { [key: number]: WebGLBuffer } = {};\n\tprivate _pointIndexArray?: Float32Array;\n\tprivate _pointIndexBuffer?: WebGLBuffer;\n\tprivate _vectorFieldIndexArray?: Float32Array;\n\tprivate _vectorFieldIndexBuffer?: WebGLBuffer;\n\tprivate _indexedLinesIndexBuffer?: WebGLBuffer;\n\t/**\n\t * Cache vertex shader attribute locations.\n\t */\n\tprivate _vertexAttributeLocations: {[key: string]: WeakMap<WebGLProgram, number>} = {};\n\n\t// Keep track of all GL extensions that have been loaded.\n\t/**\n\t * @private\n\t */\n\treadonly _extensions: { [key: string]: any } = {};\n\n\t/**\n\t * Cache some generic programs for copying data.\n\t * These are needed for rendering partial screen geometries.\n\t */\n\tprivate readonly _copyPrograms: {\n\t\t[FLOAT]?: GPUProgram,\n\t\t[INT]?: GPUProgram,\n\t\t[UINT]?: GPUProgram,\n\t} = {};\n\n\t// Other util programs.\n\t/**\n\t * Cache some generic programs for setting value from uniform.\n\t * These are used by GPULayer.clear(), among other things\n\t */\n\tprivate readonly _setValuePrograms: {\n\t\t[FLOAT]?: GPUProgram,\n\t\t[INT]?: GPUProgram,\n\t\t[UINT]?: GPUProgram,\n\t} = {};\n\tprivate _wrappedLineColorProgram?: GPUProgram; // We only need a FLOAT version of this.\n\n\t/**\n\t * Vertex shaders are shared across all GPUProgram instances.\n\t * @private\n\t */\n\treadonly _vertexShaders: {[key in PROGRAM_NAME_INTERNAL]: {\n\t\tsrc: string,\n\t\tcompiledShaders: { [key: string]: WebGLShader },\n\t}} = {\n\t\t[DEFAULT_PROGRAM_NAME]: {\n\t\t\tsrc: DEFAULT_VERT_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[SEGMENT_PROGRAM_NAME]: {\n\t\t\tsrc: SEGMENT_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[LAYER_POINTS_PROGRAM_NAME]: {\n\t\t\tsrc: LAYER_POINTS_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[LAYER_VECTOR_FIELD_PROGRAM_NAME]: {\n\t\t\tsrc: LAYER_VECTOR_FIELD_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t\t[LAYER_LINES_PROGRAM_NAME]: {\n\t\t\tsrc: LAYER_LINES_VERTEX_SHADER_SOURCE,\n\t\t\tcompiledShaders: {},\n\t\t},\n\t};\n\n\t/**\n\t * Flag to set GPUcomposer for verbose logging, defaults to false.\n\t */\n\tverboseLogging = false;\n\n\t/**\n\t * Variables for tracking fps of GPUComposer with tick().\n\t */\n\tprivate _lastTickTime?: number;\n\tprivate _lastTickFPS?: number\n\tprivate _numTicks = 0;\n\n\t/**\n\t * Create a GPUComposer from an existing THREE.WebGLRenderer that shares a single WebGL context.\n\t * @param renderer - Threejs WebGLRenderer.\n\t * @param params - GPUComposer parameters.\n\t * @param params.intPrecision - Set the global integer precision in shader programs.\n\t * @param params.floatPrecision - Set the global float precision in shader programs.\n\t * @param params.verboseLogging - Set the verbosity of GPUComposer logging (defaults to false).\n\t * @param params.errorCallback - Custom error handler, defaults to throwing an Error with message.\n\t * @returns \n\t */\n\t static initWithThreeRenderer(\n\t\trenderer: WebGLRenderer,\n\t\tparams?: {\n\t\t\tintPrecision?: GLSLPrecision,\n\t\t\tfloatPrecision?: GLSLPrecision,\n\t\t\tverboseLogging?: boolean,\n\t\t\terrorCallback?: ErrorCallback,\n\t\t},\n\t) {\n\t\tconst composer = new GPUComposer(\n\t\t\t{\n\t\t\t\tfloatPrecision: renderer.capabilities.precision as GLSLPrecision,\n\t\t\t\tintPrecision: renderer.capabilities.precision as GLSLPrecision,\n\t\t\t\t...params,\n\t\t\t\tcanvas: renderer.domElement,\n\t\t\t\tcontext: renderer.getContext(),\n\t\t\t\tglslVersion: renderer.capabilities.isWebGL2 ? GLSL3 : GLSL1,\n\t\t\t},\n\t\t);\n\t\t// Attach renderer.\n\t\t// @ts-ignore\n\t\tcomposer.renderer = renderer;\n\t\treturn composer;\n\t}\n\n\t/**\n     * Create a GPUComposer.\n     * @param params - GPUComposer parameters.\n\t * @param params.canvas - HTMLCanvasElement associated with this GPUComposer (you must add to DOM yourself).\n\t * @param params.context - Pass in a WebGL context for the GPUcomposer to user.\n\t * @param params.contextID - Set the contextID to use when initing a new WebGL context.\n\t * @param params.contextAttributes - Options to pass to WebGL context on initialization (see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext for more information).\n\t * @param params.glslVersion - Set the GLSL version to use, defaults to GLSL3 for WebGL2 contexts.\n\t * @param params.intPrecision - Set the global integer precision in shader programs.\n\t * @param params.floatPrecision - Set the global float precision in shader programs.\n\t * @param params.verboseLogging - Set the verbosity of GPUComposer logging (defaults to false).\n\t * @param params.errorCallback - Custom error handler, defaults to throwing an Error with message.\n     */\n\tconstructor(\n\t\tparams: {\n\t\t\tcanvas: HTMLCanvasElement,\n\t\t\tcontext?: WebGLRenderingContext | WebGL2RenderingContext,\n\t\t\tcontextID?: typeof WEBGL2 | typeof WEBGL1 | typeof EXPERIMENTAL_WEBGL | typeof EXPERIMENTAL_WEBGL2 | string,\n\t\t\tcontextAttributes?: {\n\t\t\t\t[key: string]: any,\n\t\t\t},\n\t\t\tglslVersion?: GLSLVersion,\n\t\t\tintPrecision?: GLSLPrecision,\n\t\t\tfloatPrecision?: GLSLPrecision,\n\t\t\tverboseLogging?: boolean,\n\t\t\t// Optionally pass in an error callback in case we want to handle errors related to webgl support.\n\t\t\t// e.g. throw up a modal telling user this will not work on their device.\n\t\t\terrorCallback?: ErrorCallback,\n\t\t},\n\t) {\n\t\t// Check params.\n\t\tconst validKeys = ['canvas', 'context', 'contextID', 'contextAttributes', 'glslVersion', 'verboseLogging', 'errorCallback'];\n\t\tconst requiredKeys = ['canvas'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUComposer(params)');\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUComposer(params)');\n\n\t\tif (params.verboseLogging !== undefined) this.verboseLogging = params.verboseLogging;\n\n\t\t// Save callback in case we run into an error.\n\t\tconst self = this;\n\t\tthis._errorCallback = (message: string) => {\n\t\t\tif (self._errorState) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself._errorState = true;\n\t\t\tparams.errorCallback ? params.errorCallback(message) : DEFAULT_ERROR_CALLBACK(message);\n\t\t}\n\n\t\tconst { canvas } = params;\n\t\tlet gl = params.context;\n\n\t\t// Init GL.\n\t\tif (!gl) {\n\t\t\t// Init a gl context if not passed in.\n\t\t\tif (params.contextID) {\n\t\t\t\tconst _gl = canvas.getContext(params.contextID, params.contextAttributes) as WebGLRenderingContext | null;\n\t\t\t\tif (!_gl) {\n\t\t\t\t\tconsole.warn(`Unable to initialize WebGL context with contextID: ${params.contextID}.`);\n\t\t\t\t} else {\n\t\t\t\t\tgl = _gl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!gl) {\n\t\t\t\tconst _gl = canvas.getContext(WEBGL2, params.contextAttributes)  as WebGL2RenderingContext | null\n\t\t\t\t\t|| canvas.getContext(WEBGL1, params.contextAttributes)  as WebGLRenderingContext | null\n\t\t\t\t\t|| canvas.getContext(EXPERIMENTAL_WEBGL2, params.contextAttributes)  as WebGLRenderingContext | null\n\t\t\t\t\t|| canvas.getContext(EXPERIMENTAL_WEBGL, params.contextAttributes)  as WebGLRenderingContext | null;\n\t\t\t\tif (_gl) {\n\t\t\t\t\tgl = _gl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!gl) {\n\t\t\t\tthis._errorCallback('Unable to initialize WebGL context.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.isWebGL2 = isWebGL2(gl);\n\t\tif (this.isWebGL2) {\n\t\t\tif (this.verboseLogging) console.log('Using WebGL 2.0 context.');\n\t\t} else {\n\t\t\tif (this.verboseLogging) console.log('Using WebGL 1.0 context.');\n\t\t}\n\t\tthis.gl = gl;\n\n\t\t// Save glsl version, default to 3 if using webgl2 context.\n\t\tlet glslVersion = params.glslVersion || (this.isWebGL2 ? GLSL3 : GLSL1);\n\t\tif (!this.isWebGL2 && glslVersion === GLSL3) {\n\t\t\tconsole.warn('GLSL3.x is incompatible with WebGL1.0 contexts, falling back to GLSL1.');\n\t\t\tglslVersion = GLSL1; // Fall back to GLSL1 in these cases.\n\t\t}\n\t\tthis.glslVersion = glslVersion;\n\n\t\t// Set default int/float precision.\n\t\tthis.intPrecision = params.intPrecision || PRECISION_HIGH_P;\n\t\tthis.floatPrecision = params.floatPrecision || PRECISION_HIGH_P;\n\n\t\t// GL setup.\n\t\t// Disable depth testing globally.\n\t\tgl.disable(gl.DEPTH_TEST);\n\t\t// Set unpack alignment to 1 so we can have textures of arbitrary dimensions.\n\t\t// https://stackoverflow.com/questions/51582282/error-when-creating-textures-in-webgl-with-the-rgb-format\n\t\tgl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n\t\t// Unbind active buffer.\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n\t\t// Canvas setup.\n\t\tthis.resize([canvas.clientWidth, canvas.clientHeight]);\n\n\t\tif (this.verboseLogging) {\n\t\t\t// Log number of textures available.\n\t\t\tconsole.log(`${this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS)} textures max.`);\n\t\t}\n\t}\n\n\tget canvas() {\n\t\treturn this.gl.canvas;\n\t}\n\n\t/**\n\t * Gets (and caches) generic set value programs for several input types.\n\t * Used for GPULayer.clear(), among other things.\n\t * @private\n\t */\n\t_setValueProgramForType(type: GPULayerType) {\n\t\tconst { _setValuePrograms } = this;\n\t\tconst key = uniformTypeForType(type, this.glslVersion);\n\t\tif (_setValuePrograms[key] === undefined) {\n\t\t\t_setValuePrograms[key] = setValueProgram(this, { type, value: [0, 0, 0, 0] });\n\t\t}\n\t\treturn _setValuePrograms[key]!;\n\t}\n\t/**\n\t * Gets (and caches) generic copy programs for several input types.\n\t * Used for partial rendering to output, among other things.\n\t * @private\n\t */\n\tprivate _copyProgramForType(type: GPULayerType) {\n\t\tconst { _copyPrograms } = this;\n\t\tconst key = uniformTypeForType(type, this.glslVersion);\n\t\tif (_copyPrograms[key] === undefined) {\n\t\t\t_copyPrograms[key] = copyProgram(this, { type });\n\t\t}\n\t\treturn _copyPrograms[key]!;\n\t}\n\t// /**\n\t//  * Gets (and caches) a generic color program for wrapped line segment rendering.\n\t//  * @private\n\t//  */\n\t// private _getWrappedLineColorProgram() {\n\t// \tif (this._wrappedLineColorProgram === undefined) {\n\t// \t\tthis._wrappedLineColorProgram = wrappedLineColorProgram({ composer: this });\n\t// \t}\n\t// \treturn this._wrappedLineColorProgram;\n\t// }\n\n\t/**\n\t * Init a buffer for vertex shader attributes.\n\t * @private\n\t */\n\tprivate _initVertexBuffer(\n\t\tdata: Float32Array,\n\t) {\n\t\tconst { _errorCallback, gl } = this;\n\t\tconst buffer = gl.createBuffer();\n\t\tif (!buffer) {\n\t\t\t_errorCallback('Unable to allocate gl buffer.');\n\t\t\treturn;\n\t\t}\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t// Add buffer data.\n\t\tgl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\t\treturn buffer;\n\t}\n\t/**\n\t * Get (and cache) positions buffer for rendering full screen quads.\n\t * @private\n\t */\n\t_getQuadPositionsBuffer() {\n\t\tif (this._quadPositionsBuffer === undefined) {\n\t\t\tconst fsQuadPositions = new Float32Array([ -1, -1, 1, -1, -1, 1, 1, 1 ]);\n\t\t\tthis._quadPositionsBuffer = this._initVertexBuffer(fsQuadPositions)!;\n\t\t}\n\t\treturn this._quadPositionsBuffer!;\n\t}\n\t/**\n\t * Get (and cache) positions buffer for rendering lines on boundary.\n\t * @private\n\t */\n\tprivate _getBoundaryPositionsBuffer() {\n\t\tif (this._boundaryPositionsBuffer === undefined) {\n\t\t\tconst boundaryPositions = new Float32Array([ -1, -1, 1, -1, 1, 1, -1, 1, -1, -1 ]);\n\t\t\tthis._boundaryPositionsBuffer = this._initVertexBuffer(boundaryPositions)!;\n\t\t}\n\t\treturn this._boundaryPositionsBuffer!;\n\t}\n\t/**\n\t * Get (and cache) positions buffer for rendering circle with various numbers of segments.\n\t * @private\n\t */\n\tprivate _getCirclePositionsBuffer(numSegments: number) {\n\t\tconst { _circlePositionsBuffer } = this;\n\t\tif (_circlePositionsBuffer[numSegments] == undefined) {\n\t\t\tconst unitCirclePoints = [0, 0];\n\t\t\tfor (let i = 0; i < numSegments; i++) {\n\t\t\t\tunitCirclePoints.push(\n\t\t\t\t\tMath.cos(2 * Math.PI * i / numSegments),\n\t\t\t\t\tMath.sin(2 * Math.PI * i / numSegments),\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Add one more point to close the loop on the triangle fan.\n\t\t\tunitCirclePoints.push(\n\t\t\t\tMath.cos(0),\n\t\t\t\tMath.sin(0),\n\t\t\t);\n\t\t\tconst circlePositions = new Float32Array(unitCirclePoints);\n\t\t\tconst buffer = this._initVertexBuffer(circlePositions)!;\n\t\t\t_circlePositionsBuffer[numSegments] = buffer;\n\t\t}\n\t\treturn _circlePositionsBuffer[numSegments];\n\t}\n\n\t/**\n\t * Used internally, see GPULayer.clone() for public API.\n\t * @private\n\t */\n\t_cloneGPULayer(gpuLayer: GPULayer, name?: string) {\n\t\tconst dimensions = gpuLayer.is1D() ? gpuLayer.length : [gpuLayer.width, gpuLayer.height];\n\n\t\tconst clone = new GPULayer(this, {\n\t\t\tname: name || `${gpuLayer.name}-clone`,\n\t\t\tdimensions,\n\t\t\ttype: gpuLayer.type,\n\t\t\tnumComponents: gpuLayer.numComponents,\n\t\t\tfilter: gpuLayer.filter,\n\t\t\twrapX: gpuLayer.wrapX,\n\t\t\twrapY: gpuLayer.wrapY,\n\t\t\tnumBuffers: gpuLayer.numBuffers,\n\t\t\tclearValue: gpuLayer.clearValue,\n\t\t});\n\n\t\t// Copy current state with several draw calls.\n\t\tconst copyProgram = this._copyProgramForType(gpuLayer.type);\n\t\t// Set bufferIndex = gpuLayer.numBuffers - 1.\n\t\tfor (let i = 0; i < gpuLayer.numBuffers - 1; i++ ){\n\t\t\tclone.incrementBufferIndex();\n\t\t}\n\t\tfor (let i = 0; i < gpuLayer.numBuffers; i++) {\n\t\t\tthis.step({\n\t\t\t\tprogram: copyProgram,\n\t\t\t\tinput: gpuLayer.getStateAtIndex(i),\n\t\t\t\toutput: clone,\n\t\t\t});\n\t\t}\n\t\t// Increment clone's buffer index until it is identical to the original layer.\n\t\tfor (let i = -1; i < gpuLayer.bufferIndex; i++ ){\n\t\t\tclone.incrementBufferIndex();\n\t\t}\n\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Gets (and caches) vertex shaders based on shader source code and compile time constants.\n\t * Tries to minimize the number of new vertex shaders that must be compiled.\n\t * @private\n\t */\n\t _getVertexShader(\n\t\tname: PROGRAM_NAME_INTERNAL,\n\t\tvertexID: string,\n\t\tvertexCompileConstants: CompileTimeConstants,\n\t\tprogramName: string,\n\t) {\n\t\tconst {\n\t\t\t_errorCallback,\n\t\t\t_vertexShaders,\n\t\t\tgl,\n\t\t\tglslVersion,\n\t\t\tintPrecision,\n\t\t\tfloatPrecision,\n\t\t} = this;\n\t\tconst { compiledShaders, src } = _vertexShaders[name];\n\t\tif (vertexID === '') vertexID = '_default';\n\t\tif (compiledShaders[vertexID] === undefined) {\n\t\t\t// Compile a vertex shader (this only happens once for each possible vertex shader across all GPUPrograms).\n\t\t\tif (src === '') {\n\t\t\t\tthrow new Error(`Error compiling GPUProgram \"${programName}\": no source for vertex shader with name \"${name}\".`);\n\t\t\t}\n\t\t\tconst preprocessedSrc = preprocessVertexShader(src, glslVersion);\n\t\t\tconst shader = compileShader(\n\t\t\t\tgl,\n\t\t\t\tglslVersion,\n\t\t\t\tintPrecision,\n\t\t\t\tfloatPrecision,\n\t\t\t\tpreprocessedSrc,\n\t\t\t\tgl.VERTEX_SHADER,\n\t\t\t\tprogramName,\n\t\t\t\t_errorCallback,\n\t\t\t\tvertexCompileConstants,\n\t\t\t\ttrue,\n\t\t\t);\n\t\t\tif (!shader) {\n\t\t\t\t_errorCallback(`Unable to compile \"${name}${vertexID}\" vertex shader for GPUProgram \"${programName}\".`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Save the results so this does not have to be repeated.\n\t\t\tcompiledShaders[vertexID] = shader;\n\t\t}\n\t\treturn compiledShaders[vertexID];\n\t}\n\n\t/**\n\t * Notify the GPUComposer that the canvas should change size.\n\t * @param dimensions - The new [width, height] to resize to.\n\t */\n\tresize(dimensions: [number, number]) {\n\t\tconst { canvas } = this;\n\t\tconst [width, height] = dimensions;\n\t\t// Set correct canvas pixel size.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/By_example/Canvas_size_and_WebGL\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\t// Save dimensions.\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t};\n\n\t/**\n\t * Set inputs and outputs in preparation for draw call.\n\t * @private\n\t */\n\tprivate _drawSetup(\n\t\tgpuProgram: GPUProgram,\n\t\tprogramName: PROGRAM_NAME_INTERNAL,\n\t\tvertexCompileConstants: CompileTimeConstants,\n\t\tfullscreenRender: boolean,\n\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\toutput?: GPULayer | GPULayer[],\n\t) {\n\t\tconst { gl } = this;\n\n\t\t// CAUTION: the order of these next few lines is important.\n\n\t\t// Get a shallow copy of current textures.\n\t\t// This line must come before this._setOutputLayer() as it depends on current internal state.\n\t\tconst inputTextures: GPULayerState[] = [];\n\t\tif (input) {\n\t\t\tif ((input as GPULayerState).layer) {\n\t\t\t\tinputTextures.push(input as GPULayerState);\n\t\t\t} else if (input.constructor === GPULayer) {\n\t\t\t\tinputTextures.push((input as GPULayer).currentState);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < (input as (GPULayer | GPULayerState)[]).length; i++) {\n\t\t\t\t\tconst layer = (input as (GPULayer | GPULayerState)[])[i];\n\t\t\t\t\tinputTextures.push((layer as GPULayer).currentState ? (layer as GPULayer).currentState : layer as GPULayerState);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst program = gpuProgram._getProgramWithName(programName, vertexCompileConstants, inputTextures)!;\n\n\t\t// Set output framebuffer.\n\t\t// This may modify WebGL internal state.\n\t\tthis._setOutputLayer(gpuProgram.name, fullscreenRender, input, output);\n\n\t\t// Set current program.\n\t\t// Must do this before calling gpuProgram._setInternalFragmentUniforms(program, inputTextures);\n\t\tgl.useProgram(program);\n\n\t\t// Set input textures.\n\t\tfor (let i = 0; i < inputTextures.length; i++) {\n\t\t\tgl.activeTexture(gl.TEXTURE0 + i);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, inputTextures[i].texture);\n\t\t}\n\t\tgpuProgram._setInternalFragmentUniforms(program, inputTextures);\n\t\treturn program;\n\t}\n\t/**\n\t * Set blend mode for draw call.\n\t * @private\n\t */\n\tprivate _setBlendMode(blendAlpha?: boolean) {\n\t\tconst { gl } = this;\n\t\tif (blendAlpha) {\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\t}\n\t}\n\t/**\n\t * Add GPULayer to inputs if needed.\n\t * @private\n\t */\n\tprivate _addLayerToInputs(\n\t\tlayer: GPULayer,\n\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t) {\n\t\t// Add layer to end of input if needed.\n\t\t// Do this with no mutations.\n\t\tif (input === undefined) {\n\t\t\treturn [layer];\n\t\t}\n\t\tif (isArray(input)) {\n\t\t\t// Return input with layer added if needed.\n\t\t\tif (indexOfLayerInArray(layer, (input as (GPULayer | GPULayerState)[])) >= 0) {\n\t\t\t\treturn input  as (GPULayer | GPULayerState)[];\n\t\t\t}\n\t\t\treturn [...(input as (GPULayer | GPULayerState)[]), layer];\n\t\t}\n\t\tif (input === layer || (input as GPULayerState).layer === layer) {\n\t\t\treturn [input as GPULayerState];\n\t\t}\n\t\treturn [(input as GPULayer | GPULayerState), layer];\n\t}\n\t/**\n\t * Copy data from input to output.\n\t * This is used when rendering to part of output state (not fullscreen quad).\n\t * @private\n\t */\n\tprivate _passThroughLayerDataFromInputToOutput(state: GPULayer) {\n\t\t// TODO: figure out the fastest way to copy a texture.\n\t\tconst copyProgram = this._copyProgramForType(state._internalType);\n\t\tthis.step({\n\t\t\tprogram: copyProgram,\n\t\t\tinput: state,\n\t\t\toutput: state,\n\t\t});\n\t}\n\t/**\n\t * Set output for draw command.\n\t * @private\n\t */\n\tprivate _setOutputLayer(\n\t\tprogramName: string,\n\t\tfullscreenRender: boolean,\n\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t) {\n\t\tconst { gl, isWebGL2 } = this;\n\n\t\t// Render to screen.\n\t\tif (!output) {\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t\t\t// Resize viewport.\n\t\t\tconst { _width, _height } = this;\n\t\t\tgl.viewport(0, 0, _width, _height);\n\t\t\treturn;\n\t\t}\n\n\t\tconst outputArray = (isArray(output) ? output : [output]) as GPULayer[];\n\n\t\tfor (let i = 0, numOutputs = outputArray.length; i < numOutputs; i++) {\n\t\t\tconst outputLayer = outputArray[i];\n\t\t\t// Check if output is same as one of input layers.\n\t\t\tif (input && ((input === output || (input as GPULayerState).layer === output) ||\n\t\t\t\t(isArray(input) && indexOfLayerInArray(outputLayer, input as (GPULayer | GPULayerState)[]) >= 0))) {\n\t\t\t\tif (outputLayer.numBuffers === 1) {\n\t\t\t\t\tthrow new Error('Cannot use same buffer for input and output of a program. Try increasing the number of buffers in your output layer to at least 2 so you can render to nextState using currentState as an input.');\n\t\t\t\t}\n\t\t\t\tif (fullscreenRender) {\n\t\t\t\t\t// Render and increment buffer.\n\t\t\t\t\toutputLayer._prepareForWrite(true);\n\t\t\t\t} else {\n\t\t\t\t\t// Pass input texture through to output.\n\t\t\t\t\tthis._passThroughLayerDataFromInputToOutput(outputLayer);\n\t\t\t\t\t// Render to output without incrementing buffer.\n\t\t\t\t\toutputLayer._prepareForWrite(false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fullscreenRender) {\n\t\t\t\t\t// Render and increment buffer.\n\t\t\t\t\toutputLayer._prepareForWrite(true);\n\t\t\t\t} else {\n\t\t\t\t\t// If we are doing a sneaky thing with a swapped texture and are\n\t\t\t\t\t// only rendering part of the screen, we may need to add a copy operation.\n\t\t\t\t\tif (outputLayer._usingTextureOverrideForCurrentBuffer()) {\n\t\t\t\t\t\tthis._passThroughLayerDataFromInputToOutput(outputLayer);\n\t\t\t\t\t}\n\t\t\t\t\toutputLayer._prepareForWrite(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Bind framebuffer.\n\t\tconst layer0 = outputArray[0];\n\t\tlet additionalTextures: WebGLTexture[] | undefined = undefined;\n\t\tconst drawBuffers = [gl.COLOR_ATTACHMENT0];\n\t\tif (outputArray.length > 1) {\n\t\t\tadditionalTextures = [];\n\t\t\tfor (let i = 1, numOutputs = outputArray.length; i < numOutputs; i++) {\n\t\t\t\tadditionalTextures.push(outputArray[i]._currentTexture);\n\t\t\t\tdrawBuffers.push(gl.COLOR_ATTACHMENT0 + i);\n\t\t\t}\n\t\t}\n\t\tbindFrameBuffer(this, layer0, layer0._currentTexture, additionalTextures);\n\t\t// Tell WebGL to draw to output textures.\n\t\tif (isWebGL2) {\n\t\t\t(gl as WebGL2RenderingContext).drawBuffers(drawBuffers);\n\t\t}\n\t\t// Resize viewport.\n\t\tconst { width, height } = this._widthHeightForOutput(programName, output);\n\t\tgl.viewport(0, 0, width, height);\n\t};\n\t/**\n\t * Set vertex shader attribute.\n\t * @private\n\t */\n\tprivate _setVertexAttribute(program: WebGLProgram, name: string, size: number, programName: string) {\n\t\tconst { gl, _vertexAttributeLocations } = this;\n\t\t// Point attribute to the currently bound VBO.\n\t\tlet locations = _vertexAttributeLocations[name];\n\t\tlet location;\n\t\tif (!locations) {\n\t\t\tlocations = new WeakMap<WebGLProgram, number>();\n\t\t\t_vertexAttributeLocations[name] = locations;\n\t\t} else {\n\t\t\tlocation = locations.get(program);\n\t\t}\n\t\tif (location === undefined) {\n\t\t\tlocation = gl.getAttribLocation(program, name);\n\t\t\tif (location < 0) {\n\t\t\t\tthrow new Error(`Unable to find vertex attribute \"${name}\" in program \"${programName}\".`);\n\t\t\t}\n\t\t\t// Cache attribute location.\n\t\t\tlocations.set(program, location);\n\t\t}\n\n\t\t// INT types not supported for attributes.\n\t\t// Use FLOAT rather than SHORT bc FLOAT covers more INT range.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\t\tgl.vertexAttribPointer(location, size, gl.FLOAT, false, 0, 0);\n\t\t// Enable the attribute.\n\t\tgl.enableVertexAttribArray(location);\n\t}\n\t/**\n\t * Set vertex shader position attribute.\n\t * @private\n\t */\n\t_setPositionAttribute(program: WebGLProgram, programName: string) {\n\t\tthis._setVertexAttribute(program, 'a_gpuio_position', 2, programName);\n\t}\n\t/**\n\t * Set vertex shader index attribute.\n\t * @private\n\t */\n\tprivate _setIndexAttribute(program: WebGLProgram, programName: string) {\n\t\tthis._setVertexAttribute(program, 'a_gpuio_index', 1, programName);\n\t}\n\t/**\n\t * Set vertex shader uv attribute.\n\t * @private\n\t */\n\tprivate _setUVAttribute(program: WebGLProgram, programName: string) {\n\t\tthis._setVertexAttribute(program, 'a_gpuio_uv', 2, programName);\n\t}\n\n\tprivate _widthHeightForOutput(programName: string, output?: GPULayer | GPULayer[]) {\n\t\tif (isArray(output)) {\n\t\t\t// Check that all outputs have the same size.\n\t\t\tconst firstOutput = (output as GPULayer[])[0];\n\t\t\tconst width = firstOutput ? firstOutput.width : this._width;\n\t\t\tconst height = firstOutput ? firstOutput.height : this._height;\n\t\t\tfor (let i = 1, numOutputs = (output as GPULayer[]).length; i < numOutputs; i++) {\n\t\t\t\tconst nextOutput = (output as GPULayer[])[i];\n\t\t\t\tif (nextOutput.width !== width || nextOutput.height !== height) {\n\t\t\t\t\tthrow new Error(`Output GPULayers must have the same dimensions, got dimensions [${width}, ${height}] and [${nextOutput.width}, ${nextOutput.height}] for program \"${programName}\".`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { width, height };\n\t\t}\n\t\tconst width = output ? (output as GPULayer).width : this._width;\n\t\tconst height = output ? (output as GPULayer).height : this._height;\n\t\treturn { width, height};\n\t}\n\n\t/**\n\t * Call stepping/drawing function once for each output.\n\t * This is required when attempting to draw to multiple outputs using GLSL1.\n\t */\n\tprivate _iterateOverOutputsIfNeeded(params: any, methodName: string) {\n\t\tif (params.output && isArray(params.output) && this.glslVersion === GLSL1) {\n\t\t\tfor (let i = 0, numOutputs = (params.output as GPULayer[]).length; i < numOutputs; i++) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis[methodName]({\n\t\t\t\t\t...params,\n\t\t\t\t\tprogram: i === 0 ? params.program : params.program._childPrograms![i - 1],\n\t\t\t\t\toutput: (params.output as GPULayer[])[i],\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Step GPUProgram entire fullscreen quad.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstep(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'step')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, {}, true, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1, 1], FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [0, 0], FLOAT);\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getQuadPositionsBuffer());\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t\tgl.disable(gl.BLEND);\n\t}\n\n\t/**\n\t * Step GPUProgram only for a 1px strip of pixels along the boundary.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.edges - Specify which edges to step, defaults to stepping entire boundary.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstepBoundary(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t\t\tedges?: BoundaryEdge | BoundaryEdge[];\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepBoundary')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\tconst { width, height } = this._widthHeightForOutput(program.name, output);\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\t// Frame needs to be offset and scaled so that all four sides are in viewport.\n\t\tconst onePx = [ 1 / width, 1 / height];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 - onePx[0], 1 - onePx[1]], FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', onePx, FLOAT);\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getBoundaryPositionsBuffer());\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tif (params.edges) {\n\t\t\tlet { edges } = params;\n\t\t\tif (!isArray(edges)) edges = [edges as BoundaryEdge];\n\t\t\tfor (let i = 0, numEdges = edges.length; i < numEdges; i++) {\n\t\t\t\t// TODO: do this in one draw call.\n\t\t\t\tconst edge = edges[i];\n\t\t\t\tif (edge === BOUNDARY_LEFT) {\n\t\t\t\t\tgl.drawArrays(gl.LINES, 3, 2);\n\t\t\t\t}\n\t\t\t\tif (edge === BOUNDARY_RIGHT) {\n\t\t\t\t\tgl.drawArrays(gl.LINES, 1, 2);\n\t\t\t\t}\n\t\t\t\tif (edge === BOUNDARY_TOP) {\n\t\t\t\t\tgl.drawArrays(gl.LINES, 2, 2);\n\t\t\t\t}\n\t\t\t\tif (edge === BOUNDARY_BOTTOM) {\n\t\t\t\t\tgl.drawArrays(gl.LINES, 0, 2);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgl.drawArrays(gl.LINE_LOOP, 0, 4);\n\t\t}\n\t\tgl.disable(gl.BLEND);\n\t}\n\n\t/**\n\t * Step GPUProgram for all but a 1px strip of pixels along the boundary.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstepNonBoundary(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepNonBoundary')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\tconst { width, height } = this._widthHeightForOutput(program.name, output);\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tconst onePx = [ 1 / width, 1 / height];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 - 2 * onePx[0], 1 - 2 * onePx[1]], FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', onePx, FLOAT);\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getQuadPositionsBuffer());\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\t\t\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t\tgl.disable(gl.BLEND);\n\t}\n\n\t/**\n\t * Step GPUProgram inside a circular spot.  This is useful for touch interactions.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.position - Position of center of circle.\n\t * @param params.diameter - Circle diameter in pixels.\n\t * @param params.useOutputScale - If true position and diameter are scaled relative to the output dimensions, else they are scaled relative to the current canvas size, defaults to false.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.numSegments - Number of segments in circle, defaults to 18.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstepCircle(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tposition: number[], // Position is in units of pixels.\n\t\t\tdiameter: number, // Diameter is in units of pixels.\n\t\t\tuseOutputScale?: boolean,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t\t\tnumSegments?: number,\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepCircle')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, position, diameter, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\tlet width = this._width;\n\t\tlet height = this._height;\n\t\tif (params.useOutputScale) {\n\t\t\t({ width, height } = this._widthHeightForOutput(program.name, output));\n\t\t}\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [diameter / width, diameter / height], FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [2 * position[0] / width - 1, 2 * position[1] / height - 1], FLOAT);\n\t\tconst numSegments = params.numSegments ? params.numSegments : DEFAULT_CIRCLE_NUM_SEGMENTS;\n\t\tif (numSegments < 3) {\n\t\t\tthrow new Error(`numSegments for GPUComposer.stepCircle must be greater than 2, got ${numSegments}.`);\n\t\t}\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getCirclePositionsBuffer(numSegments));\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\t\t\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.TRIANGLE_FAN, 0, numSegments + 2);\t\n\t\tgl.disable(gl.BLEND);\n\t}\n\n\t/**\n\t * Step GPUProgram inside a line segment (rounded end caps available).\n\t * This is useful for touch interactions during pointermove.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.position1 - Position of one end of segment.\n\t * @param params.position2 - Position of the other end of segment.\n\t * @param params.thickness - Thickness in pixels.\n\t * @param params.useOutputScale - If true position and thickness are scaled relative to the output dimensions, else they are scaled relative to the current canvas size, defaults to false.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.endCaps - Flag to draw with rounded end caps, defaults to false.\n\t * @param params.numCapSegments - Number of segments in rounded end caps, defaults to 9, must be divisible by 3.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tstepSegment(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tposition1: number[], \n\t\t\tposition2: number[],\n\t\t\tthickness: number,\n\t\t\tuseOutputScale?: boolean,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tendCaps?: boolean,\n\t\t\tnumCapSegments?: number,\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepSegment')) return;\n\t\tconst { gl, _errorState } = this;\n\t\tconst { program, position1, position2, thickness, input, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\tlet width = this._width;\n\t\tlet height = this._height;\n\t\tif (params.useOutputScale) {\n\t\t\t({ width, height } = this._widthHeightForOutput(program.name, output));\n\t\t}\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, SEGMENT_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_halfThickness', thickness / 2, FLOAT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [2 / width, 2 / height], FLOAT);\n\t\tconst diffX = position1[0] - position2[0];\n\t\tconst diffY = position1[1] - position2[1];\n\t\tconst angle = Math.atan2(diffY, diffX);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_rotation', angle, FLOAT);\n\t\tconst centerX = (position1[0] + position2[0]) / 2;\n\t\tconst centerY = (position1[1] + position2[1]) / 2;\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [2 * centerX / width - 1, 2 * centerY / height - 1], FLOAT);\n\t\tconst length = Math.sqrt(diffX * diffX + diffY * diffY);\n\t\t\n\t\tconst numSegments = params.numCapSegments ? params.numCapSegments * 2 : DEFAULT_CIRCLE_NUM_SEGMENTS;\n\t\tif (params.endCaps) {\n\t\t\tif (numSegments < 6 || numSegments % 6 !== 0) {\n\t\t\t\tthrow new Error(`numCapSegments for GPUComposer.stepSegment must be divisible by 3, got ${numSegments / 2}.`);\n\t\t\t}\n\t\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_length', length, FLOAT);\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getCirclePositionsBuffer(numSegments));\n\t\t} else {\n\t\t\t// u_gpuio_length + thickness = length, bc we are stretching a square of size thickness into a rectangle.\n\t\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_length', length - thickness, FLOAT);\n\t\t\t// Use a rectangle in case of no caps.\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._getQuadPositionsBuffer());\n\t\t}\n\t\tthis._setPositionAttribute(glProgram, program.name);\n\t\t\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tif (params.endCaps) {\n\t\t\tgl.drawArrays(gl.TRIANGLE_FAN, 0, numSegments + 2);\n\t\t} else {\n\t\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t\t}\n\t\tgl.disable(gl.BLEND);\n\t}\n\n\t/**\n\t * Step GPUProgram inside a rectangle.\n\t * @param params - Step parameters.\n\t * @param params.program - GPUProgram to run.\n\t * @param params.position - Position of one top corner of rectangle.\n\t * @param params.size - Width and height of rectangle.\n\t * @param params.useOutputScale - If true position and size are scaled relative to the output dimensions, else they are scaled relative to the current canvas size, defaults to false.\n\t * @param params.input - Input GPULayers to GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\t stepRect(\n\t\tparams: {\n\t\t\tprogram: GPUProgram,\n\t\t\tposition: number[],\n\t\t\tsize: number[],\n\t\t\tuseOutputScale?: boolean,\n\t\t\tinput?:  (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'stepRect')) return;\n\t\tconst position1 = [params.position[0], params.position[1] + params.size[1] / 2];\n\t\tconst position2 = [params.position[0] + params.size[0], position1[1]];\n\t\tthis.stepSegment({\n\t\t\tprogram: params.program,\n\t\t\tposition1,\n\t\t\tposition2,\n\t\t\tthickness: params.size[1],\n\t\t\tuseOutputScale: params.useOutputScale,\n\t\t\tinput: params.input,\n\t\t\toutput: params.output,\n\t\t\tendCaps: false,\n\t\t\tblendAlpha: params.blendAlpha,\n\t\t});\n\t}\n\n\t// stepPolyline(\n\t// \tparams: {\n\t// \t\tprogram: GPUProgram,\n\t// \t\tpositions: number[][],\n\t// \t\tthickness: number, // Thickness of line is in units of pixels.\n\t// \t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t// \t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t// \t\tcloseLoop?: boolean,\n\t// \t\tincludeUVs?: boolean,\n\t// \t\tincludeNormals?: boolean,\n\t// \t\tblendAlpha?: boolean,\n\t// \t},\n\t// ) {\n\t// \tif (this._iterateOverOutputsIfNeeded(params, 'stepPolyline')) return;\n\t// \tconst { gl, _width, _height, _errorState } = this;\n\t// \tconst { program, input, output } = params;\n\n\t// \tif (_errorState) return;\n\n\t// \tconst vertices = params.positions;\n\t// \tconst closeLoop = !!params.closeLoop;\n\t\t\n\t// \t// Offset vertices.\n\t// \tconst halfThickness = params.thickness / 2;\n\t// \tconst numPositions = closeLoop ? vertices.length * 4 + 2 : (vertices.length - 1) * 4;\n\t// \tconst positions = new Float32Array(2 * numPositions);\n\t// \tconst uvs = params.includeUVs ? new Float32Array(2 * numPositions) : undefined;\n\t// \tconst normals = params.includeNormals ? new Float32Array(2 * numPositions) : undefined;\n\n\t// \t// tmp arrays.\n\t// \tconst s1 = [0, 0];\n\t// \tconst s2 = [0, 0];\n\t// \tconst n1 = [0, 0];\n\t// \tconst n2 = [0, 0];\n\t// \tconst n3 = [0, 0];\n\t// \tfor (let i = 0; i < vertices.length; i++) {\n\t// \t\tif (!closeLoop && i === vertices.length - 1) continue;\n\t// \t\t// Vertices on this segment.\n\t// \t\tconst v1 = vertices[i];\n\t// \t\tconst v2 = vertices[(i + 1) % vertices.length];\n\t// \t\ts1[0] = v2[0] - v1[0];\n\t// \t\ts1[1] = v2[1] - v1[1];\n\t// \t\tconst length1 = Math.sqrt(s1[0] * s1[0] + s1[1] * s1[1]);\n\t// \t\tn1[0] = s1[1] / length1;\n\t// \t\tn1[1] = - s1[0] / length1;\n\n\t// \t\tconst index = i * 4 + 2;\n\n\t// \t\tif (!closeLoop && i === 0) {\n\t// \t\t\t// Add starting points to positions array.\n\t// \t\t\tpositions[0] = v1[0] + n1[0] * halfThickness;\n\t// \t\t\tpositions[1] = v1[1] + n1[1] * halfThickness;\n\t// \t\t\tpositions[2] = v1[0] - n1[0] * halfThickness;\n\t// \t\t\tpositions[3] = v1[1] - n1[1] * halfThickness;\n\t// \t\t\tif (uvs) {\n\t// \t\t\t\tuvs[0] = 0;\n\t// \t\t\t\tuvs[1] = 1;\n\t// \t\t\t\tuvs[2] = 0;\n\t// \t\t\t\tuvs[3] = 0;\n\t// \t\t\t}\n\t// \t\t\tif (normals) {\n\t// \t\t\t\tnormals[0] = n1[0];\n\t// \t\t\t\tnormals[1] = n1[1];\n\t// \t\t\t\tnormals[2] = n1[0];\n\t// \t\t\t\tnormals[3] = n1[1];\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t\tconst u = (i + 1) / (vertices.length - 1);\n\n\t// \t\t// Offset from v2.\n\t// \t\tpositions[2 * index] = v2[0] + n1[0] * halfThickness;\n\t// \t\tpositions[2 * index + 1] = v2[1] + n1[1] * halfThickness;\n\t// \t\tpositions[2 * index + 2] = v2[0] - n1[0] * halfThickness;\n\t// \t\tpositions[2 * index + 3] = v2[1] - n1[1] * halfThickness;\n\t// \t\tif (uvs) {\n\t// \t\t\tuvs[2 * index] = u;\n\t// \t\t\tuvs[2 * index + 1] = 1;\n\t// \t\t\tuvs[2 * index + 2] = u;\n\t// \t\t\tuvs[2 * index + 3] = 0;\n\t// \t\t}\n\t// \t\tif (normals) {\n\t// \t\t\tnormals[2 * index] = n1[0];\n\t// \t\t\tnormals[2 * index + 1] = n1[1];\n\t// \t\t\tnormals[2 * index + 2] = n1[0];\n\t// \t\t\tnormals[2 * index + 3] = n1[1];\n\t// \t\t}\n\n\t// \t\tif ((i < vertices.length - 2) || closeLoop) {\n\t// \t\t\t// Vertices on next segment.\n\t// \t\t\tconst v3 = vertices[(i + 1) % vertices.length];\n\t// \t\t\tconst v4 = vertices[(i + 2) % vertices.length];\n\t// \t\t\ts2[0] = v4[0] - v3[0];\n\t// \t\t\ts2[1] = v4[1] - v3[1];\n\t// \t\t\tconst length2 = Math.sqrt(s2[0] * s2[0] + s2[1] * s2[1]);\n\t// \t\t\tn2[0] = s2[1] / length2;\n\t// \t\t\tn2[1] = - s2[0] / length2;\n\n\t// \t\t\t// Offset from v3\n\t// \t\t\tpositions[2 * ((index + 2) % (4 * vertices.length))] = v3[0] + n2[0] * halfThickness;\n\t// \t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 1] = v3[1] + n2[1] * halfThickness;\n\t// \t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 2] = v3[0] - n2[0] * halfThickness;\n\t// \t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 3] = v3[1] - n2[1] * halfThickness;\n\t// \t\t\tif (uvs) {\n\t// \t\t\t\tuvs[2 * ((index + 2) % (4 * vertices.length))] = u;\n\t// \t\t\t\tuvs[2 * ((index + 2) % (4 * vertices.length)) + 1] = 1;\n\t// \t\t\t\tuvs[2 * ((index + 2) % (4 * vertices.length)) + 2] = u;\n\t// \t\t\t\tuvs[2 * ((index + 2) % (4 * vertices.length)) + 3] = 0;\n\t// \t\t\t}\n\t// \t\t\tif (normals) {\n\t// \t\t\t\tnormals[2 * ((index + 2) % (4 * vertices.length))] = n2[0];\n\t// \t\t\t\tnormals[2 * ((index + 2) % (4 * vertices.length)) + 1] = n2[1];\n\t// \t\t\t\tnormals[2 * ((index + 2) % (4 * vertices.length)) + 2] = n2[0];\n\t// \t\t\t\tnormals[2 * ((index + 2) % (4 * vertices.length)) + 3] = n2[1];\n\t// \t\t\t}\n\n\t// \t\t\t// Check the angle between adjacent segments.\n\t// \t\t\tconst cross = n1[0] * n2[1] - n1[1] * n2[0];\n\t// \t\t\tif (Math.abs(cross) < 1e-6) continue;\n\t// \t\t\tn3[0] = n1[0] + n2[0];\n\t// \t\t\tn3[1] = n1[1] + n2[1];\n\t// \t\t\tconst length3 = Math.sqrt(n3[0] * n3[0] + n3[1] * n3[1]);\n\t// \t\t\tn3[0] /= length3;\n\t// \t\t\tn3[1] /= length3;\n\t// \t\t\t// Make adjustments to positions.\n\t// \t\t\tconst angle = Math.acos(n1[0] * n2[0] + n1[1] * n2[1]);\n\t// \t\t\tconst offset = halfThickness / Math.cos(angle / 2);\n\t// \t\t\tif (cross < 0) {\n\t// \t\t\t\tpositions[2 * index] = v2[0] + n3[0] * offset;\n\t// \t\t\t\tpositions[2 * index + 1] = v2[1] + n3[1] * offset;\n\t// \t\t\t\tpositions[2 * ((index + 2) % (4 * vertices.length))] = positions[2 * index];\n\t// \t\t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 1] = positions[2 * index + 1];\n\t// \t\t\t} else {\n\t// \t\t\t\tpositions[2 * index + 2] = v2[0] - n3[0] * offset;\n\t// \t\t\t\tpositions[2 * index + 3] = v2[1] - n3[1] * offset;\n\t// \t\t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 2] = positions[2 * index + 2];\n\t// \t\t\t\tpositions[2 * ((index + 2) % (4 * vertices.length)) + 3] = positions[2 * index + 3];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \tif (closeLoop) {\n\t// \t\t// Duplicate starting points to end of positions array.\n\t// \t\tpositions[vertices.length * 8] = positions[0];\n\t// \t\tpositions[vertices.length * 8 + 1] = positions[1];\n\t// \t\tpositions[vertices.length * 8 + 2] = positions[2];\n\t// \t\tpositions[vertices.length * 8 + 3] = positions[3];\n\t// \t\tif (uvs) {\n\t// \t\t\tuvs[vertices.length * 8] = uvs[0];\n\t// \t\t\tuvs[vertices.length * 8 + 1] = uvs[1];\n\t// \t\t\tuvs[vertices.length * 8 + 2] = uvs[2];\n\t// \t\t\tuvs[vertices.length * 8 + 3] = uvs[3];\n\t// \t\t}\n\t// \t\tif (normals) {\n\t// \t\t\tnormals[vertices.length * 8] = normals[0];\n\t// \t\t\tnormals[vertices.length * 8 + 1] = normals[1];\n\t// \t\t\tnormals[vertices.length * 8 + 2] = normals[2];\n\t// \t\t\tnormals[vertices.length * 8 + 3] = normals[3];\n\t// \t\t}\n\t// \t}\n\n\t// \tconst vertexShaderOptions: CompileTimeConstants = {};\n\t// \tif (uvs) vertexShaderOptions[GPUIO_VS_UV_ATTRIBUTE] = '1';\n\t// \tif (normals) vertexShaderOptions[GPUIO_VS_NORMAL_ATTRIBUTE] = '1';\n\n\t// \t// Do setup - this must come first.\n\t// \tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t// \t// Update uniforms and buffers.\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [2 / _width, 2 / _height], FLOAT);\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [-1, -1], FLOAT);\n\t// \t// Init positions buffer.\n\t// \tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(positions)!);\n\t// \tthis._setPositionAttribute(glProgram, program.name);\n\t// \tif (uvs) {\n\t// \t\t// Init uv buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(uvs)!);\n\t// \t\tthis._setUVAttribute(glProgram, program.name);\n\t// \t}\n\t// \tif (normals) {\n\t// \t\t// Init normals buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(normals)!);\n\t// \t\tthis._setVertexAttribute(glProgram, 'a_gpuio_normal', 2, program.name);\n\t// \t}\n\n\t// \t// Draw.\n\t// \tthis._setBlendMode(params.blendAlpha);\n\t// \tgl.drawArrays(gl.TRIANGLE_STRIP, 0, numPositions);\n\t// \tgl.disable(gl.BLEND);\n\t// }\n\n\t// stepTriangleStrip(\n\t// \tparams: {\n\t// \t\tprogram: GPUProgram,\n\t// \t\tpositions: Float32Array,\n\t// \t\tnormals?: Float32Array,\n\t// \t\tuvs?: Float32Array,\n\t// \t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t// \t\toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t// \t\tcount?: number,\n\t// \t\tblendAlpha?: boolean,\n\t// \t},\n\t// ) {\n\t// \tif (this._iterateOverOutputsIfNeeded(params, 'stepTriangleStrip')) return;\n\t// \tconst { gl, _width, _height, _errorState } = this;\n\t// \tconst { program, input, output, positions, uvs, normals } = params;\n\n\t// \tif (_errorState) return;\n\n\t// \tconst vertexShaderOptions: CompileTimeConstants = {};\n\t// \tif (uvs) vertexShaderOptions[GPUIO_VS_UV_ATTRIBUTE] = '1';\n\t// \tif (normals) vertexShaderOptions[GPUIO_VS_NORMAL_ATTRIBUTE] = '1';\n\n\t// \t// Do setup - this must come first.\n\t// \tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t// \t// Update uniforms and buffers.\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [2 / _width, 2 / _height], FLOAT);\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [-1, -1], FLOAT);\n\t// \t// Init positions buffer.\n\t// \tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(positions)!);\n\t// \tthis._setPositionAttribute(glProgram, program.name);\n\t// \tif (uvs) {\n\t// \t\t// Init uv buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(uvs)!);\n\t// \t\tthis._setUVAttribute(glProgram, program.name);\n\t// \t}\n\t// \tif (normals) {\n\t// \t\t// Init normals buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(normals)!);\n\t// \t\tthis._setVertexAttribute(glProgram, 'a_gpuio_normal', 2, program.name);\n\t// \t}\n\n\t// \tconst count = params.count ? params.count : positions.length / 2;\n\n\t// \t// Draw.\n\t// \tthis._setBlendMode(params.blendAlpha);\n\t// \tgl.drawArrays(gl.TRIANGLE_STRIP, 0, count);\n\t// \tgl.disable(gl.BLEND);\n\t// }\n\n\t// stepLines(params: {\n\t// \tprogram: GPUProgram,\n\t// \tpositions: Float32Array,\n\t// \tindices?: Uint16Array | Uint32Array | Int16Array | Int32Array,\n\t// \tnormals?: Float32Array,\n\t// \tuvs?: Float32Array,\n\t// \tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t// \toutput?: GPULayer | GPULayer[], // Undefined renders to screen.\n\t// \tcount?: number,\n\t// \tcloseLoop?: boolean,\n\t// \tblendAlpha?: boolean,\n\t// }) {\n\t// \tconst { gl, _width, _height, _errorState } = this;\n\t// \tconst { indices, uvs, normals, input, output, program } = params;\n\n\t// \tif (_errorState) return;\n\n\t// \t// Check that params are valid.\n\t// \tif (params.closeLoop && indices) {\n\t// \t\tthrow new Error(`GPUComposer.stepLines() can't be called with closeLoop == true and indices.`);\n\t// \t}\n\n\t// \tconst vertexShaderOptions: CompileTimeConstants = {};\n\t// \tif (uvs) vertexShaderOptions[GPUIO_VS_UV_ATTRIBUTE] = '1';\n\t// \tif (normals) vertexShaderOptions[GPUIO_VS_NORMAL_ATTRIBUTE] = '1';\n\n\t// \t// Do setup - this must come first.\n\t// \tconst glProgram = this._drawSetup(program, DEFAULT_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t// \tconst count = params.count ? params.count : (indices ? indices.length : (params.positions.length / 2));\n\n\t// \t// Update uniforms and buffers.\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [2 / _width, 2 / _height], FLOAT);\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_translation', [-1, -1], FLOAT);\n\t// \tif (indices) {\n\t// \t\t// Reorder positions array to match indices.\n\t// \t\tconst positions = new Float32Array(2 * count);\n\t// \t\tfor (let i = 0; i < count; i++) {\n\t// \t\t\tconst index = indices[i];\n\t// \t\t\tpositions[2 * i] = params.positions[2 * index];\n\t// \t\t\tpositions[2 * i + 1] = params.positions[2 * index + 1];\n\t// \t\t}\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(positions)!);\n\t// \t} else {\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(params.positions)!);\n\t// \t}\n\t// \tthis._setPositionAttribute(glProgram, program.name);\n\t// \tif (uvs) {\n\t// \t\t// Init uv buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(uvs)!);\n\t// \t\tthis._setUVAttribute(glProgram, program.name);\n\t// \t}\n\t// \tif (normals) {\n\t// \t\t// Init normals buffer.\n\t// \t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._initVertexBuffer(normals)!);\n\t// \t\tthis._setVertexAttribute(glProgram, 'a_gpuio_normal', 2, program.name);\n\t// \t}\n\n\t// \t// Draw.\n\t// \tthis._setBlendMode(params.blendAlpha);\n\t// \tif (params.indices) {\n\t// \t\tgl.drawArrays(gl.LINES, 0, count);\n\t// \t} else {\n\t// \t\tif (params.closeLoop) {\n\t// \t\t\tgl.drawArrays(gl.LINE_LOOP, 0, count);\n\t// \t\t} else {\n\t// \t\t\tgl.drawArrays(gl.LINE_STRIP, 0, count);\n\t// \t\t}\n\t// \t}\n\t// \tgl.disable(gl.BLEND);\n\t// }\n\n\t/**\n\t * Draw the contents of a GPULayer as points.  This assumes the components of the GPULayer have the form [xPosition, yPosition] or [xPosition, yPosition, xOffset, yOffset].\n\t * @param params - Draw parameters.\n\t * @param params.layer - GPULayer containing position data.\n\t * @param params.program - GPUProgram to run, defaults to drawing points in red.\n\t * @param params.input - Input GPULayers for GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.pointSize - Pixel size of points.\n\t * @param params.count - How many points to draw, defaults to positions.length.\n\t * @param params.color - (If no program passed in) RGB color in range [0, 1] to draw points.\n\t * @param params.wrapX - Wrap points positions in X, defaults to false.\n\t * @param params.wrapY - Wrap points positions in Y, defaults to false.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tdrawLayerAsPoints(\n\t\tparams: {\n\t\t\tlayer: GPULayer, // Positions in units of pixels.\n\t\t\tprogram?: GPUProgram,\n\t\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tpointSize?: number,\n\t\t\tcount?: number,\n\t\t\tcolor?: number[],\n\t\t\twrapX?: boolean,\n\t\t\twrapY?: boolean,\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'drawLayerAsPoints')) return;\n\t\tconst { gl, _pointIndexArray, _width, _height, glslVersion, _errorState } = this;\n\t\tconst { layer, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\t// Check that numPoints is valid.\n\t\tif (layer.numComponents !== 2 && layer.numComponents !== 4) {\n\t\t\tthrow new Error(`GPUComposer.drawLayerAsPoints() must be passed a position GPULayer with either 2 or 4 components, got position GPULayer \"${layer.name}\" with ${layer.numComponents} components.`)\n\t\t}\n\t\tif (glslVersion === GLSL1 && layer.width * layer.height > MAX_FLOAT_INT) {\n\t\t\tconsole.warn(`Points positions array length: ${layer.width * layer.height} is longer than what is supported by GLSL1 : ${MAX_FLOAT_INT}, expect index overflow.`);\n\t\t}\n\t\tconst { length } = layer;\n\t\tconst count = params.count || length;\n\t\tif (count > length) {\n\t\t\tthrow new Error(`Invalid count ${count} for position GPULayer of length ${length}.`);\n\t\t}\n\n\t\tlet program = params.program;\n\t\tif (program === undefined) {\n\t\t\tprogram = this._setValueProgramForType(FLOAT);\n\t\t\tconst color = params.color || [1, 0, 0]; // Default of red.\n\t\t\tif (color.length !== 3) throw new Error(`color parameter must have length 3, got ${JSON.stringify(color)}.`);\n\t\t\tprogram.setUniform('u_value', [...color, 1], FLOAT);\n\t\t}\n\n\t\t// Add positions to end of input if needed.\n\t\tconst input = this._addLayerToInputs(layer, params.input);\n\n\t\tconst vertexShaderOptions: CompileTimeConstants = {};\n\t\t// Tell whether we are using an absolute position (2 components),\n\t\t// or position with accumulation buffer (4 components, better floating pt accuracy).\n\t\tif (layer.numComponents === 4) vertexShaderOptions[GPUIO_VS_POSITION_W_ACCUM] = '1';\n\t\tif (params.wrapX) vertexShaderOptions[GPUIO_VS_WRAP_X] = '1';\n\t\tif (params.wrapY) vertexShaderOptions[GPUIO_VS_WRAP_Y] = '1';\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, LAYER_POINTS_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_positions', indexOfLayerInArray(layer, input), INT);\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 / _width, 1 / _height], FLOAT);\n\t\t// Set default pointSize.\n\t\tconst pointSize = params.pointSize || 1;\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_pointSize', pointSize, FLOAT);\n\t\tconst positionLayerDimensions = [layer.width, layer.height];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_positionsDimensions', positionLayerDimensions, FLOAT);\n\t\t// We get this for free in GLSL3 with gl_VertexID.\n\t\tif (glslVersion === GLSL1) {\n\t\t\tif (this._pointIndexBuffer === undefined || (_pointIndexArray && _pointIndexArray.length < count)) {\n\t\t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t\t\t\tconst indices = initSequentialFloatArray(length);\n\t\t\t\tthis._pointIndexArray = indices;\n\t\t\t\tthis._pointIndexBuffer = this._initVertexBuffer(indices);\n\t\t\t}\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._pointIndexBuffer!);\n\t\t\tthis._setIndexAttribute(glProgram, program.name);\n\t\t}\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.POINTS, 0, count);\n\t\tgl.disable(gl.BLEND);\n\t}\n\n\t// drawLayerAsLines(\n\t// \tparams: {\n\t// \t\tpositions: GPULayer,\n\t// \t\tindices?: Float32Array | Uint16Array | Uint32Array | Int16Array | Int32Array,\n\t// \t\tprogram?: GPUProgram,\n\t// \t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t// \t\toutput?: GPULayer | GPULayer[],\n\t// \t\tcount?: number,\n\t// \t\tcolor?: number[]\n\t// \t\twrapX?: boolean,\n\t// \t\twrapY?: boolean,\n\t// \t\tcloseLoop?: boolean,\n\t// \t\tblendAlpha?: boolean,\n\t// \t},\n\t// ) {\n\t// \tif (this._iterateOverOutputsIfNeeded(params, 'drawLayerAsLines')) return;\n\t// \tconst { gl, _width, _height, glslVersion, _errorState } = this;\n\t// \tconst { positions, output } = params;\n\n\t// \tif (_errorState) return;\n\n\t// \t// Check that positions is valid.\n\t// \tif (positions.numComponents !== 2 && positions.numComponents !== 4) {\n\t// \t\tthrow new Error(`GPUComposer.drawLayerAsLines() must be passed a position GPULayer with either 2 or 4 components, got position GPULayer \"${positions.name}\" with ${positions.numComponents} components.`)\n\t// \t}\n\t// \t// Check that params are valid.\n\t// \tif (params.closeLoop && params.indices) {\n\t// \t\tthrow new Error(`GPUComposer.drawLayerAsLines() can't be called with closeLoop == true and indices.`);\n\t// \t}\n\n\t// \tlet program = params.program;\n\t// \tif (program === undefined) {\n\t// \t\tprogram = params.wrapX || params.wrapY ? this._getWrappedLineColorProgram() : this._setValueProgramForType(FLOAT);;\n\t// \t\tconst color = params.color || [1, 0, 0]; // Default to red.\n\t//\t\tif (color.length !== 3) throw new Error(`color parameter must have length 3, got ${JSON.stringify(color)}.`);\n\t// \t\tprogram.setUniform('u_value', [...color, 1], FLOAT);\n\t// \t}\n\n\t// \t// Add positionLayer to end of input if needed.\n\t// \tconst input = this._addLayerToInputs(positions, params.input);\n\n\t// \tconst vertexShaderOptions: CompileTimeConstants = {};\n\t// \t// Tell whether we are using an absolute position (2 components),\n\t// \t// or position with accumulation buffer (4 components, better floating pt accuracy).\n\t// \tif (positions.numComponents === 4) vertexShaderOptions[GPUIO_VS_POSITION_W_ACCUM] = '1';\n\t// \tif (params.wrapX) vertexShaderOptions[GPUIO_VS_WRAP_X] = '1';\n\t// \tif (params.wrapY) vertexShaderOptions[GPUIO_VS_WRAP_Y] = '1';\n\t// \tvertexShaderOptions[GPUIO_VS_INDEXED_POSITIONS] = params.indices ? '1': '0';\n\n\t// \t// Do setup - this must come first.\n\t// \tconst glProgram = this._drawSetup(program, LAYER_LINES_PROGRAM_NAME, vertexShaderOptions, false, input, output);\n\n\t// \tconst count = params.count ? params.count : (params.indices ? params.indices.length : positions.length);\n\n\t// \t// Update uniforms and buffers.\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_positions', indexOfLayerInArray(positions, input), INT);\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [1 / _width, 1 / _height], FLOAT);\n\t// \tconst positionLayerDimensions = [positions.width, positions.height];\n\t// \tprogram._setVertexUniform(glProgram, 'u_gpuio_positionsDimensions', positionLayerDimensions, FLOAT);\n\t// \t// Only pass in indices if we are using indexed pts or GLSL1, otherwise we get this for free from gl_VertexID.\n\t// \tif (params.indices || glslVersion === GLSL1) {\n\t// \t\t// TODO: cache indexArray if no indices passed in.\n\t// \t\tconst indices = params.indices ? params.indices : initSequentialFloatArray(count);\n\t// \t\tif (this._indexedLinesIndexBuffer === undefined) {\n\t// \t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t// \t\t\tlet floatArray: Float32Array;\n\t// \t\t\tif (indices.constructor !== Float32Array) {\n\t// \t\t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t// \t\t\t\tfloatArray = new Float32Array(indices.length);\n\t// \t\t\t\tfor (let i = 0; i < count; i++) {\n\t// \t\t\t\t\tfloatArray[i] = indices[i];\n\t// \t\t\t\t}\n\t// \t\t\t\tconsole.warn(`Converting indices array of type ${indices.constructor} to Float32Array in GPUComposer.drawIndexedLines for WebGL compatibility, you may want to use a Float32Array to store this information so the conversion is not required.`);\n\t// \t\t\t} else {\n\t// \t\t\t\tfloatArray = indices as Float32Array;\n\t// \t\t\t}\n\t// \t\t\tthis._indexedLinesIndexBuffer = this._initVertexBuffer(floatArray);\n\t// \t\t} else {\n\t// \t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._indexedLinesIndexBuffer!);\n\t// \t\t\t// Copy buffer data.\n\t// \t\t\tgl.bufferData(gl.ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n\t// \t\t}\n\t// \t\tthis._setIndexAttribute(glProgram, program.name);\n\t// \t}\n\n\t// \t// Draw.\n\t// \tthis._setBlendMode(params.blendAlpha);\n\t// \tif (params.indices) {\n\t// \t\tgl.drawArrays(gl.LINES, 0, count);\n\t// \t} else {\n\t// \t\tif (params.closeLoop) {\n\t// \t\t\tgl.drawArrays(gl.LINE_LOOP, 0, count);\n\t// \t\t} else {\n\t// \t\t\tgl.drawArrays(gl.LINE_STRIP, 0, count);\n\t// \t\t}\n\t// \t}\n\t// \tgl.disable(gl.BLEND);\n\t// }\n\n\t/**\n\t * Draw the contents of a 2 component GPULayer as a vector field.\n\t * @param params - Draw parameters.\n\t * @param params.layer - GPULayer containing vector data.\n\t * @param params.program - GPUProgram to run, defaults to drawing vector lines in red.\n\t * @param params.input - Input GPULayers for GPUProgram.\n\t * @param params.output - Output GPULayer, will draw to screen if undefined.\n\t * @param params.vectorSpacing - Spacing between vectors, defaults to drawing a vector every 10 pixels.\n\t * @param params.vectorScale - Scale factor to apply to vector lengths.\n\t * @param params.color - (If no program passed in) RGB color in range [0, 1] to draw points.\n\t * @param params.blendAlpha - Blend mode for draw, defaults to false.\n\t * @returns \n\t */\n\tdrawLayerAsVectorField(\n\t\tparams: {\n\t\t\tlayer: GPULayer,\n\t\t\tprogram?: GPUProgram,\n\t\t\tinput?: (GPULayer | GPULayerState)[] | GPULayer | GPULayerState,\n\t\t\toutput?: GPULayer | GPULayer[],\n\t\t\tvectorSpacing?: number,\n\t\t\tvectorScale?: number,\n\t\t\tcolor?: number[],\n\t\t\tblendAlpha?: boolean,\n\t\t},\n\t) {\n\t\tif (this._iterateOverOutputsIfNeeded(params, 'drawLayerAsVectorField')) return;\n\t\tconst { gl, _vectorFieldIndexArray, _width, _height, glslVersion, _errorState } = this;\n\t\tconst { layer, output } = params;\n\n\t\tif (_errorState) return;\n\n\t\t// Check that field is valid.\n\t\tif (layer.numComponents !== 2) {\n\t\t\tthrow new Error(`GPUComposer.drawLayerAsVectorField() must be passed a fieldLayer with 2 components, got fieldLayer \"${layer.name}\" with ${layer.numComponents} components.`)\n\t\t}\n\t\t// Check aspect ratio.\n\t\t// const dimensions = [vectorLayer.width, vectorLayer.height];\n\t\t// if (Math.abs(dimensions[0] / dimensions[1] - width / height) > 0.01) {\n\t\t// \tthrow new Error(`Invalid aspect ratio ${(dimensions[0] / dimensions[1]).toFixed(3)} vector GPULayer with dimensions [${dimensions[0]}, ${dimensions[1]}], expected ${(width / height).toFixed(3)}.`);\n\t\t// }\n\n\t\tlet program = params.program;\n\t\tif (program === undefined) {\n\t\t\tprogram = this._setValueProgramForType(FLOAT);;\n\t\t\tconst color = params.color || [1, 0, 0]; // Default to red.\n\t\t\tif (color.length !== 3) throw new Error(`color parameter must have length 3, got ${JSON.stringify(color)}.`);\n\t\t\tprogram.setUniform('u_value', [...color, 1], FLOAT);\n\t\t}\n\n\t\t// Add data to end of input if needed.\n\t\tconst input = this._addLayerToInputs(layer, params.input);\n\n\t\t// Do setup - this must come first.\n\t\tconst glProgram = this._drawSetup(program, LAYER_VECTOR_FIELD_PROGRAM_NAME, {}, false, input, output);\n\n\t\t// Update uniforms and buffers.\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_vectors', indexOfLayerInArray(layer, input), INT);\n\t\t// Set default scale.\n\t\tconst vectorScale = params.vectorScale || 1;\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_scale', [vectorScale / _width, vectorScale / _height], FLOAT);\n\t\tconst vectorSpacing = params.vectorSpacing || 10;\n\t\tconst spacedDimensions = [Math.floor(_width / vectorSpacing), Math.floor(_height / vectorSpacing)];\n\t\tprogram._setVertexUniform(glProgram, 'u_gpuio_dimensions', spacedDimensions, FLOAT);\n\t\tconst length = 2 * spacedDimensions[0] * spacedDimensions[1];\n\t\t// We get this for free in GLSL3 with gl_VertexID.\n\t\tif (glslVersion === GLSL1) {\n\t\t\tif (this._vectorFieldIndexBuffer === undefined || (_vectorFieldIndexArray && _vectorFieldIndexArray.length < length)) {\n\t\t\t\t// Have to use float32 array bc int is not supported as a vertex attribute type.\n\t\t\t\tconst indices = initSequentialFloatArray(length);\n\t\t\t\tthis._vectorFieldIndexArray = indices;\n\t\t\t\tthis._vectorFieldIndexBuffer = this._initVertexBuffer(indices);\n\t\t\t}\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this._vectorFieldIndexBuffer!);\n\t\t\tthis._setIndexAttribute(glProgram, program.name);\n\t\t}\n\n\t\t// Draw.\n\t\tthis._setBlendMode(params.blendAlpha);\n\t\tgl.drawArrays(gl.LINES, 0, length);\n\t\tgl.disable(gl.BLEND);\n\t}\n\n\t/**\n\t * If this GPUComposer has been inited via GPUComposer.initWithThreeRenderer(), call resetThreeState() in render loop after performing any step or draw functions.\n\t */\n\tresetThreeState() {\n\t\tif (!this._renderer) {\n\t\t\tthrow new Error(`Can't call resetTHreeState() on a GPUComposer that was not inited with GPUComposer.initWithThreeRenderer().`);\n\t\t}\n\t\tconst { gl } = this;\n\t\t// Reset viewport.\n\t\tconst viewport = this._renderer.getViewport(new ThreejsUtils.Vector4() as Vector4);\n\t\tgl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);\n\t\t// Unbind framebuffer (render to screen).\n\t\tthis._renderer.setRenderTarget(null);\n\t\t// Reset texture bindings.\n\t\tthis._renderer.resetState();\n\t}\n\n\t// TODO: params.callback is not generated in the docs.\n\t/**\n\t * Save the current state of the canvas to png.\n\t * @param params - PNG parameters.\n\t * @param params.filename - PNG filename (no extension).\n\t * @param params.dpi - PNG dpi (defaults to 72dpi).\n\t * @param params.callback - Optional callback when Blob is ready, default behavior saves the PNG using FileSaver.js. \n\t*/\n\tsavePNG(params: {\n\t\tfilename?: string,\n\t\tdpi?: number,\n\t\tcallback?: (blob: Blob, filename: string) => void,\n\t} = {}) {\n\t\tconst { canvas, gl } = this;\n\t\tconst filename = params.filename || 'output';\n\t\tconst callback = params.callback || saveAs; // Default to saving the image with FileSaver.\n\t\t// TODO: need to adjust the canvas size to get the correct px ratio from toBlob().\n\t\t// const ratio = window.devicePixelRatio || 1;\n\t\tcanvas.toBlob((blob) => {\n\t\t\tif (!blob) {\n\t\t\t\tconsole.warn(`Problem saving PNG, unable to init blob from canvas.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (params.dpi) {\n\t\t\t\tchangeDpiBlob(blob, params.dpi).then((blob: Blob) => {\n\t\t\t\t\tcallback(blob, `${filename}.png`);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(blob, `${filename}.png`);\n\t\t\t}\n\t\t}, 'image/png');\n\t}\n\n\t/**\n\t * Call tick() from your render loop to measure the FPS of your application.\n\t * Internally, this does some low pass filtering to give consistent results.\n\t * @returns An Object containing the current fps of your application and the number of times tick() has been called.\n\t */\n\ttick(): { fps: number, numTicks: number} {\n\t\tthis._numTicks += 1;\n\t\tlet { _lastTickTime, _lastTickFPS } = this;\n\t\tconst currentTime = performance.now();\n\t\tthis._lastTickTime = currentTime;\n\t\tif (!_lastTickTime) {\n\t\t\treturn { fps: 0, numTicks: this._numTicks };\n\t\t}\n\t\tconst currentFPS = 1000 / (currentTime - _lastTickTime);\n\t\tif (!_lastTickFPS) _lastTickFPS = currentFPS;\n\t\t// Use a low pass filter to smooth out fps reading.\n\t\tconst factor = 0.9;\n\t\tconst fps =  Number.parseFloat((factor * _lastTickFPS + (1 - factor) * currentFPS).toFixed(1));\n\t\tthis._lastTickFPS = fps;\n\t\treturn {\n\t\t\tfps,\n\t\t\tnumTicks: this._numTicks,\n\t\t};\n\t}\n\t\n\t/**\n\t * Deallocate GPUComposer instance and associated WebGL properties.\n\t */\n\tdispose() {\n\t\tconst { gl, verboseLogging } = this;\n\n\t\tif (verboseLogging) console.log(`Deallocating GPUComposer.`);\n\n\t\t// Delete buffers.\n\t\tif (this._quadPositionsBuffer) {\n\t\t\tgl.deleteBuffer(this._quadPositionsBuffer);\n\t\t\tdelete this._quadPositionsBuffer;\n\t\t}\n\t\tif (this._boundaryPositionsBuffer) {\n\t\t\tgl.deleteBuffer(this._boundaryPositionsBuffer);\n\t\t\tdelete this._boundaryPositionsBuffer;\n\t\t}\n\t\t(Object.keys(this._circlePositionsBuffer) as any as number[]).forEach(key => {\n\t\t\tgl.deleteBuffer(this._circlePositionsBuffer[key]);\n\t\t});\n\t\t// @ts-ignore\n\t\tdelete this._circlePositionsBuffer;\n\t\tdelete this._pointIndexArray;\n\t\tif (this._pointIndexBuffer) {\n\t\t\tgl.deleteBuffer(this._pointIndexBuffer);\n\t\t\tdelete this._pointIndexBuffer;\n\t\t}\n\t\tdelete this._vectorFieldIndexArray;\n\t\tif (this._vectorFieldIndexBuffer) {\n\t\t\tgl.deleteBuffer(this._vectorFieldIndexBuffer);\n\t\t\tdelete this._vectorFieldIndexBuffer;\n\t\t}\n\t\tif (this._indexedLinesIndexBuffer) {\n\t\t\tgl.deleteBuffer(this._indexedLinesIndexBuffer);\n\t\t\tdelete this._indexedLinesIndexBuffer;\n\t\t}\n\n\t\t// Delete vertex attribute locations.\n\t\tObject.keys(this._vertexAttributeLocations).forEach((key) => {\n\t\t\tdelete this._vertexAttributeLocations[key];\n\t\t});\n\t\t// @ts-ignore\n\t\tdelete this._vertexAttributeLocations;\n\n\t\t// Delete vertex shaders.\n\t\tObject.values(this._vertexShaders).forEach(({ compiledShaders })=> {\n\t\t\tObject.keys(compiledShaders).forEach(key => {\n\t\t\t\tgl.deleteShader(compiledShaders[key]);\n\t\t\t\tdelete compiledShaders[key];\n\t\t\t});\n\t\t});\n\t\t// @ts-ignore\n\t\tdelete this._vertexShaders;\n\t\t\n\t\t// Delete fragment shaders.\n\t\tObject.values(this._copyPrograms).forEach(program => {\n\t\t\tprogram.dispose();\n\t\t});\n\t\tObject.keys(this._copyPrograms).forEach(key => {\n\t\t\t// @ts-ignore\n\t\t\tdelete this._copyPrograms[key];\n\t\t});\n\t\t// @ts-ignore;\n\t\tdelete this._copyPrograms;\n\n\t\tObject.values(this._setValuePrograms).forEach(program => {\n\t\t\tprogram.dispose();\n\t\t});\n\t\tObject.keys(this._setValuePrograms).forEach(key => {\n\t\t\t// @ts-ignore\n\t\t\tdelete this._setValuePrograms[key];\n\t\t});\n\t\t// @ts-ignore;\n\t\tdelete this._setValuePrograms;\n\n\t\tthis._wrappedLineColorProgram?.dispose();\n\t\tdelete this._wrappedLineColorProgram;\n\n\t\t// @ts-ignore\n\t\tdelete this._renderer;\n\t\t// @ts-ignore\n\t\tdelete this.gl;\n\t\t// @ts-ignore;\n\t\tdelete this.canvas;\n\t\t// GL context will be garbage collected by webgl.\n\t\t// @ts-ignore\n\t\tdelete this._errorCallback;\n\t\t// @ts-ignore\n\t\tdelete this._extensions;\n\n\t\t// Delete all other keys.\n\t\t// This is mostly for testing so we can be sure we've deallocated everything.\n\t\t// @ts-ignore;\n\t\tdelete this._errorState;\n\t\t// @ts-ignore;\n\t\tdelete this.verboseLogging;\n\t\t// @ts-ignore;\n\t\tdelete this._numTicks;\n\t\t// @ts-ignore;\n\t\tdelete this.isWebGL2;\n\t\t// @ts-ignore;\n\t\tdelete this.glslVersion;\n\t\t// @ts-ignore;\n\t\tdelete this.intPrecision;\n\t\t// @ts-ignore;\n\t\tdelete this.floatPrecision;\n\t\t// @ts-ignore;\n\t\tdelete this._width;\n\t\t// @ts-ignore;\n\t\tdelete this._height;\n\t}\n}","import { getFloat16 } from '@petamoriken/float16';\nimport type { Texture } from 'three';\nimport {\n\tisArray,\n\tisFiniteNumber,\n\tisObject,\n\tisPositiveInteger,\n\tisString,\n} from '@amandaghassaei/type-checks';\n// @ts-ignore\nimport { changeDpiBlob } from 'changedpi';\nimport { saveAs } from 'file-saver';\nimport type { GPUComposer } from './GPUComposer';\nimport {\n\tcheckRequiredKeys,\n\tcheckValidKeys,\n\tisValidClearValue,\n\tisValidDataType,\n\tisValidFilter,\n\tisValidImageFormat,\n\tisValidImageType,\n\tisValidWrap,\n} from './checks';\nimport {\n\tHALF_FLOAT,\n\tFLOAT,\n\tUNSIGNED_BYTE,\n\tBYTE,\n\tUNSIGNED_SHORT,\n\tSHORT,\n\tUNSIGNED_INT,\n\tINT,\n\tNEAREST,\n\tLINEAR,\n\tCLAMP_TO_EDGE,\n\tGPULayerArray,\n\tGPULayerFilter,\n\tGPULayerNumComponents,\n\tGPULayerType,\n\tGPULayerWrap,\n\tvalidFilters,\n\tvalidWraps,\n\tvalidDataTypes,\n\tGPULayerState,\n\tImageFormat,\n\tImageType,\n\tvalidImageFormats,\n\tvalidImageTypes,\n } from './constants';\nimport {\n\treadPixelsAsync,\n\treadyToRead,\n} from './utils';\nimport { disposeFramebuffers, bindFrameBuffer } from './framebuffers';\nimport { arrayConstructorForType } from './conversions';\n\nexport class GPULayer {\n\t// Keep a reference to GPUComposer.\n\tprivate readonly _composer: GPUComposer;\n\n\t/**\n\t * Name of GPULayer, used for error logging.\n\t */\n\treadonly name: string;\n\t/**\n\t * Data type represented by GPULayer.\n\t */\n\treadonly type: GPULayerType; // Input type passed in during setup.\n\t/**\n\t * Number of RGBA elements represented by each pixel in the GPULayer (1-4).\n\t */\n\treadonly numComponents: GPULayerNumComponents;\n\t/**\n\t * Interpolation filter for GPULayer, defaults to LINEAR for 2D FLOAT/HALF_FLOAT GPULayers, otherwise defaults to NEAREST.\n\t */\n\treadonly filter: GPULayerFilter;\n\t/**\n\t * Horizontal wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t */\n\treadonly wrapX: GPULayerWrap;\n\t/**\n\t * Vertical wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t */\n\treadonly wrapY: GPULayerWrap;\n\n\t// Value to set when clear() is called, defaults to zero.\n\t// Access with GPULayer.clearValue.\n\tprivate _clearValue: number | number[] = 0;\n\n\t// Each GPULayer may contain a number of buffers to store different instances of the state.\n\t// e.g [currentState, previousState]\n\tprivate _bufferIndex = 0;\n\treadonly numBuffers;\n\tprivate readonly _buffers: WebGLTexture[] = [];\n\n\t// Texture sizes.\n\tprivate _length?: number; // This is only used for 1D data layers, access with GPULayer.length.\n\tprivate _width: number; // Access with GPULayer.width.\n\tprivate _height: number; // Access with GPULayer.height.\n\n\t// GPULayer settings.\n\t// Due to variable browser support of WebGL features, \"internal\" variables may be different\n\t// from the parameter originally passed in.  These variables are set so that they match the original\n\t// parameter as best as possible, but fragment shader polyfills may be required.\n\t// All \"gl\" variables are used to initialize internal WebGLTexture.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n\t/**\n\t * @private\n\t */\n\treadonly _glInternalFormat: number;\n\t/**\n\t * @private\n\t */\n\treadonly _glFormat: number;\n\n\t/**\n\t * GPULayer._internalType corresponds to GPULayer.glType, but may be different from GPULayer.type.\n\t * @private\n\t */\n\treadonly _internalType: GPULayerType;\n\t/**\n\t * @private\n\t */\n\treadonly _glType: number;\n\n\t/**\n\t * Internally, GPULayer._glNumChannels may represent a larger number of channels than GPULayer.numComponents.\n\t * For example, writable RGB textures are not supported in WebGL2, must use RGBA instead.\n\t * @private\n\t */\n\treadonly _glNumChannels: number;\n\n\t/**\n\t * GPULayer._internalFilter corresponds to GPULayer.glFilter, may be different from GPULayer.filter.\n\t * @private\n\t */\n\treadonly _internalFilter: GPULayerFilter;\n\t/**\n\t * @private\n\t */\n\treadonly _glFilter: number;\n\n\t/**\n\t * GPULayer._internalWrapX corresponds to GPULayer.glWrapX, but may be different from GPULayer.wrapX.\n\t * @private\n\t */\n\treadonly _internalWrapX: GPULayerWrap;\n\t/**\n\t * @private\n\t */\n\treadonly _glWrapS: number;\n\n\t/**\n\t * GPULayer._internalWrapY corresponds to GPULayer.glWrapY, but may be different from GPULayer.wrapY.\n\t * @private\n\t */\n\treadonly _internalWrapY: GPULayerWrap;\n\t/**\n\t * @private\n\t */\n\treadonly _glWrapT: number;\n\t\n\t// Optimization so that \"copying\" can happen without draw calls by simply swapping WebGL textures between GPULayers.\n\t// This functionality is not currently active right now, but will be added back in later.\n\tprivate _textureOverrides?: (WebGLTexture | undefined)[];\n\n\t// Optimizations so we don't allocate many large arrays if getValues()is called multiple times.\n\tprivate _values?: GPULayerArray;\n\tprivate _valuesRaw?: Float32Array | Uint16Array | Uint32Array | Int32Array;\n\tprivate _valuesBufferView?: DataView;\n\n\t/**\n\t * Create a GPULayer from an image url.\n\t * @param composer - The current GPUComposer instance.\n\t * @param params  - GPULayer parameters.\n\t * @param params.name - Name of GPULayer, used for error logging.\n\t * @param params.url - URL of the image source.\n \t * @param params.type - Data type represented by GPULayer.\n\t * @param params.format - Image format, either RGB or RGBA.\n\t * @param params.filter - Interpolation filter for GPULayer, defaults to LINEAR for FLOAT/HALF_FLOAT Images, otherwise defaults to NEAREST.\n\t * @param params.wrapX - Horizontal wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t * @param params.wrapY - Vertical wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t */\n\tstatic async initFromImageURL(composer: GPUComposer,\n\t\tparams: {\n\t\t\tname: string,\n\t\t\turl: string,\n\t\t\ttype?: ImageType,\n\t\t\tformat?: ImageFormat,\n\t\t\tfilter?: GPULayerFilter,\n\t\t\twrapX?: GPULayerWrap,\n\t\t\twrapY?: GPULayerWrap,\n\t\t},\n\t) {\n\t\treturn new Promise<GPULayer>((resolve, reject) => {\n\t\t\tif (!params) {\n\t\t\t\tthrow new Error('Error initing GPULayer: must pass params to GPULayer.initFromImageURL(composer, params).');\n\t\t\t}\n\t\t\tif (!isObject(params)) {\n\t\t\t\tthrow new Error(`Error initing GPULayer: must pass valid params object to GPULayer.initFromImageURL(composer, params), got ${JSON.stringify(params)}.`);\n\t\t\t}\n\t\t\t// Check params.\n\t\t\tconst validKeys = ['name', 'url', 'filter', 'wrapX', 'wrapY', 'format', 'type'];\n\t\t\tconst requiredKeys = ['name', 'url'];\n\t\t\tconst keys = Object.keys(params);\n\t\t\tcheckValidKeys(keys, validKeys, 'GPULayer.initFromImageURL(composer, params)', params.name);\n\t\t\tcheckRequiredKeys(keys, requiredKeys, 'GPULayer.initFromImageURL(composer, params)', params.name);\n\n\t\t\tconst { url, name, filter, wrapX, wrapY, type, format } = params;\n\t\t\tif (!isString(url)) {\n\t\t\t\tthrow new Error(`Expected GPULayer.initFromImageURL params to have url of type string, got ${url} of type ${typeof url}.`)\n\t\t\t}\n\t\t\tif (type && !isValidImageType(type)) {\n\t\t\t\tthrow new Error(`Invalid type: \"${type}\" for GPULayer.initFromImageURL \"${name}\", must be one of ${JSON.stringify(validImageTypes)}.`)\n\t\t\t}\n\t\t\tif (format && !isValidImageFormat(format)) {\n\t\t\t\tthrow new Error(`Invalid format: \"${format}\" for GPULayer.initFromImageURL \"${name}\", must be one of ${JSON.stringify(validImageFormats)}.`)\n\t\t\t}\n\n\t\t\t// Init a layer to return, we will fill it when image has loaded.\n\t\t\tconst layer = new GPULayer(composer, {\n\t\t\t\tname,\n\t\t\t\ttype: type || FLOAT,\n\t\t\t\tfilter,\n\t\t\t\twrapX,\n\t\t\t\twrapY,\n\t\t\t\tnumComponents: format ? format.length as GPULayerNumComponents : 4,\n\t\t\t\tdimensions: [1, 1], // Init as 1 px to start.\n\t\t\t\tnumBuffers: 1,\n\t\t\t});\n\n\t\t\n\t\t\t// Load image.\n\t\t\tconst image = new Image();\n\t\t\timage.onload = () => {\n\t\t\t\tlayer.resize([image.width, image.height], image);\n\t\t\t\t// Callback when texture has loaded.\n\t\t\t\tresolve(layer);\n\t\t\t};\n\t\t\timage.onerror = (e) => {\n\t\t\t\treject(new Error(`Error loading image \"${name}\": ${e}`));\n\t\t\t}\n\t\t\timage.src = url;\n\t\t});\n\t}\n\n\t/**\n\t * Create a GPULayer.\n\t * @param composer - The current GPUComposer instance.\n\t * @param params  - GPULayer parameters.\n\t * @param params.name - Name of GPULayer, used for error logging.\n \t * @param params.type - Data type represented by GPULayer.\n\t * @param params.numComponents - Number of RGBA elements represented by each pixel in the GPULayer (1-4).\n\t * @param params.dimensions - Dimensions of 1D or 2D GPULayer.\n\t * @param params.filter - Interpolation filter for GPULayer, defaults to LINEAR for 2D FLOAT/HALF_FLOAT GPULayers, otherwise defaults to NEAREST.\n\t * @param params.wrapX - Horizontal wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t * @param params.wrapY - Vertical wrapping style for GPULayer, defaults to CLAMP_TO_EDGE.\n\t * @param params.numBuffers - How may buffers to allocate, defaults to 1.  If you intend to use the current state of this GPULayer as an input to generate a new state, you will need at least 2 buffers.\n\t * @param params.clearValue - Value to write to GPULayer when GPULayer.clear() is called.\n\t * @param params.array - Array to initialize GPULayer.\n\t */\n\tconstructor(\n\t\tcomposer: GPUComposer,\n\t\tparams: {\n\t\t\tname: string,\n\t\t\ttype: GPULayerType,\n\t\t\tnumComponents: GPULayerNumComponents,\n\t\t\tdimensions: number | number[],\n\t\t\tarray?: GPULayerArray | number[],\n\t\t\tfilter?: GPULayerFilter,\n\t\t\twrapX?: GPULayerWrap,\n\t\t\twrapY?: GPULayerWrap,\n\t\t\tnumBuffers?: number,\n\t\t\tclearValue?: number | number[],\n\t\t},\n\t) {\n\t\t// Check constructor parameters.\n\t\tconst { name } = (params || {});\n\t\tif (!composer) {\n\t\t\tthrow new Error(`Error initing GPULayer \"${name}\": must pass GPUComposer instance to GPULayer(composer, params).`);\n\t\t}\n\t\tif (!params) {\n\t\t\tthrow new Error('Error initing GPULayer: must pass params to GPULayer(composer, params).');\n\t\t}\n\t\tif (!isObject(params)) {\n\t\t\tthrow new Error(`Error initing GPULayer: must pass valid params object to GPULayer(composer, params), got ${JSON.stringify(params)}.`);\n\t\t}\n\t\t// Check params keys.\n\t\tconst validKeys = ['name', 'type', 'numComponents', 'dimensions', 'filter', 'wrapX', 'wrapY', 'numBuffers', 'clearValue', 'array'];\n\t\tconst requiredKeys = ['name', 'type', 'numComponents', 'dimensions'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPULayer(composer, params)', params.name);\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPULayer(composer, params)', params.name);\n\n\t\tconst { dimensions, type, numComponents } = params;\n\t\tconst { gl } = composer;\n\n\t\t// Save params.\n\t\tthis._composer = composer;\n\t\tthis.name = name;\n\n\t\t// numComponents must be between 1 and 4.\n\t\tif (!isPositiveInteger(numComponents) || numComponents > 4) {\n\t\t\tthrow new Error(`Invalid numComponents: ${JSON.stringify(numComponents)} for GPULayer \"${name}\", must be number in range [1-4].`);\n\t\t}\n\t\tthis.numComponents = numComponents;\n\n\t\t// Set dimensions, may be 1D or 2D.\n\t\tconst { length, width, height } = GPULayer.calcGPULayerSize(dimensions, name, composer.verboseLogging);\n\t\t// We already type checked length, width, and height in calcGPULayerSize.\n\t\tthis._length = length;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\t// Set filtering - if we are processing a 1D array, default to NEAREST filtering.\n\t\t// Else default to LINEAR (interpolation) filtering for float types and NEAREST for integer types.\n\t\tconst defaultFilter = (length === undefined && (type === FLOAT || type == HALF_FLOAT)) ? LINEAR : NEAREST;\n\t\tconst filter = params.filter !== undefined ? params.filter : defaultFilter;\n\t\tif (!isValidFilter(filter)) {\n\t\t\tthrow new Error(`Invalid filter: ${JSON.stringify(filter)} for GPULayer \"${name}\", must be one of ${JSON.stringify(validFilters)}.`);\n\t\t}\n\t\t// Don't allow LINEAR filtering on integer types, it is not supported.\n\t\tif (filter === LINEAR && !(type === FLOAT || type == HALF_FLOAT)) {\n\t\t\tthrow new Error(`LINEAR filtering is not supported on integer types, please use NEAREST filtering for GPULayer \"${name}\" with type: ${type}.`);\n\t\t}\n\t\tthis.filter = filter;\n\n\t\t// Get wrap types, default to clamp to edge.\n\t\tconst wrapX = params.wrapX !== undefined ? params.wrapX : CLAMP_TO_EDGE;\n\t\tif (!isValidWrap(wrapX)) {\n\t\t\tthrow new Error(`Invalid wrapX: ${JSON.stringify(wrapX)} for GPULayer \"${name}\", must be one of ${JSON.stringify(validWraps)}.`);\n\t\t}\n\t\tthis.wrapX = wrapX;\n\t\tconst wrapY = params.wrapY !== undefined ? params.wrapY : CLAMP_TO_EDGE;\n\t\tif (!isValidWrap(wrapY)) {\n\t\t\tthrow new Error(`Invalid wrapY: ${JSON.stringify(wrapY)} for GPULayer \"${name}\", must be one of ${JSON.stringify(validWraps)}.`);\n\t\t}\n\t\tthis.wrapY = wrapY;\n\n\t\t// Set data type.\n\t\tif (!isValidDataType(type)) {\n\t\t\tthrow new Error(`Invalid type: ${JSON.stringify(type)} for GPULayer \"${name}\", must be one of ${JSON.stringify(validDataTypes)}.`);\n\t\t}\n\t\tthis.type = type;\n\t\tconst internalType = GPULayer.getGPULayerInternalType({\n\t\t\tcomposer,\n\t\t\ttype,\n\t\t\tname,\n\t\t});\n\t\tthis._internalType = internalType;\n\t\t// Set gl texture parameters.\n\t\tconst {\n\t\t\tglFormat,\n\t\t\tglInternalFormat,\n\t\t\tglType,\n\t\t\tglNumChannels,\n\t\t} = GPULayer.getGLTextureParameters({\n\t\t\tcomposer,\n\t\t\tname,\n\t\t\tnumComponents,\n\t\t\tinternalType,\n\t\t});\n\t\tthis._glInternalFormat = glInternalFormat;\n\t\tthis._glFormat = glFormat;\n\t\tthis._glType = glType;\n\t\tthis._glNumChannels = glNumChannels;\n\n\t\t// Set internal filtering/wrap types.\n\t\t// Make sure that we set filter BEFORE setting wrap.\n\t\tconst internalFilter = GPULayer.getGPULayerInternalFilter({ composer, filter, wrapX, wrapY, internalType, name });\n\t\tthis._internalFilter = internalFilter;\n\t\tthis._glFilter = gl[internalFilter];\n\t\tthis._internalWrapX = GPULayer.getGPULayerInternalWrap({ composer, wrap: wrapX, internalFilter, internalType, name });\n\t\tthis._glWrapS = gl[this._internalWrapX];\n\t\tthis._internalWrapY = GPULayer.getGPULayerInternalWrap({ composer, wrap: wrapY, internalFilter, internalType, name });\n\t\tthis._glWrapT = gl[this._internalWrapY];\n\n\t\t// Num buffers is the number of states to store for this data.\n\t\tconst numBuffers = params.numBuffers !== undefined ? params.numBuffers : 1;\n\t\tif (!isPositiveInteger(numBuffers)) {\n\t\t\tthrow new Error(`Invalid numBuffers: ${JSON.stringify(numBuffers)} for GPULayer \"${name}\", must be positive integer.`);\n\t\t}\n\t\tthis.numBuffers = numBuffers;\n\n\t\t// Wait until after type has been set to set clearValue.\n\t\tif (params.clearValue !== undefined) {\n\t\t\tthis.clearValue = params.clearValue; // Setter can only be called after this.numComponents has been set.\n\t\t}\n\n\t\tthis._initBuffers(params.array);\n\t}\n\n\t/**\n\t * The width of the GPULayer array.\n\t */\n\t get width() {\n\t\treturn this._width;\n\t}\n\n\t/**\n\t * The height of the GPULayer array.\n\t */\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\t/**\n\t * The length of the GPULayer array (only available to 1D GPULayers).\n\t */\n\tget length() {\n\t\tif (!this._length) {\n\t\t\tthrow new Error(`Cannot access length on 2D GPULayer \"${this.name}\".`);\n\t\t}\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Returns whether the GPULayer was inited as a 1D array (rather than 2D).\n\t * @returns - true if GPULayer is 1D, else false.\n\t */\n\tis1D() {\n\t\treturn this._length !== undefined;\n\t}\n\n\t/**\n\t * Test whether the current buffer index has override enabled.\n\t * @private\n\t */\n\t_usingTextureOverrideForCurrentBuffer() {\n\t\treturn !!(this._textureOverrides && this._textureOverrides[this.bufferIndex]);\n\t}\n\n\t// saveCurrentStateToGPULayer(layer: GPULayer) {\n\t// \t// A method for saving a copy of the current state without a draw call.\n\t// \t// Draw calls are expensive, this optimization helps.\n\t// \tif (this.numBuffers < 2) {\n\t// \t\tthrow new Error(`Can't call GPULayer.saveCurrentStateToGPULayer on GPULayer \"${this.name}\" with less than 2 buffers.`);\n\t// \t}\n\t// \t// Check that texture params are the same.\n\t// \tif (layer.glWrapS !== this.glWrapS || layer.glWrapT !== this.glWrapT ||\n\t// \t\tlayer.wrapS !== this.wrapS || layer.wrapT !== this.wrapT ||\n\t// \t\tlayer.width !== this.width || layer.height !== this.height ||\n\t// \t\tlayer.glFilter !== this.glFilter || layer.filter !== this.filter ||\n\t// \t\tlayer.glNumChannels !== this.glNumChannels || layer.numComponents !== this.numComponents ||\n\t// \t\tlayer.glType !== this.glType || layer.type !== this.type ||\n\t// \t\tlayer.glFormat !== this.glFormat || layer.glInternalFormat !== this.glInternalFormat) {\n\t// \t\t\tthrow new Error(`Incompatible texture params between GPULayers \"${layer.name}\" and \"${this.name}\".`);\n\t// \t}\n\n\t// \t// If we have not already inited overrides array, do so now.\n\t// \tif (!this.textureOverrides) {\n\t// \t\tthis.textureOverrides = [];\n\t// \t\tfor (let i = 0; i < this.numBuffers; i++) {\n\t// \t\t\tthis.textureOverrides.push(undefined);\n\t// \t\t}\n\t// \t}\n\n\t// \t// Check if we already have an override in place.\n\t// \tif (this.textureOverrides[this.bufferIndex]) {\n\t// \t\tthrow new Error(`Can't call GPULayer.saveCurrentStateToGPULayer on GPULayer \"${this.name}\", this GPULayer has not written new state since last call to GPULayer.saveCurrentStateToGPULayer.`);\n\t// \t}\n\t// \tconst { currentState } = this;\n\t// \tthis.textureOverrides[this.bufferIndex] = currentState;\n\t// \t// Swap textures.\n\t// \tthis.buffers[this.bufferIndex].texture = layer.currentState;\n\t// \tlayer._setCurrentStateTexture(currentState);\n\n\t// \t// Bind swapped texture to framebuffer.\n\t// \tconst { gl } = this.composer;\n\t// \tconst { framebuffer, texture } = this.buffers[this.bufferIndex];\n\t// \tif (!framebuffer) throw new Error(`No framebuffer for writable GPULayer \"${this.name}\".`);\n\t// \tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t// \t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/framebufferTexture2D\n\t// \tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\t// \t// Unbind.\n\t// \tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t// }\n\n\t// // This is used internally.\n\t// _setCurrentStateTexture(texture: WebGLTexture) {\n\t// \tthis.buffers[this.bufferIndex].texture = texture;\n\t// }\n\n\t/**\t\n\t * Init GLTexture/GLFramebuffer pairs for reading/writing GPULayer data.\n\t * @private\n\t */\n\tprivate _initBuffers(\n\t\tarrayOrImage?: GPULayerArray | number[] | HTMLImageElement,\n\t) {\n\t\tconst {\n\t\t\tname,\n\t\t\tnumBuffers,\n\t\t\t_composer,\n\t\t\t_glInternalFormat,\n\t\t\t_glFormat,\n\t\t\t_glType,\n\t\t\t_glFilter,\n\t\t\t_glWrapS,\n\t\t\t_glWrapT,\n\t\t\twidth,\n\t\t\theight,\n\t\t} = this;\n\t\tconst { gl, _errorCallback } = _composer;\n\n\t\tlet validatedArrayOrImage: GPULayerArray | HTMLImageElement | null = null;\n\t\tif (isArray(arrayOrImage)) validatedArrayOrImage = GPULayer.validateGPULayerArray(arrayOrImage as GPULayerArray | number[], this);\n\t\telse if (arrayOrImage?.constructor === HTMLImageElement) validatedArrayOrImage = arrayOrImage;\n\n\t\t// Init a texture for each buffer.\n\t\tfor (let i = 0; i < numBuffers; i++) {\n\t\t\tconst texture = gl.createTexture();\n\t\t\tif (!texture) {\n\t\t\t\t_errorCallback(`Could not init texture for GPULayer \"${name}\": ${gl.getError()}.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, _glWrapS);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, _glWrapT);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, _glFilter);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, _glFilter);\n\n\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, _glInternalFormat, width, height, 0, _glFormat, _glType, validatedArrayOrImage as any as ArrayBufferView | null);\n\t\t\t\n\t\t\t// Save this buffer to the list.\n\t\t\tthis._buffers.push(texture);\n\t\t}\n\t\t// Unbind.\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t}\n\t\n\t/**\n\t * Get buffer index of the current state.\n\t */\n\tget bufferIndex() {\n\t\treturn this._bufferIndex;\n\t}\n\n\t/**\n\t * Increment buffer index by 1.\n\t */\n\tincrementBufferIndex() {\n\t\t// Increment bufferIndex.\n\t\tthis._bufferIndex = (this.bufferIndex + 1) % this.numBuffers;\n\t}\n\n\t/**\n\t * Decrement buffer index by 1.\n\t */\n\t decrementBufferIndex() {\n\t\t// Decrement bufferIndex.\n\t\tthis._bufferIndex = (this.bufferIndex - 1 + this.numBuffers) % this.numBuffers;\n\t}\n\n\t/**\n\t * Get the current state as a GPULayerState object.\n\t */\n\tget currentState() {\n\t\treturn this.getStateAtIndex(this.bufferIndex);\n\t}\n\n\t/**\n\t * Get the current state as a WebGLTexture.\n\t * Used internally.\n\t * @private\n\t */\n\tget _currentTexture() {\n\t\tconst { _buffers, _bufferIndex, _textureOverrides } = this;\n\t\tif (_textureOverrides && _textureOverrides[_bufferIndex]) return _textureOverrides[_bufferIndex]!;\n\t\treturn _buffers[_bufferIndex];\n\t}\n\n\t/**\n\t * Get the previous state as a GPULayerState object (only available for GPULayers with numBuffers > 1).\n\t */\n\tget lastState() {\n\t\tif (this.numBuffers === 1) {\n\t\t\tthrow new Error(`Cannot access lastState on GPULayer \"${this.name}\" with only one buffer.`);\n\t\t}\n\t\treturn this.getStateAtIndex((this.bufferIndex - 1 + this.numBuffers) % this.numBuffers);\n\t}\n\n\t/**\n\t * Get the state at a specified index as a GPULayerState object.\n\t */\n\tgetStateAtIndex(index: number): GPULayerState {\n\t\tconst { numBuffers, _textureOverrides, _buffers } = this;\n\t\tif (index < 0 && index > -numBuffers) {\n\t\t\tindex += numBuffers; // Slightly negative numbers are ok.\n\t\t}\n\t\tif (index < 0 || index >= numBuffers) {\n\t\t\t// We will allow this number to overflow with warning - likely user error.\n\t\t\tconsole.warn(`Out of range buffer index: ${index} for GPULayer \"${this.name}\" with $.numBuffers} buffer${numBuffers > 1 ? 's' : ''}.  Was this intentional?`);\n\t\t\tif (index < 0) {\n\t\t\t\tindex += numBuffers * Math.ceil(Math.abs(index) / numBuffers);\n\t\t\t} else {\n\t\t\t\tindex = index % numBuffers;\n\t\t\t}\n\t\t}\n\t\tlet texture = _buffers[index];\n\t\tif (_textureOverrides && _textureOverrides[index]) texture =  _textureOverrides[index]!;\n\t\treturn {\n\t\t\ttexture,\n\t\t\tlayer: this,\n\t\t};\n\t}\n\n\t/**\n\t * Increments the buffer index (if needed).\n\t * @private\n\t */\n\t_prepareForWrite(\n\t\tincrementBufferIndex: boolean,\n\t) {\n\t\tif (incrementBufferIndex) {\n\t\t\tthis.incrementBufferIndex();\n\t\t}\n\n\t\t// We are going to do a data write, if we have overrides enabled, we can remove them.\n\t\tif (this._textureOverrides) {\n\t\t\tthis._textureOverrides[this.bufferIndex] = undefined;\n\t\t}\n\t}\n\n\tsetFromArray(array: GPULayerArray | number[]) {\n\t\tconst {\n\t\t\t_composer,\n\t\t\t_glInternalFormat,\n\t\t\t_glFormat,\n\t\t\t_glType,\n\t\t\twidth,\n\t\t\theight,\n\t\t\t_currentTexture,\n\t\t} = this;\n\t\tconst { gl } = _composer;\n\t\tconst validatedArray = GPULayer.validateGPULayerArray(array, this);\n\t\tgl.bindTexture(gl.TEXTURE_2D, _currentTexture);\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, _glInternalFormat, width, height, 0, _glFormat, _glType, validatedArray);\n\t\t// Unbind texture.\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t}\n\n\t// setFromImage(image: HTMLImageElement) {\n\t// \tconst { name, _composer, width, height, _currentTexture, _glInternalFormat, _glFormat, _glType, numComponents, type } = this;\n\t// \tconst { gl } = _composer;\n\t// \t// Check compatibility.\n\t// \tif (!isValidImageType(type)) {\n\t// \t\tthrow new Error(`GPULayer has invalid type ${type} for setFromImage(), valid types are: ${JSON.stringify(validImageTypes)}.`);\n\t// \t}\n\t// \tif (numComponents < 3) {\n\t// \t\tthrow new Error(`GPULayer has invalid numComponents ${numComponents} for setFromImage(), must have either 3 (RGB) or 4 (RGBA) components.`);\n\t// \t}\n\t// \tif (image.width !== width || image.height !== height) {\n\t// \t\tthrow new Error(`Invalid image dimensions [${image.width}, ${image.height}] for GPULayer \"${name}\" with dimensions [${width}, ${height}].  Call GPULayer.resize(width, height, image) instead.`);\n\t// \t}\n\t// \tgl.bindTexture(gl.TEXTURE_2D, _currentTexture);\n\t// \tgl.texImage2D(gl.TEXTURE_2D, 0, _glInternalFormat, width, height, 0, _glFormat, _glType, image as any);\n\t// \t// Unbind texture.\n\t// \tgl.bindTexture(gl.TEXTURE_2D, null);\n\t// }\n\n\tresize(\n\t\tdimensions: number | number[],\n\t\tarrayOrImage?: HTMLImageElement | GPULayerArray | number[],\n\t) {\n\t\tconst { name, _composer } = this;\n\t\tconst { verboseLogging } = _composer;\n\t\tif (verboseLogging) console.log(`Resizing GPULayer \"${name}\" to ${JSON.stringify(dimensions)}.`);\n\t\tconst { length, width, height } = GPULayer.calcGPULayerSize(dimensions, name, verboseLogging);\n\t\tthis._length = length;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._destroyBuffers();\n\t\tthis._initBuffers(arrayOrImage);\n\t}\n\n\t/**\n\t * Set the clearValue of the GPULayer, which is applied during GPULayer.clear().\n\t */\n\tset clearValue(clearValue: number | number[]) {\n\t\tconst { numComponents, type } = this;\n\t\tif (!isValidClearValue(clearValue, numComponents, type)) {\n\t\t\tthrow new Error(`Invalid clearValue: ${JSON.stringify(clearValue)} for GPULayer \"${this.name}\", expected ${type} or array of ${type} of length ${numComponents}.`);\n\t\t}\n\t\t// Make deep copy if needed.\n\t\tthis._clearValue = isArray(clearValue) ? (clearValue as number[]).slice() : clearValue;\n\t}\n\n\t/**\n\t * Get the clearValue of the GPULayer.\n\t */\n\tget clearValue() {\n\t\treturn this._clearValue;\n\t}\n\n\t/**\n\t * Clear all data in GPULayer to GPULayer.clearValue.\n\t * @param applyToAllBuffers - Flag to apply to all buffers of GPULayer, or just the current output buffer.\n\t */\n\tclear(applyToAllBuffers = false) {\n\t\tconst { name, _composer, clearValue, numBuffers, type } = this;\n\t\tconst { verboseLogging } = _composer;\n\t\tif (verboseLogging) console.log(`Clearing GPULayer \"${name}\".`);\n\n\t\tconst value: number[] = [];\n\t\tif (isFiniteNumber(clearValue)) {\n\t\t\tvalue.push(clearValue as number, clearValue as number, clearValue as number, clearValue as number);\n\t\t} else {\n\t\t\tvalue.push(...clearValue as number[]);\n\t\t\tfor (let j = value.length; j < 4; j++) {\n\t\t\t\tvalue.push(0);\n\t\t\t}\n\t\t}\n\t\n\t\tconst endIndex = applyToAllBuffers ? numBuffers : 1;\n\t\tconst program = _composer._setValueProgramForType(type);\n\t\tprogram.setUniform('u_value', value);\n\t\tthis.decrementBufferIndex(); // step() wil increment buffer index before draw, this way we clear in place.\n\t\tfor (let i = 0; i < endIndex; i++) {\n\t\t\t// Write clear value to buffers.\n\t\t\t_composer.step({\n\t\t\t\tprogram,\n\t\t\t\toutput: this,\n\t\t\t});\n\t\t}\n\t\tif (applyToAllBuffers) this.incrementBufferIndex(); // Get us back to the starting index.\n\t}\n\n\tprivate _getValuesSetup() {\n\t\tconst { width, height, _composer, _currentTexture } = this;\n\t\tlet { _valuesRaw } = this;\n\t\tconst { gl } = _composer;\n\n\t\t// In case GPULayer was not the last output written to.\n\t\tbindFrameBuffer(_composer, this, _currentTexture);\n\n\t\tlet { _glNumChannels, _glType, _glFormat, _internalType } = this;\n\t\tswitch (_internalType) {\n\t\t\tcase HALF_FLOAT:\n\t\t\t\tif (gl.FLOAT !== undefined) {\n\t\t\t\t\t// Firefox requires that RGBA/FLOAT is used for readPixels of float16 types.\n\t\t\t\t\t_glNumChannels = 4;\n\t\t\t\t\t_glFormat = gl.RGBA;\n\t\t\t\t\t_glType = gl.FLOAT;\n\t\t\t\t\t_valuesRaw = _valuesRaw || new Float32Array(width * height * _glNumChannels);\n\t\t\t\t} else {\n\t\t\t\t\t_valuesRaw = _valuesRaw || new Uint16Array(width * height * _glNumChannels);\n\t\t\t\t}\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Uint16Array(width * height * glNumChannels);\n\t\t\t\tbreak\n\t\t\tcase FLOAT:\n\t\t\t\t// Chrome and Firefox require that RGBA/FLOAT is used for readPixels of float32 types.\n\t\t\t\t// https://github.com/KhronosGroup/WebGL/issues/2747\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = gl.RGBA;\n\t\t\t\t_valuesRaw = _valuesRaw || new Float32Array(width * height * _glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_BYTE:\n\t\t\t\t// We never hit glslVersion === GLSL1 anymore, see GPULayerHelpers.shouldCastIntTypeAsFloat for more info.\n\t\t\t\t// if (glslVersion === GLSL1) {\n\t\t\t\t// \t// Firefox requires that RGBA/UNSIGNED_BYTE is used for readPixels of unsigned byte types.\n\t\t\t\t// \t_glNumChannels = 4;\n\t\t\t\t// \t_glFormat = gl.RGBA;\n\t\t\t\t// \t_valuesRaw = _valuesRaw || new Uint8Array(width * height * _glNumChannels);\n\t\t\t\t// \tbreak;\n\t\t\t\t// }\n\t\t\t\t// Firefox requires that RGBA_INTEGER/UNSIGNED_INT is used for readPixels of unsigned int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_glType = gl.UNSIGNED_INT;\n\t\t\t\t_valuesRaw = _valuesRaw || new Uint32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Uint8Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_SHORT:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/UNSIGNED_INT is used for readPixels of unsigned int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_glType = gl.UNSIGNED_INT;\n\t\t\t\t_valuesRaw = _valuesRaw || new Uint32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Uint16Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_INT:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/UNSIGNED_INT is used for readPixels of unsigned int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_valuesRaw = _valuesRaw || new Uint32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Uint32Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase BYTE:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/INT is used for readPixels of int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_glType = gl.INT;\n\t\t\t\t_valuesRaw = _valuesRaw || new Int32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Int8Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase SHORT:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/INT is used for readPixels of int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_glType = gl.INT;\n\t\t\t\t_valuesRaw = _valuesRaw || new Int32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Int16Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tcase INT:\n\t\t\t\t// Firefox requires that RGBA_INTEGER/INT is used for readPixels of int types.\n\t\t\t\t_glNumChannels = 4;\n\t\t\t\t_glFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t_valuesRaw = _valuesRaw || new Int32Array(width * height * _glNumChannels);\n\t\t\t\t// // The following works in Chrome.\n\t\t\t\t// _valuesRaw = _valuesRaw || new Int32Array(width * height * glNumChannels);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported internalType ${_internalType} for getValues().`);\n\t\t}\n\t\tthis._valuesRaw = _valuesRaw;\n\t\tif (readyToRead(gl)) {\n\t\t\treturn { _glFormat, _glType, _valuesRaw, _glNumChannels, _internalType };\n\t\t} else {\n\t\t\tthrow new Error(`Unable to read values from Buffer with status: ${gl.checkFramebufferStatus(gl.FRAMEBUFFER)}.`);\n\t\t}\n\t}\n\n\tprivate _getValuesPost(\n\t\t_valuesRaw: Float32Array | Uint16Array | Uint32Array | Int32Array,\n\t\t_glNumChannels: number,\n\t\t_internalType: GPULayerType,\n\t) {\n\t\tconst { width, height, numComponents, type } = this;\n\t\t\n\t\tconst OUTPUT_LENGTH = (this._length ? this._length : width * height) * numComponents;\n\n\t\t// Convert uint16 to float32 if needed.\n\t\tconst handleFloat16Conversion = _internalType === HALF_FLOAT && _valuesRaw.constructor === Uint16Array;\n\t\tlet { _valuesBufferView } = this;\n\t\tif (handleFloat16Conversion && !_valuesBufferView) {\n\t\t\t// @ts-ignore\n\t\t\t_valuesBufferView = new DataView((_valuesRaw as Uint16Array).buffer);\n\t\t\tthis._valuesBufferView = _valuesBufferView;\n\t\t}\n\t\t\n\n\t\t// We may use a different internal type than the assigned type of the GPULayer.\n\t\tif (_valuesRaw.length === OUTPUT_LENGTH && arrayConstructorForType(type, true) === _valuesRaw.constructor) {\n\t\t\tthis._values = _valuesRaw;\n\t\t} else if (!this._values) this._values = GPULayer.initArrayForType(type, OUTPUT_LENGTH, true);\n\t\tconst { _values } = this;\n\n\t\t// In some cases glNumChannels may be > numComponents.\n\t\tif (_valuesBufferView || _values !== _valuesRaw || numComponents !== _glNumChannels) {\n\t\t\tfor (let i = 0, length = width * height; i < length; i++) {\n\t\t\t\tconst index1 = i * _glNumChannels;\n\t\t\t\tconst index2 = i * numComponents;\n\t\t\t\tif (index2 >= OUTPUT_LENGTH) break;\n\t\t\t\tfor (let j = 0; j < numComponents; j++) {\n\t\t\t\t\tif (_valuesBufferView) {\n\t\t\t\t\t\t_values[index2 + j] = getFloat16(_valuesBufferView, 2 * (index1 + j), true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_values[index2 + j] = _valuesRaw[index1 + j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _values;\n\t}\n\n\t/**\n\t * Returns the current values of the GPULayer as a TypedArray.\n\t * @returns - A TypedArray containing current state of GPULayer.\n\t */\n\tgetValues() {\n\t\tconst { width, height, _composer } = this;\n\t\tconst { gl } = _composer;\n\t\tconst { _glFormat, _glType, _valuesRaw, _glNumChannels, _internalType } = this._getValuesSetup();\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels\n\t\tgl.readPixels(0, 0, width, height, _glFormat, _glType, _valuesRaw);\n\t\treturn this._getValuesPost(_valuesRaw, _glNumChannels, _internalType);\n\t}\n\n\t/**\n\t * Non-blocking function to return the current values of the GPULayer as a TypedArray.\n\t * This only works for WebGL2 contexts, will fall back to getValues() if WebGL1 context.\n\t * @returns - A TypedArray containing current state of GPULayer.\n\t */\n\tasync getValuesAsync() {\n\t\tconst { width, height, _composer } = this;\n\t\tconst { gl, isWebGL2 } = _composer;\n\t\tif (!isWebGL2) {\n\t\t\t// Async method is not supported for WebGL1.\n\t\t\treturn this.getValues();\n\t\t}\n\t\tconst { _glFormat, _glType, _valuesRaw, _glNumChannels, _internalType } = this._getValuesSetup();\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels\n\t\tawait readPixelsAsync(gl as WebGL2RenderingContext, 0, 0, width, height, _glFormat, _glType, _valuesRaw);\n\t\treturn this._getValuesPost(_valuesRaw, _glNumChannels, _internalType);\n\t}\n\n\t// TODO: params.callback is not generated in the docs.\n\t/**\n\t * Save the current state of this GPULayer to png.\n\t * @param params - PNG parameters.\n\t * @param params.filename - PNG filename (no extension, defaults to the name of the GPULayer).\n\t * @param params.dpi - PNG dpi (defaults to 72dpi).\n\t * @param params.multiplier - Multiplier to apply to data before saving PNG (defaults to 255 for FLOAT and HALF_FLOAT types, else 1).\n\t * @param params.callback - Optional callback when Blob is ready, default behavior saves the PNG using FileSaver.js. \n\t*/\n\tsavePNG(params: {\n\t\tfilename?: string,\n\t\tdpi?: number,\n\t\tmultiplier?: number,\n\t\tcallback?: (blob: Blob, filename: string) => void,\n\t} = {}) {\n\t\tconst values = this.getValues();\n\t\tconst { width, height, type, name, numComponents } = this;\n\t\tconst callback = params.callback || saveAs; // Default to saving the image with FileSaver.\n\t\tconst filename = params.filename || name; // Default to the name of this layer.\n\t\tconst multiplier = params.multiplier ||\n\t\t\t((type === FLOAT || type === HALF_FLOAT) ? 255 : 1);\n\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = width;\n    \tcanvas.height = height;\n\t\tconst context = canvas.getContext('2d')!;\n\t\tconst imageData = context.getImageData(0, 0, width, height);\n\t\tconst buffer = imageData.data;\n\t\t// Have to flip the y axis since PNGs are written top to bottom.\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst index = y * width + x;\n\t\t\t\tconst indexFlipped = (height - 1 - y) * width + x;\n\t\t\t\tfor (let i = 0; i < numComponents; i++) {\n\t\t\t\t\tbuffer[4 * indexFlipped + i] = values[numComponents * index + i] * multiplier;\n\t\t\t\t}\n\t\t\t\tif (numComponents === 1) {\n\t\t\t\t\t// Make monochrome.\n\t\t\t\t\tbuffer[4 * indexFlipped + 1] = buffer[4 * indexFlipped];\n\t\t\t\t\tbuffer[4 * indexFlipped + 2] = buffer[4 * indexFlipped];\n\t\t\t\t}\n\t\t\t\tif (numComponents < 4) {\n\t\t\t\t\tbuffer[4 * indexFlipped + 3] = 255; // Set alpha channel to 255.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcontext.putImageData(imageData, 0, 0);\n\n\t\tcanvas.toBlob((blob) => {\n\t\t\tif (!blob) {\n\t\t\t\tconsole.warn(`Problem saving PNG from GPULayer \"${name}\", unable to init blob.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (params.dpi) {\n\t\t\t\tchangeDpiBlob(blob, params.dpi).then((blob: Blob) =>{\n\t\t\t\t\tcallback(blob, `${filename}.png`);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(blob, `${filename}.png`);\n\t\t\t}\n\t\t}, 'image/png');\n\t}\n\n\t/**\n\t * Attach the output buffer of this GPULayer to a Threejs Texture object.\n\t * @param {Texture} texture - Threejs texture object.\n\t */\n\tattachToThreeTexture(texture: Texture) {\n\t\tconst { _composer, numBuffers, currentState, name } = this;\n\t\tconst { _renderer } = _composer;\n\t\tif (!_renderer) {\n\t\t\tthrow new Error('GPUComposer was not inited with a renderer.');\n\t\t}\n\t\t// Link webgl texture to threejs object.\n\t\t// This is not officially supported.\n\t\tif (numBuffers > 1) {\n\t\t\tthrow new Error(`GPULayer \"${name}\" contains multiple WebGL textures (one for each buffer) that are flip-flopped during compute cycles, please choose a GPULayer with one buffer.`);\n\t\t}\n\t\tconst offsetTextureProperties = _renderer.properties.get(texture);\n\t\toffsetTextureProperties.__webglTexture = currentState;\n\t\toffsetTextureProperties.__webglInit = true;\n\t}\n\n\t/**\n\t * Delete this GPULayer's framebuffers and textures.\n\t * @private\n\t */\n\tprivate _destroyBuffers() {\n\t\tconst { _composer, _buffers } = this;\n\t\tconst { gl } = _composer;\n\t\t_buffers.forEach(texture => {\n\t\t\tgl.deleteTexture(texture);\n\t\t\tdisposeFramebuffers(gl, texture);\n\t\t});\n\t\t_buffers.length = 0;\n\n\t\t// These are technically owned by another GPULayer,\n\t\t// so we are not responsible for deleting them from gl context.\n\t\tdelete this._textureOverrides;\n\t}\n\n\t/**\n\t * Create a deep copy of GPULayer with current state copied over.\n\t * @param name - Name of new GPULayer as string.\n\t * @returns - Deep copy of GPULayer.\n\t */\n\tclone(name?: string) {\n\t\t// Make a deep copy.\n\t\treturn this._composer._cloneGPULayer(this, name);\n\t}\n\n\t/**\n\t * Deallocate GPULayer instance and associated WebGL properties.\n\t */\n\tdispose() {\n\t\tconst { name, _composer } = this;\n\t\tconst { gl, verboseLogging } = _composer;\n\n\t\tif (verboseLogging) console.log(`Deallocating GPULayer \"${name}\".`);\n\n\t\tif (!gl) throw new Error(`Must call dispose() on all GPULayers before calling dispose() on GPUComposer.`);\n\t\n\t\tthis._destroyBuffers();\n\t\t// @ts-ignore\n\t\tdelete this._buffers;\n\t\t// @ts-ignore\n\t\tdelete this._composer;\n\n\t\tif (this._values) delete this._values;\n\t\tif (this._valuesRaw) delete this._valuesRaw;\n\t}\n\n\t/** \n\t * These methods are defined in GPULayerHelpers.ts\n\t */\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic initArrayForType(\n\t\ttype: GPULayerType,\n\t\tlength: number,\n\t\thalfFloatsAsFloats?: boolean,\n\t): GPULayerArray;\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic calcGPULayerSize(\n\t\tsize: number | number[],\n\t\tname: string,\n\t\tverboseLogging: boolean,\n\t): { width: number, height: number, length?: number };\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic getGPULayerInternalWrap(\n\t\tparams: {\n\t\t\tcomposer: GPUComposer,\n\t\t\twrap: GPULayerWrap,\n\t\t\tinternalFilter: GPULayerFilter,\n\t\t\tinternalType: GPULayerType,\n\t\t\tname: string,\n\t\t},\n\t): GPULayerWrap;\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic getGPULayerInternalFilter(\n\t\tparams: {\n\t\t\tcomposer: GPUComposer,\n\t\t\tfilter: GPULayerFilter,\n\t\t\twrapX: GPULayerWrap,\n\t\t\twrapY: GPULayerWrap,\n\t\t\tinternalType: GPULayerType,\n\t\t\tname: string,\n\t\t},\n\t): GPULayerFilter;\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic getGLTextureParameters(\n\t\tparams: {\n\t\t\tcomposer: GPUComposer,\n\t\t\tname: string,\n\t\t\tnumComponents: GPULayerNumComponents,\n\t\t\tinternalType: GPULayerType,\n\t\t}\n\t): {\n\t\tglFormat: number,\n\t\tglInternalFormat: number,\n\t\tglType: number,\n\t\tglNumChannels: number,\n\t};\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\n\tstatic getGPULayerInternalType(\n\t\tparams: {\n\t\t\tcomposer: GPUComposer,\n\t\t\ttype: GPULayerType,\n\t\t\tname: string,\n\t\t},\n\t): GPULayerType;\n\t/**\n\t * @private\n\t */\n\t// @ts-ignore\t\n\tstatic validateGPULayerArray(\n\t\tarray: GPULayerArray | number[],\n\t\tlayer: GPULayer,\n\t): GPULayerArray;\n}","import { isNumber, isPositiveInteger } from '@amandaghassaei/type-checks';\nimport { setFloat16 } from '@petamoriken/float16';\nimport {\n\tBYTE,\n\tCLAMP_TO_EDGE,\n\tFLOAT,\n\tGPULayerFilter,\n\tGPULayerType,\n\tGPULayerWrap,\n\tHALF_FLOAT,\n\tINT,\n\tNEAREST,\n\tSHORT,\n\tUNSIGNED_BYTE,\n\tUNSIGNED_INT,\n\tUNSIGNED_SHORT,\n\tGLSL3,\n\tGPULayerNumComponents,\n\tGLSL1,\n\tGPULayerArray,\n\tvalidArrayTypes,\n\tMIN_UNSIGNED_BYTE,\n\tMAX_UNSIGNED_BYTE,\n\tMIN_BYTE,\n\tMAX_BYTE,\n\tMIN_UNSIGNED_SHORT,\n\tMAX_UNSIGNED_SHORT,\n\tMIN_SHORT,\n\tMAX_SHORT,\n\tMIN_UNSIGNED_INT,\n\tMAX_UNSIGNED_INT,\n\tMIN_INT,\n\tMAX_INT,\n\tLINEAR,\n\tDEFAULT_PROGRAM_NAME,\n} from './constants';\nimport { arrayConstructorForType } from './conversions';\nimport {\n\tEXT_COLOR_BUFFER_FLOAT,\n\tEXT_COLOR_BUFFER_HALF_FLOAT,\n\tgetExtension,\n\tOES_TEXTURE_FLOAT,\n\tOES_TEXTURE_FLOAT_LINEAR,\n\tOES_TEXTURE_HALF_FLOAT,\n\tOES_TEXTURE_HAlF_FLOAT_LINEAR,\n} from './extensions';\nimport { bindFrameBuffer } from './framebuffers';\nimport type { GPUComposer } from './GPUComposer';\nimport { GPULayer } from './GPULayer';\nimport {\n\tcompileShader,\n\tconvertFragmentShaderToGLSL1,\n\tinitGLProgram,\n\tisIntType,\n\tisUnsignedIntType,\n} from './utils';\n\n// Memoize results.\nconst results = {\n\twriteSupport: {} as { [key: string]: boolean },\n\tfilterWrapSupport: {} as { [key: string]: boolean },\n}\n\n/**\n * Init empty typed array for type, optionally use Float32Array for HALF_FLOAT.\n * @private\n */\nGPULayer.initArrayForType = (\n\ttype: GPULayerType,\n\tlength: number,\n\thalfFloatsAsFloats = false,\n) => {\n\treturn new (arrayConstructorForType(type, halfFloatsAsFloats))(length);\n}\n\n/**\n * Calc 2D size [width, height] for GPU layer given a 1D or 2D size parameter.\n * If 1D size supplied, nearest power of 2 width/height is generated.\n * Also checks that size elements are valid.\n * @private\n */\n\nGPULayer.calcGPULayerSize = (\n\tsize: number | number[],\n\tname: string,\n\tverboseLogging: boolean,\n) => {\n\tif (isNumber(size as number)) {\n\t\tif (!isPositiveInteger(size)) {\n\t\t\tthrow new Error(`Invalid length: ${JSON.stringify(size)} for GPULayer \"${name}\", must be positive integer.`);\n\t\t}\n\t\tconst length = size as number;\n\t\t// Relaxing adherence to power of 2.\n\t\t// // Calc power of two width and height for length.\n\t\t// let exp = 1;\n\t\t// let remainder = length;\n\t\t// while (remainder > 2) {\n\t\t// \texp++;\n\t\t// \tremainder /= 2;\n\t\t// }\n\t\t// const width = Math.pow(2, Math.floor(exp / 2) + exp % 2);\n\t\t// const height = Math.pow(2, Math.floor(exp/2));\n\t\tconst width = Math.ceil(Math.sqrt(length));\n\t\tconst height = Math.ceil(length / width);\n\t\tif (verboseLogging) console.log(`Using [${width}, ${height}] for 1D array of length ${size} in GPULayer \"${name}\".`);\n\t\treturn { width, height, length };\n\t}\n\tconst width = (size as number[])[0];\n\tif (!isPositiveInteger(width)) {\n\t\tthrow new Error(`Invalid width: ${JSON.stringify(width)} for GPULayer \"${name}\", must be positive integer.`);\n\t}\n\tconst height = (size as number[])[1];\n\tif (!isPositiveInteger(height)) {\n\t\tthrow new Error(`Invalid height: ${JSON.stringify(height)} for GPULayer \"${name}\", must be positive integer.`);\n\t}\n\treturn { width, height };\n}\n\n/**\n * Get the GL wrap type to use internally in GPULayer, based on browser support.\n * @private\n */\nGPULayer.getGPULayerInternalWrap = (\n\tparams: {\n\t\tcomposer: GPUComposer,\n\t\twrap: GPULayerWrap,\n\t\tinternalFilter: GPULayerFilter,\n\t\tinternalType: GPULayerType,\n\t\tname: string,\n\t},\n) => {\n\tconst { composer, wrap, internalFilter, internalType } = params;\n\n\t// CLAMP_TO_EDGE is always supported.\n\tif (wrap === CLAMP_TO_EDGE) {\n\t\treturn wrap;\n\t}\n\n\t// Test if wrap/filter combo is actually supported by running some numbers through.\n\tif (testFilterWrap(composer, internalType, internalFilter, wrap)) {\n\t\treturn wrap;\n\t}\n\t// If not, convert to CLAMP_TO_EDGE and polyfill in fragment shader.\n\treturn CLAMP_TO_EDGE;\n\t// REPEAT and MIRROR_REPEAT wrap not supported for non-power of 2 textures in safari.\n\t// I've tested this and it seems that some power of 2 textures will work (512 x 512),\n\t// but not others (1024x1024), so let's just change all WebGL 1.0 to CLAMP.\n\t// Without this, we currently get an error at drawArrays():\n\t// \"WebGL: drawArrays: texture bound to texture unit 0 is not renderable.\n\t// It maybe non-power-of-2 and have incompatible texture filtering or is not\n\t// 'texture complete', or it is a float/half-float type with linear filtering and\n\t// without the relevant float/half-float linear extension enabled.\"\n}\n\n/**\n * Get the GL filter type to use internally in GPULayer, based on browser support.\n * @private\n */\n GPULayer.getGPULayerInternalFilter = (\n\tparams: {\n\t\tcomposer: GPUComposer,\n\t\tfilter: GPULayerFilter,\n\t\twrapX: GPULayerWrap,\n\t\twrapY: GPULayerWrap,\n\t\tinternalType: GPULayerType,\n\t\tname: string,\n\t},\n) => {\n\tlet { filter } = params;\n\tif (filter === NEAREST) {\n\t\t// NEAREST filtering is always supported.\n\t\treturn filter;\n\t}\n\n\tconst { composer, internalType, wrapX, wrapY, name } = params;\n\n\tif (internalType === HALF_FLOAT) {\n\t\tconst extension = getExtension(composer, OES_TEXTURE_HAlF_FLOAT_LINEAR, true)\n\t\t\t|| getExtension(composer, OES_TEXTURE_FLOAT_LINEAR, true);\n\t\tif (!extension || !testFilterWrap(composer, internalType, filter, wrapX) || !testFilterWrap(composer, internalType, filter, wrapY)) {\n\t\t\tconsole.warn(`This browser does not support ${filter} filtering for type ${internalType} and wrap [${wrapX}, ${wrapY}].  Falling back to NEAREST filter for GPULayer \"${name}\" with ${filter} polyfill in fragment shader.`);\n\t\t\tfilter = NEAREST; // Polyfill in fragment shader.\n\t\t}\n\t} if (internalType === FLOAT) {\n\t\tconst extension = getExtension(composer, OES_TEXTURE_FLOAT_LINEAR, true);\n\t\tif (!extension || !testFilterWrap(composer, internalType, filter, wrapX) || !testFilterWrap(composer, internalType, filter, wrapY)) {\n\t\t\tconsole.warn(`This browser does not support ${filter} filtering for type ${internalType} and wrap [${wrapX}, ${wrapY}].  Falling back to NEAREST filter for GPULayer \"${name}\" with ${filter} polyfill in fragment shader.`);\n\t\t\tfilter = NEAREST; // Polyfill in fragment shader.\n\t\t}\n\t}\n\treturn filter;\n}\n\n/**\n * Returns whether to cast int type as floats, as needed by browser.\n * @private\n */\nexport function shouldCastIntTypeAsFloat(\n\tcomposer: GPUComposer,\n\ttype: GPULayerType,\n) {\n\tconst { glslVersion, isWebGL2 } = composer;\n\t// All types are supported by WebGL2 + glsl3.\n\tif (glslVersion === GLSL3 && isWebGL2) return false;\n\t// Int textures (other than UNSIGNED_BYTE) are not supported by WebGL1.0 or glsl1.x.\n\t// https://stackoverflow.com/questions/55803017/how-to-select-webgl-glsl-sampler-type-from-texture-format-properties\n\t// Use HALF_FLOAT/FLOAT instead.\n\t// Some large values of INT and UNSIGNED_INT are not supported unfortunately.\n\t// See tests for more information.\n\t// Update: Even UNSIGNED_BYTE should be cast as float in GLSL1.  I noticed some strange behavior in test:\n\t// setUniform>'should cast/handle uint uniforms for UNSIGNED_BYTE GPULayers' in tests/mocha/GPUProgram and \n\t// getValues>'should return correct values for UNSIGNED_BYTE GPULayer' in tests/mocha/GPULayer\n\treturn type === UNSIGNED_BYTE || type === BYTE || type === SHORT || type === INT || type === UNSIGNED_SHORT || type === UNSIGNED_INT;\n}\n\n/**\n * Returns GLTexture parameters for GPULayer, based on browser support.\n * @private\n */\nGPULayer.getGLTextureParameters = (\n\tparams: {\n\t\tcomposer: GPUComposer,\n\t\tname: string,\n\t\tnumComponents: GPULayerNumComponents,\n\t\tinternalType: GPULayerType,\n\t}\n) => {\n\tconst { composer, name, numComponents, internalType } = params;\n\tconst { gl, glslVersion, isWebGL2 } = composer;\n\t// https://www.khronos.org/registry/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE\n\tlet glType: number | undefined,\n\t\tglFormat: number | undefined,\n\t\tglInternalFormat: number | undefined,\n\t\tglNumChannels: number | undefined;\n\n\tif (isWebGL2) {\n\t\tglNumChannels = numComponents;\n\t\t// https://www.khronos.org/registry/webgl/extensions/EXT_color_buffer_float/\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n\t\t// The sized internal format RGBxxx are not color-renderable.\n\t\t// If numComponents == 3 for a writable texture, use RGBA instead.\n\t\t// Page 5 of https://www.khronos.org/files/webgl20-reference-guide.pdf\n\t\t// Update: Some formats (e.g. RGB) may be emulated, causing a performance hit:\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#some_formats_e.g._rgb_may_be_emulated\n\t\t// Prefer to use rgba instead of rgb for all cases (WebGL1 and WebGL2).\n\t\tif (numComponents === 3) {\n\t\t\tglNumChannels = 4;\n\t\t}\n\t\tif (internalType === FLOAT || internalType === HALF_FLOAT) {\n\t\t\t// This will be hit in all cases for GLSL1, now that we have cast UNSIGNED_BYTE types to HALF_FLOAT for GLSL1.\n\t\t\t// See comments in shouldCastIntTypeAsFloat for more information.\n\t\t\tswitch (glNumChannels) {\n\t\t\t\tcase 1:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RG;\n\t\t\t\t\tbreak;\n\t\t\t\t// case 3:\n\t\t\t\t// \tglFormat = gl.RGB; // We never hit this.\n\t\t\t\t// \tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tglFormat = gl.RGBA;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t}\n\t\t} else {\n\t\t\t// This case will only be hit by GLSL 3.\n\t\t\t// Int textures are not supported in GLSL1.\n\t\t\tswitch (glNumChannels) {\n\t\t\t\tcase 1:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RED_INTEGER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RG_INTEGER;\n\t\t\t\t\tbreak;\n\t\t\t\t// case 3:\n\t\t\t\t// \tglFormat = (gl as WebGL2RenderingContext).RGB_INTEGER; // We never hit this.\n\t\t\t\t// \tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tglFormat = (gl as WebGL2RenderingContext).RGBA_INTEGER;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t}\n\t\t}\n\t\tswitch (internalType) {\n\t\t\tcase HALF_FLOAT:\n\t\t\t\tglType = (gl as WebGL2RenderingContext).HALF_FLOAT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R16F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG16F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB16F; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA16F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FLOAT:\n\t\t\t\tglType = (gl as WebGL2RenderingContext).FLOAT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R32F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG32F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB32F; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA32F;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_BYTE:\n\t\t\t\tglType = gl.UNSIGNED_BYTE;\n\t\t\t\tif (glslVersion === GLSL1 && internalType === UNSIGNED_BYTE) {\n\t\t\t\t\tglInternalFormat = glFormat;\n\t\t\t\t} else {\n\t\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R8UI;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG8UI;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// case 3:\n\t\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB8UI; // We never hit this.\n\t\t\t\t\t\t// \tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA8UI;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BYTE:\n\t\t\t\tglType = gl.BYTE;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R8I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG8I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB8I; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA8I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SHORT:\n\t\t\t\tglType = gl.SHORT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R16I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG16I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB16I; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA16I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_SHORT:\n\t\t\t\tglType = gl.UNSIGNED_SHORT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R16UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG16UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB16UI; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA16UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase INT:\n\t\t\t\tglType = gl.INT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R32I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG32I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB32I; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA32I;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase UNSIGNED_INT:\n\t\t\t\tglType = gl.UNSIGNED_INT;\n\t\t\t\tswitch (glNumChannels) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).R32UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RG32UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// case 3:\n\t\t\t\t\t// \tglInternalFormat = (gl as WebGL2RenderingContext).RGB32UI; // We never hit this.\n\t\t\t\t\t// \tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tglInternalFormat = (gl as WebGL2RenderingContext).RGBA32UI;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported glNumChannels: ${glNumChannels} for GPULayer \"${name}\".`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported type: \"${internalType}\" for GPULayer \"${name}\".`);\n\t\t}\n\t} else {\n\t\t// WebGL1 case.\n\t\tif (numComponents < 1 || numComponents > 4) {\n\t\t\tthrow new Error(`Unsupported numComponents: ${numComponents} for GPULayer \"${name}\".`);\n\t\t}\n\t\t// Always use 4 channel textures for WebGL1.\n\t\t// Some formats (e.g. RGB) may be emulated, causing a performance hit:\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#some_formats_e.g._rgb_may_be_emulated\n\t\tglNumChannels = 4;\n\t\tglFormat = gl.RGBA;\n\t\tglInternalFormat = gl.RGBA;\n\t\tswitch (internalType) {\n\t\t\tcase FLOAT:\n\t\t\t\tglType = gl.FLOAT;\n\t\t\t\tbreak;\n\t\t\tcase HALF_FLOAT:\n\t\t\t\tglType = (gl as WebGL2RenderingContext).HALF_FLOAT || getExtension(composer, OES_TEXTURE_HALF_FLOAT).HALF_FLOAT_OES as number;\n\t\t\t\tbreak;\n\t\t\t// case UNSIGNED_BYTE:\n\t\t\t// \t// This will never be hit, now that we have cast UNSIGNED_BYTE types to HALF_FLOAT for GLSL1.\n\t\t\t// \t// See comments in shouldCastIntTypeAsFloat for more information.\n\t\t\t// \tglType = gl.UNSIGNED_BYTE;\n\t\t\t// \tbreak;\n\t\t\t// No other types are supported in WebGL1.\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported type: \"${internalType}\" in WebGL 1.0 for GPULayer \"${name}\".`);\n\t\t}\n\t}\n\n\t// Check for missing params.\n\tif (glType === undefined || glFormat === undefined || glInternalFormat === undefined) {\n\t\tconst missingParams = [];\n\t\tif (glType === undefined) missingParams.push('glType');\n\t\tif (glFormat === undefined) missingParams.push('glFormat');\n\t\tif (glInternalFormat === undefined) missingParams.push('glInternalFormat');\n\t\tthrow new Error(`Invalid type: ${internalType} for numComponents: ${numComponents}, unable to init parameter${missingParams.length > 1 ? 's' : ''} ${missingParams.join(', ')} for GPULayer \"${name}\".`);\n\t}\n\tif (glNumChannels === undefined || numComponents < 1 || numComponents > 4 || glNumChannels < numComponents) {\n\t\tthrow new Error(`Invalid numChannels: ${glNumChannels} for numComponents: ${numComponents} for GPULayer \"${name}\".`);\n\t}\n\n\treturn {\n\t\tglFormat,\n\t\tglInternalFormat,\n\t\tglType,\n\t\tglNumChannels,\n\t};\n}\n\n/**\n * Rigorous method for testing FLOAT and HALF_FLOAT write support by attaching texture to framebuffer.\n * @private\n */\nexport function testWriteSupport(\n\tcomposer: GPUComposer,\n\tinternalType: GPULayerType,\n) {\n\tconst { gl, glslVersion, isWebGL2 } = composer;\n\n\t// Memoize results for a given set of inputs.\n\tconst key = `${isWebGL2},${internalType},${glslVersion === GLSL3 ? '3' : '1'}`;\n\tif (results.writeSupport[key] !== undefined) {\n\t\treturn results.writeSupport[key];\n\t}\n\n\tconst texture = gl.createTexture();\n\tif (!texture) {\n\t\tresults.writeSupport[key] = false;\n\t\treturn results.writeSupport[key];\n\t}\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\n\t// Default to most widely supported settings.\n\tconst wrap = gl[CLAMP_TO_EDGE];\n\tconst filter = gl[NEAREST];\n\t// Use non-power of two dimensions to check for more universal support.\n\t// (In case size of GPULayer is changed at a later point).\n\tconst width = 10;\n\tconst height = 10;\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n\n\tconst { glInternalFormat, glFormat, glType } = GPULayer.getGLTextureParameters({\n\t\tcomposer,\n\t\tname: 'testWriteSupport',\n\t\tnumComponents: 1,\n\t\tinternalType,\n\t});\n\tgl.texImage2D(gl.TEXTURE_2D, 0, glInternalFormat, width, height, 0, glFormat, glType, null);\n\n\t// Init a framebuffer for this texture so we can write to it.\n\tconst framebuffer = gl.createFramebuffer();\n\tif (!framebuffer) {\n\t\t// Clear out allocated memory.\n\t\tgl.deleteTexture(texture);\n\t\tresults.writeSupport[key] = false;\n\t\treturn results.writeSupport[key];\n\t}\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/framebufferTexture2D\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n\tconst validStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n\t// Clear out allocated memory.\n\tgl.deleteTexture(texture);\n\tgl.deleteFramebuffer(framebuffer);\n\n\tresults.writeSupport[key] = validStatus;\n\treturn results.writeSupport[key];\n}\n\n/**\n * Rigorous method for testing whether a filter/wrap combination is supported\n * by the current browser.  I found that some versions of WebGL2 mobile safari\n * may support the OES_texture_float_linear and EXT_color_buffer_float, but still\n * do not linearly interpolate float textures or wrap only for power-of-two textures.\n * @private\n */\nexport function testFilterWrap(\n\tcomposer: GPUComposer,\n\tinternalType: GPULayerType,\n\tfilter: GPULayerFilter,\n\twrap: GPULayerWrap,\n) {\n\tconst { gl, glslVersion, intPrecision, floatPrecision, _errorCallback, isWebGL2 } = composer;\n\n\t// Memoize results for a given set of inputs.\n\tconst key = `${isWebGL2},${internalType},${filter},${wrap},${glslVersion === GLSL3 ? '3' : '1'}`;\n\tif (results.filterWrapSupport[key] !== undefined) {\n\t\treturn results.filterWrapSupport[key];\n\t}\n\n\tconst texture = gl.createTexture();\n\tif (!texture) {\n\t\tresults.filterWrapSupport[key] = false;\n\t\treturn results.filterWrapSupport[key];\n\t}\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\n\tconst glWrap = gl[wrap];\n\tconst glFilter = gl[filter];\n\t// Use non power of two dimensions to check for more universal support.\n\tconst width = 3;\n\tconst height = 3;\n\tconst numComponents = 1;\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, glWrap);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, glWrap);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);\n\n\tconst { glInternalFormat, glFormat, glType, glNumChannels } = GPULayer.getGLTextureParameters({\n\t\tcomposer,\n\t\tname: 'testFilterWrap',\n\t\tnumComponents,\n\t\tinternalType,\n\t});\n\t// Init texture with values.\n\tconst values = [3, 56.5, 834, -53.6, 0.003, 96.2, 23, 90.2, 32];\n\tlet valuesTyped = GPULayer.initArrayForType(internalType, values.length * glNumChannels, true);\n\tfor (let i = 0; i < values.length; i++) {\n\t\tvaluesTyped[i * glNumChannels] = values[i];\n\t\tvalues[i] = valuesTyped[i * glNumChannels]; // Cast as int/uint if needed.\n\t}\n\tif (internalType === HALF_FLOAT) {\n\t\t// Cast values as Uint16Array for HALF_FLOAT.\n\t\tconst valuesTyped16 = new Uint16Array(valuesTyped.length);\n\t\tconst float16View =  new DataView(valuesTyped16.buffer);\n\t\tfor (let i = 0; i < valuesTyped.length; i++) {\n\t\t\tsetFloat16(float16View, 2 * i, valuesTyped[i], true);\n\t\t}\n\t\tvaluesTyped = valuesTyped16;\n\t}\n\tgl.texImage2D(gl.TEXTURE_2D, 0, glInternalFormat, width, height, 0, glFormat, glType, valuesTyped);\n\n\t// Init a GPULayer to write to.\n\t// Must use CLAMP_TO_EDGE/NEAREST on this GPULayer to avoid infinite loop.\n\tconst output = new GPULayer(composer, {\n\t\tname: 'testFloatLinearFiltering-output',\n\t\ttype: internalType,\n\t\tnumComponents,\n\t\tdimensions: [width, height],\n\t\twrapX: CLAMP_TO_EDGE,\n\t\twrapY: CLAMP_TO_EDGE,\n\t\tfilter: NEAREST,\n\t});\n\n\tconst offset = filter === LINEAR ? 0.5 : 1;\n\t// Run program to perform linear filter.\n\tconst programName = 'testFilterWrap-program';\n\tlet fragmentShaderSource = `\nin vec2 v_uv;\nuniform vec2 u_offset;\n#ifdef GPUIO_INT\n\tuniform isampler2D u_input;\n\tout int out_result;\n#endif\n#ifdef GPUIO_UINT\n\tuniform usampler2D u_input;\n\tout uint out_result;\n#endif\n#ifdef GPUIO_FLOAT\n\tuniform sampler2D u_input;\n\tout float out_result;\n#endif\nvoid main() {\n\tout_result = texture(u_input, v_uv + offset).x;\n}`;\n\tif (glslVersion !== GLSL3) {\n\t\tfragmentShaderSource = convertFragmentShaderToGLSL1(fragmentShaderSource, programName)[0];\n\t}\n\tconst fragmentShader = compileShader(\n\t\tgl,\n\t\tglslVersion,\n\t\tintPrecision,\n\t\tfloatPrecision,\n\t\tfragmentShaderSource,\n\t\tgl.FRAGMENT_SHADER,\n\t\tprogramName,\n\t\t_errorCallback,\n\t\t{\n\t\t\toffset: `vec2(${offset / width}, ${offset / height})`,\n\t\t\t[isUnsignedIntType(internalType) ? 'GPUIO_UINT' : (isIntType(internalType) ? 'GPUIO_INT': 'GPUIO_FLOAT')]: '1',\n\t\t},\n\t\ttrue,\n\t);\n\n\tfunction wrapValue(val: number, max: number) {\n\t\tif (wrap === CLAMP_TO_EDGE) return Math.max(0, Math.min(max - 1, val));\n\t\treturn (val + max) % max;\n\t}\n\n\tconst vertexShader = composer._getVertexShader(DEFAULT_PROGRAM_NAME, '', {}, programName);\n\tif (vertexShader && fragmentShader) {\n\t\tconst program = initGLProgram(gl, vertexShader, fragmentShader, programName, _errorCallback);\n\t\tif (program) {\n\t\t\t// Draw setup.\n\t\t\toutput._prepareForWrite(false);\n\t\t\tbindFrameBuffer(composer, output, output._currentTexture);\n\t\t\tgl.viewport(0, 0, width, height);\n\t\t\tgl.useProgram(program);\n\t\t\t// Bind texture.\n\t\t\tgl.activeTexture(gl.TEXTURE0 );\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\t// Set uniforms.\n\t\t\tgl.uniform2fv(gl.getUniformLocation(program, 'u_gpuio_scale'), [1, 1]);\n\t\t\tgl.uniform2fv(gl.getUniformLocation(program, 'u_gpuio_translation'), [0, 0]);\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, composer._getQuadPositionsBuffer());\n\t\t\tcomposer._setPositionAttribute(program, programName);\n\n\t\t\t// Draw.\n\t\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t\t\tgl.disable(gl.BLEND);\n\n\t\t\tconst filtered = output.getValues();\n\t\t\tlet supported = true;\n\t\t\tconst tol = isIntType(internalType) ? 0 : (internalType === HALF_FLOAT ? 1e-2 : 1e-4);\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\t\tlet expected;\n\t\t\t\t\tif (filter === LINEAR) {\n\t\t\t\t\t\texpected = (values[y * width + x] +\n\t\t\t\t\t\t\tvalues[y * width + wrapValue(x + 1, width)] +\n\t\t\t\t\t\t\tvalues[wrapValue(y + 1, height) * width + x] +\n\t\t\t\t\t\t\tvalues[wrapValue(y + 1, height) * width + wrapValue(x + 1, width)]) / 4;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst _x = wrapValue(x + offset, width);\n\t\t\t\t\t\tconst _y = wrapValue(y + offset, height);\n\t\t\t\t\t\texpected = values[_y * width + _x];\n\t\t\t\t\t}\n\t\t\t\t\tconst i = y * width + x;\n\t\t\t\t\tif (Math.abs((expected - filtered[i]) / expected) > tol) {\n\t\t\t\t\t\tsupported = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresults.filterWrapSupport[key] = supported;\n\t\t\t// Clear out allocated memory.\n\t\t\tgl.deleteProgram(program);\n\t\t} else {\n\t\t\tresults.filterWrapSupport[key] = false;\n\t\t}\n\t\t// Clear out allocated memory.\n\t\t// vertexShader belongs to composer, don't delete it.\n\t\tgl.deleteShader(fragmentShader);\n\t} else {\n\t\tresults.filterWrapSupport[key] = false;\n\t}\n\t// Clear out allocated memory.\n\toutput.dispose();\n\tgl.deleteTexture(texture);\n\treturn results.filterWrapSupport[key];\n}\n\n/**\n * Get the GL type to use internally in GPULayer, based on browser support.\n * @private\n * Exported here for testing purposes.\n */\nGPULayer.getGPULayerInternalType = (\n\tparams: {\n\t\tcomposer: GPUComposer,\n\t\ttype: GPULayerType,\n\t\tname: string,\n\t},\n) => {\n\tconst { composer, name } = params;\n\tconst { _errorCallback, isWebGL2 } = composer;\n\tconst { type } = params;\n\tlet internalType = type;\n\t// Check if int types are supported.\n\tconst intCast = shouldCastIntTypeAsFloat(composer, type);\n\tif (intCast) {\n\t\tif (internalType === UNSIGNED_BYTE || internalType === BYTE) {\n\t\t\t// Integers between -2048 and +2048 can be exactly represented by half float.\n\t\t\tinternalType = HALF_FLOAT;\n\t\t} else {\n\t\t\t// Integers between 0 and 16777216 can be exactly represented by float32 (also applies for negative integers between 16777216 and 0)\n\t\t\t// This is sufficient for UNSIGNED_SHORT and SHORT types.\n\t\t\t// Large UNSIGNED_INT and INT cannot be represented by FLOAT type.\n\t\t\tconsole.warn(`Falling back ${internalType} type to FLOAT type for glsl1.x support for GPULayer \"${name}\".\nLarge UNSIGNED_INT or INT with absolute value > 16,777,216 are not supported, on mobile UNSIGNED_INT, INT, UNSIGNED_SHORT, and SHORT with absolute value > 2,048 may not be supported.`);\n\t\t\tinternalType = FLOAT;\n\t\t}\n\t}\n\n\t// Check if float textures supported.\n\tif (!isWebGL2) {\n\t\tif (internalType === FLOAT) {\n\t\t\t// The OES_texture_float extension implicitly enables WEBGL_color_buffer_float extension (for writing).\n\t\t\tconst extension = getExtension(composer, OES_TEXTURE_FLOAT, true);\n\t\t\tif (extension) {\n\t\t\t\t// https://stackoverflow.com/questions/17476632/webgl-extension-support-across-browsers\n\t\t\t\t// Rendering to a floating-point texture may not be supported, even if the OES_texture_float extension\n\t\t\t\t// is supported. Typically, this fails on mobile hardware. To check if this is supported, you have to\n\t\t\t\t// call the WebGL checkFramebufferStatus() function after attempting to attach texture to framebuffer.\n\t\t\t\tconst valid = testWriteSupport(composer, internalType);\n\t\t\t\tif (!valid) {\n\t\t\t\t\tconsole.warn(`FLOAT not supported for writing operations in this browser, falling back to HALF_FLOAT type for GPULayer \"${name}\".`);\n\t\t\t\t\tinternalType = HALF_FLOAT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`FLOAT not supported in this browser, falling back to HALF_FLOAT type for GPULayer \"${name}\".`);\n\t\t\t\tinternalType = HALF_FLOAT;\n\t\t\t}\n\t\t}\n\t\t// Must support at least half float if using a float type.\n\t\tif (internalType === HALF_FLOAT) {\n\t\t\t// The OES_texture_half_float extension implicitly enables EXT_color_buffer_half_float extension (for writing).\n\t\t\tgetExtension(composer, OES_TEXTURE_HALF_FLOAT, true);\n\t\t\t// FYI, very old safari issues: https://stackoverflow.com/questions/54248633/cannot-create-half-float-oes-texture-from-uint16array-on-ipad\n\t\t\tconst valid = testWriteSupport(composer, internalType);\n\t\t\t// May still be ok for read-only, but this will affect the ability to call getValues() and savePNG().\n\t\t\t// We'll let it pass for now.\n\t\t\tif (!valid) {\n\t\t\t\tconsole.warn(`This browser does not support writing to HALF_FLOAT textures.`);\n\t\t\t\t// _errorCallback(`This browser does not support writing to HALF_FLOAT textures.`);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// For writable webGL2 contexts, load EXT_color_buffer_float/EXT_color_buffer_half_float extension.\n\t\tif (internalType === FLOAT) {\n\t\t\tconst extension = getExtension(composer, EXT_COLOR_BUFFER_FLOAT, true);\n\t\t\tif (!extension) {\n\t\t\t\tconsole.warn(`FLOAT not supported in this browser, falling back to HALF_FLOAT type for GPULayer \"${name}\".`);\n\t\t\t\tinternalType = HALF_FLOAT;\n\t\t\t} else {\n\t\t\t\t// Test attaching texture to framebuffer to be sure float writing is supported.\n\t\t\t\tconst valid = testWriteSupport(composer, internalType);\n\t\t\t\tif (!valid) {\n\t\t\t\t\tconsole.warn(`FLOAT not supported for writing operations in this browser, falling back to HALF_FLOAT type for GPULayer \"${name}\".`);\n\t\t\t\t\tinternalType = HALF_FLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (internalType === HALF_FLOAT) {\n\t\t\t// On WebGL 2, EXT_color_buffer_half_float is an alternative to using the EXT_color_buffer_float extension\n\t\t\t// on platforms that support 16-bit floating point render targets but not 32-bit floating point render targets.\n\t\t\tconst halfFloatExt = getExtension(composer, EXT_COLOR_BUFFER_HALF_FLOAT, true);\n\t\t\tif (!halfFloatExt) {\n\t\t\t\t// Some versions of Firefox (e.g. Firefox v104 on Mac) do not support EXT_COLOR_BUFFER_HALF_FLOAT,\n\t\t\t\t// but EXT_COLOR_BUFFER_FLOAT will work instead.\n\t\t\t\tgetExtension(composer, EXT_COLOR_BUFFER_FLOAT, true);\n\t\t\t}\n\t\t\t// Test attaching texture to framebuffer to be sure half float writing is supported.\n\t\t\tconst valid = testWriteSupport(composer, internalType);\n\t\t\t// May still be ok for read-only, but this will affect the ability to call getValues() and savePNG().\n\t\t\t// We'll let it pass for now.\n\t\t\tif (!valid) {\n\t\t\t\tconsole.warn(`This browser does not support writing to HALF_FLOAT textures.`);\n\t\t\t\t_errorCallback(`This browser does not support writing to HALF_FLOAT textures.`);\n\t\t\t}\n\t\t}\n\t}\n\treturn internalType;\n}\n\n/**\n * Min and max values for types.\n * @private\n */\nexport function minMaxValuesForType(type: GPULayerType) {\n\t// Get min and max values for int types.\n\tlet min = -Infinity;\n\tlet max = Infinity;\n\tswitch(type) {\n\t\tcase UNSIGNED_BYTE:\n\t\t\tmin = MIN_UNSIGNED_BYTE;\n\t\t\tmax = MAX_UNSIGNED_BYTE;\n\t\t\tbreak;\n\t\tcase BYTE:\n\t\t\tmin = MIN_BYTE;\n\t\t\tmax = MAX_BYTE;\n\t\t\tbreak;\n\t\tcase UNSIGNED_SHORT:\n\t\t\tmin = MIN_UNSIGNED_SHORT;\n\t\t\tmax = MAX_UNSIGNED_SHORT;\n\t\t\tbreak;\n\t\tcase SHORT:\n\t\t\tmin = MIN_SHORT;\n\t\t\tmax = MAX_SHORT;\n\t\t\tbreak;\n\t\tcase UNSIGNED_INT:\n\t\t\tmin = MIN_UNSIGNED_INT;\n\t\t\tmax = MAX_UNSIGNED_INT;\n\t\t\tbreak;\n\t\tcase INT:\n\t\t\tmin = MIN_INT;\n\t\t\tmax = MAX_INT;\n\t\t\tbreak;\n\t}\n\treturn {\n\t\tmin, max,\n\t};\n}\n\n/**\n * Recasts typed array to match GPULayer.internalType.\n * @private\n */\nGPULayer.validateGPULayerArray = (array: GPULayerArray | number[], layer: GPULayer) => {\n\tconst { numComponents, width, height, name } = layer;\n\tconst glNumChannels = layer._glNumChannels;\n\tconst internalType = layer._internalType;\n\tconst length = layer.is1D() ? layer.length : null;\n\n\t// Check that data is correct length (user error).\n\tif (array.length !== width * height * numComponents) { // Either the correct length for WebGLTexture size\n\t\tif (!length || (length &&  array.length !== length * numComponents)) { // Of the correct length for 1D array.\n\t\t\tthrow new Error(`Invalid data length: ${array.length} for GPULayer \"${name}\" of ${length ? `length ${length} and ` : ''}dimensions: [${width}, ${height}] and numComponents: ${numComponents}.`);\n\t\t}\n\t}\n\n\t// Get array type to figure out if we need to type cast.\n\t// For webgl1.0 we may need to cast an int type to a FLOAT or HALF_FLOAT.\n\tlet shouldTypeCast = false;\n\tswitch(array.constructor) {\n\t\tcase Array:\n\t\t\tshouldTypeCast = true;\n\t\t\tbreak;\n\t\tcase Float32Array:\n\t\t\tshouldTypeCast = internalType !== FLOAT;\n\t\t\tbreak;\n\t\tcase Uint8Array:\n\t\t\tshouldTypeCast = internalType !== UNSIGNED_BYTE;\n\t\t\tbreak;\n\t\tcase Int8Array:\n\t\t\tshouldTypeCast = internalType !== BYTE;\n\t\t\tbreak;\n\t\tcase Uint16Array:\n\t\t\t// User may have converted to HALF_FLOAT already.\n\t\t\t// We need to add this check in case type is UNSIGNED_SHORT and internal type is HALF_FLOAT.\n\t\t\t// (This can happen for some WebGL1 contexts.)\n\t\t\t// if (type === HALF_FLOAT) {\n\t\t\t// \tshouldTypeCast = internalType !== HALF_FLOAT;\n\t\t\t// \t// In order to complete this, we will also need to handle converting from Uint16Array to some other type.\n\t\t\t// \t// Are there cases where HALF_FLOAT is not supported?\n\t\t\t// } else {\n\t\t\t\tshouldTypeCast = internalType !== UNSIGNED_SHORT\n\t\t\t// }\n\t\t\tbreak;\n\t\tcase Int16Array:\n\t\t\tshouldTypeCast = internalType !== SHORT;\n\t\t\tbreak;\n\t\tcase Uint32Array:\n\t\t\tshouldTypeCast = internalType !== UNSIGNED_INT;\n\t\t\tbreak;\n\t\tcase Int32Array:\n\t\t\tshouldTypeCast = internalType !== INT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid array type: ${array.constructor.name} for GPULayer \"${name}\", please use one of [${validArrayTypes.map(constructor => constructor.name).join(', ')}].`);\n\t}\n\n\t// Get min and max values for internalType.\n\tconst { min, max } = minMaxValuesForType(internalType);\n\n\t// Then check if array needs to be lengthened.\n\t// This could be because glNumChannels !== numComponents or because length !== width * height.\n\tconst arrayLength = width * height * glNumChannels;\n\tconst shouldResize = array.length !== arrayLength;\n\t\t\n\tlet validatedArray = array as GPULayerArray;\n\tif (shouldTypeCast || shouldResize) {\n\t\tvalidatedArray = GPULayer.initArrayForType(internalType, arrayLength);\n\t\t// Fill new data array with old data.\n\t\t// We have to handle the case of Float16 specially by converting data to Uint16Array.\n\t\tconst view = (internalType === HALF_FLOAT && shouldTypeCast) ? new DataView(validatedArray.buffer) : null;\n\t\tfor (let i = 0, _len = array.length / numComponents; i < _len; i++) {\n\t\t\tfor (let j = 0; j < numComponents; j++) {\n\t\t\t\tconst origValue = array[i * numComponents + j];\n\t\t\t\tlet value = origValue;\n\t\t\t\tlet clipped = false;\n\t\t\t\tif (value < min) {\n\t\t\t\t\tvalue = min;\n\t\t\t\t\tclipped = true;\n\t\t\t\t} else if (value > max) {\n\t\t\t\t\tvalue = max;\n\t\t\t\t\tclipped = true;\n\t\t\t\t}\n\t\t\t\tif (clipped) {\n\t\t\t\t\tconsole.warn(`Clipping out of range value ${origValue} to ${value} for GPULayer \"${name}\" with internal type ${internalType}.`);\n\t\t\t\t}\n\t\t\t\tconst index = i * glNumChannels + j;\n\t\t\t\tif (view) {\n\t\t\t\t\tsetFloat16(view, 2 * index, value, true);\n\t\t\t\t} else {\n\t\t\t\t\tvalidatedArray[index] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn validatedArray;\n}","import type { GPUComposer } from './GPUComposer';\nimport {\n\tFLOAT_1D_UNIFORM,\n\tFLOAT_2D_UNIFORM,\n\tFLOAT_3D_UNIFORM,\n\tFLOAT_4D_UNIFORM,\n\tINT_1D_UNIFORM,\n\tINT_2D_UNIFORM,\n\tINT_3D_UNIFORM,\n\tINT_4D_UNIFORM,\n\tUniform,\n\tUniformType,\n\tUniformInternalType,\n\tUniformValue,\n\tCompileTimeConstants,\n\tPROGRAM_NAME_INTERNAL,\n\tUINT_1D_UNIFORM,\n\tUINT_2D_UNIFORM,\n\tUINT_3D_UNIFORM,\n\tUINT_4D_UNIFORM,\n\tUniformParams,\n\tBOOL_1D_UNIFORM,\n\tBOOL_2D_UNIFORM,\n\tBOOL_3D_UNIFORM,\n\tBOOL_4D_UNIFORM,\n\tGLSL3,\n\tGPULayerState,\n\tREPEAT,\n\tLINEAR,\n\tGLSL1,\n} from './constants';\nimport {\n\tcompileShader,\n\tpreprocessFragmentShader,\n\tinitGLProgram,\n\tuniformInternalTypeForValue,\n\tisIntType,\n} from './utils';\nimport {\n\tSAMPLER2D_CAST_INT,\n\tSAMPLER2D_DIMENSIONS_UNIFORM,\n\tSAMPLER2D_FILTER,\n\tSAMPLER2D_HALF_PX_UNIFORM,\n\tSAMPLER2D_WRAP_X,\n\tSAMPLER2D_WRAP_Y,\n} from './polyfills';\nimport {\n\tisArray,\n\tisBoolean,\n\tisFiniteNumber,\n\tisInteger,\n\tisNonNegativeInteger,\n\tisObject,\n\tisString,\n} from '@amandaghassaei/type-checks';\nimport { checkRequiredKeys, checkValidKeys } from './checks';\n\nexport class GPUProgram {\n\t// Keep a reference to GPUComposer.\n\tprivate readonly _composer: GPUComposer;\n\n\t/**\n\t * Name of GPUProgram, used for error logging.\n\t */\n\treadonly name: string;\n\n\t// Compiled fragment shaders (we hang onto different versions depending on compile time constants).\n\tprivate _fragmentShaders: {[key: string]: WebGLShader} = {};\n\t// Source code for fragment shader.\n\t// Hold onto this in case we need to recompile with different #defines.\n\tprotected _fragmentShaderSource!: string;\n\t// #define variables for fragment shader program.\n\tprivate readonly _compileTimeConstants: CompileTimeConstants = {};\n\t// Uniform locations, values, and types.\n\tprivate readonly _uniforms: { [ key: string]: Uniform } = {};\n\n\t// Store WebGLProgram's - we need to compile several WebGLPrograms of GPUProgram.fragmentShader + various vertex shaders.\n\t// Each combination of vertex + fragment shader requires a separate WebGLProgram.\n\t// These programs are compiled on the fly as needed.\n\tprivate readonly _programs: {[key: string]: WebGLProgram } = {};\n\t// Reverse lookup for above.\n\tprivate readonly _programsKeyLookup = new WeakMap<WebGLProgram, string>();\n\n\t// Store the index of input sampler2D in input array.\n\tprotected readonly _samplerUniformsIndices: { name: string, inputIndex: number, shaderIndex: number }[] = [];\n\n\t/**\n\t * This is only used in cases where GLSL1 program has multiple outputs.\n\t * @private\n\t */\n\t_childPrograms?: GPUProgramChild[];\n\n\t/**\n     * Create a GPUProgram.\n     * @param composer - The current GPUComposer instance.\n     * @param params - GPUProgram parameters.\n\t * @param params.name - Name of GPUProgram, used for error logging.\n\t * @param params.fragmentShader - Fragment shader source or array of sources to be joined.\n\t * @param params.uniforms - Array of uniforms to initialize with GPUProgram.  More uniforms can be added later with GPUProgram.setUniform().\n\t * @param params.compileTimeConstants - Compile time #define constants to include with fragment shader.\n     */\n\tconstructor(\n\t\tcomposer: GPUComposer,\n\t\tparams: {\n\t\t\tname: string,\n\t\t\t// We may want to pass in an array of shader string sources, if split across several files.\n\t\t\tfragmentShader: string | string[],\n\t\t\tuniforms?: UniformParams[],\n\t\t\t// We'll allow some compile time constants to be passed in as #define to the preprocessor for the fragment shader.\n\t\t\tcompileTimeConstants?: CompileTimeConstants,\n\t\t},\n\t) {\n\t\t// Check constructor parameters.\n\t\tconst { name } = (params || {});\n\t\tif (!composer) {\n\t\t\tthrow new Error(`Error initing GPUProgram \"${name}\": must pass GPUComposer instance to GPUProgram(composer, params).`);\n\t\t}\n\t\tif (!params) {\n\t\t\tthrow new Error(`Error initing GPUProgram: must pass params to GPUProgram(composer, params).`);\n\t\t}\n\t\tif (!isObject(params)) {\n\t\t\tthrow new Error(`Error initing GPUProgram: must pass valid params object to GPUProgram(composer, params), got ${JSON.stringify(params)}.`);\n\t\t}\n\t\t// Check params keys.\n\t\tconst validKeys = ['name', 'fragmentShader', 'uniforms', 'compileTimeConstants'];\n\t\tconst requiredKeys = ['name', 'fragmentShader'];\n\t\tconst keys = Object.keys(params);\n\t\tcheckValidKeys(keys, validKeys, 'GPUProgram(composer, params)', params.name);\n\t\tcheckRequiredKeys(keys, requiredKeys, 'GPUProgram(composer, params)', params.name);\n\n\t\tconst { fragmentShader, uniforms, compileTimeConstants } = params;\n\n\t\t// Save arguments.\n\t\tthis._composer = composer;\n\t\tthis.name = name;\n\n\t\t// Preprocess fragment shader source.\n\t\tconst fragmentShaderSource = isString(fragmentShader) ?\n\t\t\t\tfragmentShader as string :\n\t\t\t\t(fragmentShader as string[]).join('\\n');\n\t\tconst { shaderSource, samplerUniforms, additionalSources } = preprocessFragmentShader(\n\t\t\tfragmentShaderSource, composer.glslVersion, name,\n\t\t);\n\t\tthis._fragmentShaderSource = shaderSource;\n\t\tsamplerUniforms.forEach((name, i) => {\n\t\t\tthis._samplerUniformsIndices.push({\n\t\t\t\tname,\n\t\t\t\tinputIndex: 0, // All uniforms default to 0.\n\t\t\t\tshaderIndex: i,\n\t\t\t});\n\t\t});\n\t\tif (this.constructor === GPUProgram) { // This is not a child program.\n\t\t\tif (additionalSources) {\n\t\t\t\tthis._childPrograms = [];\n\t\t\t\tfor (let i = 0, numChildren = additionalSources.length; i < numChildren; i++) {\n\t\t\t\t\tthis._childPrograms.push(new GPUProgramChild(composer, params, { fragmentShaderSource: additionalSources[i] }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Save compile time constants.\n\t\tif (compileTimeConstants) {\n\t\t\tthis._compileTimeConstants = { ...compileTimeConstants };\n\t\t}\n\n\t\t// Set program uniforms.\n\t\tif (uniforms) {\n\t\t\tfor (let i = 0; i < uniforms.length; i++) {\n\t\t\t\tconst { name, value, type } = uniforms[i];\n\t\t\t\tthis.setUniform(name, value, type);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Force compilation of GPUProgram with new compileTimeConstants.\n\t * @param compileTimeConstants - Compile time #define constants to include with fragment shader.\n\t */\n\trecompile(compileTimeConstants: CompileTimeConstants) {\n\t\tconst { _compileTimeConstants } = this;\n\t\t// Check if we have changed the compile-time constants.\n\t\t// compileTimeConstants may be a partial list.\n\t\tlet needsRecompile = false;\n\t\tObject.keys(compileTimeConstants).forEach(key => {\n\t\t\tif (_compileTimeConstants[key] !== compileTimeConstants[key]) {\n\t\t\t\tneedsRecompile = true;\n\t\t\t\t_compileTimeConstants[key] = compileTimeConstants[key];\n\t\t\t}\n\t\t});\n\t\tif (!needsRecompile) return;\n\t\tconst { \n\t\t\t_fragmentShaders,\n\t\t\t_programs,\n\t\t\t_programsKeyLookup,\n\t\t\t_composer,\n\t\t\t_uniforms,\n\t\t} = this;\n\t\tconst { gl } = _composer;\n\t\t// Delete cached compiled shaders and programs.\n\t\tconst programKeys = Object.keys(_programs);\n\t\tfor (let i = 0, numPrograms = programKeys.length; i < numPrograms; i++) {\n\t\t\tconst key = programKeys[i];\n\t\t\tconst program = _programs[key];\n\t\t\tgl.deleteProgram(program);\n\t\t\t_programsKeyLookup.delete(program);\n\t\t\tdelete _programs[key];\n\t\t}\n\t\tconst fragmentShaderKeys = Object.keys(_fragmentShaders);\n\t\tfor (let i = 0, numFragmentShaders = fragmentShaderKeys.length; i < numFragmentShaders; i++) {\n\t\t\tconst key = fragmentShaderKeys[i];\n\t\t\tgl.deleteShader(_fragmentShaders[key]);\n\t\t\tdelete _fragmentShaders[key];\n\t\t}\n\t\t// Delete all cached uniform locations.\n\t\tconst uniforms = Object.values(_uniforms);\n\t\tfor (let i = 0, numUniforms = uniforms.length; i < numUniforms; i++) {\n\t\t\tuniforms[i].location = {};\n\t\t}\n\n\t\tif (this._childPrograms) {\n\t\t\tfor (let i = 0, numChildren = this._childPrograms.length; i < numChildren; i++) {\n\t\t\t\tthis._childPrograms[i].recompile(compileTimeConstants);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get fragment shader for GPUProgram, compile new one if needed.\n\t * Used internally.\n\t * @private\n\t */\n\tprivate _getFragmentShader(fragmentId: string, internalCompileTimeConstants: CompileTimeConstants, ) {\n\t\tconst { _fragmentShaders } = this;\n\t\tif (_fragmentShaders[fragmentId]) {\n\t\t\t// No need to recompile.\n\t\t\treturn _fragmentShaders[fragmentId];\n\t\t}\n\n\t\tconst { _composer, name, _fragmentShaderSource, _compileTimeConstants } = this;\n\t\tconst {\n\t\t\tgl,\n\t\t\t_errorCallback,\n\t\t\tverboseLogging,\n\t\t\tglslVersion,\n\t\t\tfloatPrecision,\n\t\t\tintPrecision,\n\t\t} = _composer;\n\t\t\n\t\t// Update compile time constants.\n\t\tconst keys = Object.keys(internalCompileTimeConstants);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key = keys[i];\n\t\t\t_compileTimeConstants[key] = internalCompileTimeConstants[key];\n\t\t}\n\n\t\tif (verboseLogging) console.log(`Compiling fragment shader for GPUProgram \"${name}\" with compile time constants: ${JSON.stringify(_compileTimeConstants)}`);\n\t\tconst shader = compileShader(\n\t\t\tgl,\n\t\t\tglslVersion,\n\t\t\tintPrecision,\n\t\t\tfloatPrecision,\n\t\t\t_fragmentShaderSource,\n\t\t\tgl.FRAGMENT_SHADER,\n\t\t\tname,\n\t\t\t_errorCallback,\n\t\t\t_compileTimeConstants,\n\t\t\tObject.keys(_fragmentShaders).length === 0,\n\t\t);\n\t\tif (!shader) {\n\t\t\t_errorCallback(`Unable to compile fragment shader for GPUProgram \"${name}\".`);\n\t\t\treturn;\n\t\t}\n\t\t_fragmentShaders[fragmentId] = shader;\n\t\treturn _fragmentShaders[fragmentId];\n\t}\n\n\t/**\n\t * Get GLProgram associated with a specific vertex shader.\n\t * @private\n\t */\n\t_getProgramWithName(name: PROGRAM_NAME_INTERNAL, vertexCompileConstants: CompileTimeConstants, input: GPULayerState[]) {\n\t\tconst { _samplerUniformsIndices, _composer } = this;\n\n\t\tlet fragmentID = '';\n\t\tconst fragmentCompileConstants: CompileTimeConstants = {};\n\t\tfor (let i = 0, length = _samplerUniformsIndices.length; i < length; i++) {\n\t\t\tconst { inputIndex } = _samplerUniformsIndices[i];\n\t\t\tconst { layer } = input[inputIndex];\n\t\t\tconst {\n\t\t\t\tfilter, wrapX, wrapY, type,\n\t\t\t\t_internalFilter, _internalWrapX, _internalWrapY,\n\t\t\t} = layer;\n\t\t\tconst wrapXVal = wrapX === _internalWrapX ? 0 : (wrapX === REPEAT ? 1 : 0);\n\t\t\tconst wrapYVal = wrapY === _internalWrapY ? 0 : (wrapY === REPEAT ? 1 : 0);\n\t\t\tconst filterVal = filter === _internalFilter ? 0 : (filter === LINEAR ? 1 : 0);\n\t\t\tfragmentID += `_IN${i}_${wrapXVal}_${wrapYVal}_${filterVal}`;\n\t\t\tfragmentCompileConstants[`${SAMPLER2D_WRAP_X}${i}`] = `${wrapXVal}`;\n\t\t\tfragmentCompileConstants[`${SAMPLER2D_WRAP_Y}${i}`] = `${wrapYVal}`;\n\t\t\tfragmentCompileConstants[`${SAMPLER2D_FILTER}${i}`] = `${filterVal}`;\n\t\t\tif (_composer.glslVersion === GLSL1 && isIntType(type)) {\n\t\t\t\tfragmentCompileConstants[`${SAMPLER2D_CAST_INT}${i}`] = '1';\n\t\t\t}\n\t\t}\n\t\tconst vertexID = Object.keys(vertexCompileConstants).map(key => `_${key}_${vertexCompileConstants[key]}`).join();\n\t\tconst key = `${name}${vertexID}${fragmentID}`;\n\n\t\t// Check if we've already compiled program.\n\t\tif (this._programs[key]) return this._programs[key];\n\n\t\t// Otherwise, we need to compile a new program on the fly.\n\t\tconst { _uniforms, _programs, _programsKeyLookup } = this;\n\t\tconst { gl, _errorCallback } = _composer;\n\n\t\tconst vertexShader = _composer._getVertexShader(name, vertexID, vertexCompileConstants, this.name);\n\t\tif (vertexShader === undefined) {\n\t\t\t_errorCallback(`Unable to init vertex shader \"${name}${vertexID}\" for GPUProgram \"${this.name}\".`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst fragmentShader = this._getFragmentShader(fragmentID, fragmentCompileConstants);\n\t\tif (fragmentShader === undefined) {\n\t\t\t_errorCallback(`Unable to init fragment shader \"${fragmentID}\" for GPUProgram \"${this.name}\".`);\n\t\t\treturn;\n\t\t}\n\n\t\tconst program = initGLProgram(gl, vertexShader, fragmentShader, this.name, _errorCallback);\n\t\tif (program === undefined) {\n\t\t\tgl.deleteShader(fragmentShader);\n\t\t\t_errorCallback(`Unable to init program \"${key}\" for GPUProgram \"${this.name}\".`);\n\t\t\treturn;\n\t\t}\n\n\t\t// If we have any uniforms set for this GPUProgram, add those to WebGLProgram we just inited.\n\t\t// Set active program.\n\t\tgl.useProgram(program);\n\t\tconst uniformNames = Object.keys(_uniforms);\n\t\tfor (let i = 0; i < uniformNames.length; i++) {\n\t\t\tconst uniformName = uniformNames[i];\n\t\t\tconst uniform = _uniforms[uniformName];\n\t\t\tconst { value, type } = uniform;\n\t\t\tthis._setProgramUniform(program, key, uniformName, value, type);\n\t\t}\n\n\t\t_programs[key] = program;\n\t\t_programsKeyLookup.set(program, key);\n\t\treturn program;\n\t}\n\n\t/**\n\t * Set uniform for GLProgram.\n\t * @private\n\t */\n\tprivate _setProgramUniform(\n\t\tprogram: WebGLProgram,\n\t\tprogramName: string,\n\t\tuniformName: string,\n\t\tvalue: UniformValue,\n\t\ttype: UniformInternalType,\n\t) {\n\t\tconst { _composer, _uniforms } = this;\n\t\tconst { gl, _errorCallback, glslVersion } = _composer;\n\n\t\t// We have already set gl.useProgram(program) outside this function.\n\n\t\tconst isGLSL3 = glslVersion === GLSL3;\n\n\t\tlet location = _uniforms[uniformName]?.location[programName];\n\t\t// Init a location for WebGLProgram if needed (only do this once).\n\t\tif (location === undefined) {\n\t\t\tconst _location = gl.getUniformLocation(program, uniformName);\n\t\t\tif (_location === null) {\n\t\t\t\tconsole.warn(`Could not init uniform \"${uniformName}\" for program \"${this.name}\". Check that uniform is present in shader code, unused uniforms may be removed by compiler. Also check that uniform type in shader code matches type ${type}. Error code: ${gl.getError()}.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlocation = _location;\n\t\t\t// Save location for future use.\n\t\t\tif (_uniforms[uniformName]) {\n\t\t\t\t_uniforms[uniformName].location[programName] = location;\n\t\t\t}\n\n\t\t\t// Since this is the first time we are initing the uniform, check that type is correct.\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getUniform\n\t\t\tconst uniform = gl.getUniform(program, location);\n\t\t\tlet badType = false;\n\t\t\tif (type === BOOL_1D_UNIFORM || type === BOOL_2D_UNIFORM || type === BOOL_3D_UNIFORM || type === BOOL_4D_UNIFORM) {\n\t\t\t\tif (!isBoolean(uniform) && uniform.constructor !== Array) {\n\t\t\t\t\tbadType = true;\n\t\t\t\t}\n\t\t\t} else \n\t\t\tif (type === FLOAT_1D_UNIFORM || type === FLOAT_2D_UNIFORM || type === FLOAT_3D_UNIFORM || type === FLOAT_4D_UNIFORM) {\n\t\t\t\tif (!isFiniteNumber(uniform) && uniform.constructor !== Float32Array) {\n\t\t\t\t\tbadType = true;\n\t\t\t\t}\n\t\t\t} else if (type === INT_1D_UNIFORM || type === INT_2D_UNIFORM || type === INT_3D_UNIFORM || type === INT_4D_UNIFORM) {\n\t\t\t\tif (!isInteger(uniform) && uniform.constructor !== Int32Array) {\n\t\t\t\t\tbadType = true;\n\t\t\t\t}\n\t\t\t} else if (type === UINT_1D_UNIFORM || type === UINT_2D_UNIFORM || type === UINT_3D_UNIFORM || type === UINT_4D_UNIFORM) {\n\t\t\t\tif (!isGLSL3) {\n\t\t\t\t\t// GLSL1 does not have uint type, expect int instead.\n\t\t\t\t\tif (!isNonNegativeInteger(uniform) && uniform.constructor !== Int32Array) {\n\t\t\t\t\t\tbadType = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (!isNonNegativeInteger(uniform) && uniform.constructor !== Uint32Array) {\n\t\t\t\t\tbadType = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (badType) {\n\t\t\t\t_errorCallback(`Invalid uniform \"${uniformName}\" for program \"${this.name}\". Check that uniform type in shader code matches type ${type}, gl.getUniform(program, location) returned type: ${uniform.constructor.name}.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Set uniform.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform\n\t\tswitch (type) {\n\t\t\t// We are setting boolean uniforms with uniform[1234]i.\n\t\t\t// This suggest floats work as well, but ints seem more natural:\n\t\t\t// https://github.com/KhronosGroup/WebGL/blob/main/sdk/tests/conformance/uniforms/gl-uniform-bool.html\n\t\t\tcase BOOL_1D_UNIFORM:\n\t\t\t\tgl.uniform1i(location, value ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase BOOL_2D_UNIFORM:\n\t\t\t\tgl.uniform2i(location, (value as number[])[0] ? 1 : 0, (value as number[])[1] ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase BOOL_3D_UNIFORM:\n\t\t\t\tgl.uniform3i(location, (value as number[])[0] ? 1 : 0, (value as number[])[1] ? 1 : 0, (value as number[])[2] ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase BOOL_4D_UNIFORM:\n\t\t\t\tgl.uniform4i(location, (value as number[])[0] ? 1 : 0, (value as number[])[1] ? 1 : 0, (value as number[])[2] ? 1 : 0, (value as number[])[3] ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase FLOAT_1D_UNIFORM:\n\t\t\t\tgl.uniform1f(location, value as number);\n\t\t\t\tbreak;\n\t\t\tcase FLOAT_2D_UNIFORM:\n\t\t\t\tgl.uniform2fv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase FLOAT_3D_UNIFORM:\n\t\t\t\tgl.uniform3fv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase FLOAT_4D_UNIFORM:\n\t\t\t\tgl.uniform4fv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase INT_1D_UNIFORM:\n\t\t\t\tgl.uniform1i(location, value as number);\n\t\t\t\tbreak;\n\t\t\tcase INT_2D_UNIFORM:\n\t\t\t\tgl.uniform2iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase INT_3D_UNIFORM:\n\t\t\t\tgl.uniform3iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase INT_4D_UNIFORM:\n\t\t\t\tgl.uniform4iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\t// Uint not supported in GLSL1, use int instead.\n\t\t\tcase UINT_1D_UNIFORM:\n\t\t\t\tif (isGLSL3) (gl as WebGL2RenderingContext).uniform1ui(location, value as number);\n\t\t\t\telse gl.uniform1i(location, value as number);\n\t\t\t\tbreak;\n\t\t\tcase UINT_2D_UNIFORM:\n\t\t\t\tif (isGLSL3) (gl as WebGL2RenderingContext).uniform2uiv(location, value as number[]);\n\t\t\t\telse gl.uniform2iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase UINT_3D_UNIFORM:\n\t\t\t\tif (isGLSL3) (gl as WebGL2RenderingContext).uniform3uiv(location, value as number[]);\n\t\t\t\telse gl.uniform3iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tcase UINT_4D_UNIFORM:\n\t\t\t\tif (isGLSL3) (gl as WebGL2RenderingContext).uniform4uiv(location, value as number[]);\n\t\t\t\telse gl.uniform4iv(location, value as number[]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown uniform type ${type} for GPUProgram \"${this.name}\".`);\n\t\t}\n\t}\n\n\t/**\n\t * Set fragment shader uniform for GPUProgram.\n\t * @param name - Uniform name as it appears in fragment shader.\n\t * @param value - Uniform value.\n\t * @param type - Uniform type (this only needs to be set once).\n\t */\n\tsetUniform(\n\t\tname: string,\n\t\tvalue: UniformValue,\n\t\ttype?: UniformType,\n\t) {\n\t\tconst { _programs, _uniforms, _composer, _samplerUniformsIndices } = this;\n\t\tconst { verboseLogging, gl } = _composer;\n\n\t\t// Check that length of value is correct.\n\t\tif (isArray(value)) {\n\t\t\tconst length = (value as number[]).length;\n\t\t\tif (length > 4) throw new Error(`Invalid uniform value: [${(value as number[]).join(', ')}] passed to GPUProgram \"${this.name}, uniforms must be of type number[] with length <= 4, number, or boolean.\"`)\n\t\t}\n\n\t\tlet currentType = _uniforms[name]?.type;\n\t\tif (type) {\n\t\t\tconst internalType = uniformInternalTypeForValue(value, type, name, this.name);\n\t\t\tif (currentType === undefined) currentType = internalType;\n\t\t\telse {\n\t\t\t\t// console.warn(`Don't need to pass in type to GPUProgram.setUniform for previously inited uniform \"${uniformName}\"`);\n\t\t\t\t// Check that types match previously set uniform.\n\t\t\t\tif (currentType !== internalType) {\n\t\t\t\t\tthrow new Error(`Uniform \"${name}\" for GPUProgram \"${this.name}\" cannot change from type ${currentType} to type ${internalType}.`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (currentType === undefined) {\n\t\t\tthrow new Error(`Unknown type for uniform \"${name}\", please pass in type to GPUProgram.setUniform(name, value, type) when initing a new uniform.`);\n\t\t}\n\n\t\tif (!_uniforms[name]) {\n\t\t\t// Init uniform if needed.\n\t\t\t_uniforms[name] = { type: currentType, location: {}, value };\n\t\t} else {\n\t\t\t// Deep check if value has changed.\n\t\t\tif (isArray(value)) {\n\t\t\t\tlet isChanged = true;\n\t\t\t\tfor (let i = 0; i < (value as number[]).length; i++) {\n\t\t\t\t\tif (_uniforms[name].value !== value) {\n\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isChanged) return; // No change.\n\t\t\t} else if (_uniforms[name].value === value) {\n\t\t\t\treturn; // No change.\n\t\t\t}\n\t\t\t// Update value.\n\t\t\t_uniforms[name].value = value;\n\t\t}\n\n\t\tconst samplerUniform = _samplerUniformsIndices.find((uniform) => uniform.name === name);\n\t\tif (samplerUniform && currentType === INT_1D_UNIFORM) {\n\t\t\tsamplerUniform.inputIndex = value as number;\n\t\t}\n\n\t\tif (verboseLogging) console.log(`Setting uniform \"${name}\" for program \"${this.name}\" to value ${JSON.stringify(value)} with type ${currentType}.`)\n\n\t\t// Update any active programs.\n\t\tconst keys = Object.keys(_programs);\n\t\tfor (let i = 0, numKeys = keys.length; i < numKeys; i++) {\n\t\t\tconst programName = keys[i];\n\t\t\t// Set active program.\n\t\t\tconst program = _programs[programName]!;\n\t\t\tgl.useProgram(program);\n\t\t\tthis._setProgramUniform(program, programName, name, value, currentType);\n\t\t}\n\n\t\tif (this._childPrograms) {\n\t\t\tfor (let i = 0, numChildren = this._childPrograms.length; i < numChildren; i++) {\n\t\t\t\tthis._childPrograms[i].setUniform(name, value, type);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Set internal fragment shader uniforms for GPUProgram.\n\t * @private\n\t */\n\t_setInternalFragmentUniforms(\n\t\tprogram: WebGLProgram,\n\t\tinput: GPULayerState[],\n\t) {\n\t\tif (input.length === 0) return;\n\t\tif (!program) {\n\t\t\tthrow new Error('Must pass in valid WebGLProgram to GPUProgram._setInternalFragmentUniforms, got undefined.');\n\t\t}\n\t\tconst { _programsKeyLookup, _samplerUniformsIndices } = this;\n\t\tconst programName = _programsKeyLookup.get(program);\n\t\tif (!programName) {\n\t\t\tthrow new Error(`Could not find valid programName for WebGLProgram in GPUProgram \"${this.name}\".`);\n\t\t}\n\n\t\tconst indexLookup = new Array(_samplerUniformsIndices.length).fill(-1);\n\t\tfor (let i = 0, length = _samplerUniformsIndices.length; i < length; i++) {\n\t\t\tconst { inputIndex, shaderIndex } = _samplerUniformsIndices[i];\n\t\t\tif (indexLookup[inputIndex] >= 0) {\n\t\t\t\t// There is an index collision, this should not happen.\n\t\t\t\tconsole.warn(`Found > 1 sampler2D uniforms at texture index ${inputIndex} for GPUProgram \"${this.name}\".`);\n\t\t\t} else {\n\t\t\t\tindexLookup[inputIndex] = shaderIndex;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, length = input.length; i < length; i++) {\n\t\t\tconst { layer } = input[i];\n\t\t\tconst { width, height } = layer;\n\t\t\tconst index = indexLookup[i];\n\t\t\tif (index < 0) continue;\n\t\t\tconst { filter, wrapX, wrapY, _internalFilter, _internalWrapX, _internalWrapY } = layer;\n\t\t\tconst filterMismatch = filter !== _internalFilter;\n\t\t\tif (filterMismatch || wrapX !== _internalWrapX || wrapY !== _internalWrapY) {\n\t\t\t\tconst halfPxSize = [0.5 / width, 0.5 / height];\n\t\t\t\tconst halfPxUniform = `${SAMPLER2D_HALF_PX_UNIFORM}${index}`;\n\t\t\t\tthis._setProgramUniform(\n\t\t\t\t\tprogram,\n\t\t\t\t\tprogramName,\n\t\t\t\t\thalfPxUniform,\n\t\t\t\t\thalfPxSize,\n\t\t\t\t\tFLOAT_2D_UNIFORM,\n\t\t\t\t);\n\t\t\t\tif (filterMismatch) {\n\t\t\t\t\tconst dimensions = [width, height];\n\t\t\t\t\tconst dimensionsUniform = `${SAMPLER2D_DIMENSIONS_UNIFORM}${index}`;\n\t\t\t\t\tthis._setProgramUniform(\n\t\t\t\t\t\tprogram,\n\t\t\t\t\t\tprogramName,\n\t\t\t\t\t\tdimensionsUniform,\n\t\t\t\t\t\tdimensions,\n\t\t\t\t\t\tFLOAT_2D_UNIFORM,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set vertex shader uniform for GPUProgram.\n\t * @private\n\t */\n\t_setVertexUniform(\n\t\tprogram: WebGLProgram,\n\t\tuniformName: string,\n\t\tvalue: UniformValue,\n\t\ttype: UniformType,\n\t) {\n\t\tif (!program) {\n\t\t\tthrow new Error('Must pass in valid WebGLProgram to GPUProgram._setVertexUniform, got undefined.');\n\t\t}\n\t\tconst { _programsKeyLookup } = this;\n\t\tconst programName = _programsKeyLookup.get(program);\n\t\tif (!programName) {\n\t\t\tthrow new Error(`Could not find valid programName for WebGLProgram in GPUProgram \"${this.name}\".`);\n\t\t}\n\t\tconst internalType = uniformInternalTypeForValue(value, type, uniformName, this.name);\n\t\tthis._setProgramUniform(program, programName, uniformName, value, internalType);\n\t}\n\n\t/**\n\t * Deallocate GPUProgram instance and associated WebGL properties.\n\t */\n\tdispose() {\n\t\tconst { _composer, _fragmentShaders, _programs, _programsKeyLookup } = this;\n\t\tconst { gl, verboseLogging } = _composer;\n\n\t\tif (verboseLogging) console.log(`Deallocating GPUProgram \"${this.name}\".`);\n\t\tif (!gl) throw new Error(`Must call dispose() on all GPUPrograms before calling dispose() on GPUComposer.`);\n\n\t\t// Unbind all gl data before deleting.\n\t\tObject.values(_programs).forEach(program => {\n\t\t\tif (program) {\n\t\t\t\tgl.deleteProgram(program);\n\t\t\t\t_programsKeyLookup.delete(program);\n\t\t\t}\n\t\t});\n\t\tObject.keys(_programs).forEach(key => {\n\t\t\tdelete _programs[key as PROGRAM_NAME_INTERNAL];\n\t\t});\n\n\t\t// Delete fragment shaders.\n\t\tObject.values(_fragmentShaders).forEach(shader => {\n\t\t\tgl.deleteShader(shader);\n\t\t});\n\t\tObject.keys(_fragmentShaders).forEach(key => {\n\t\t\tdelete _fragmentShaders[key];\n\t\t});\n\n\t\tif (this._childPrograms) {\n\t\t\tfor (let i = 0, numChildren = this._childPrograms.length; i < numChildren; i++) {\n\t\t\t\tthis._childPrograms[i].dispose();\n\t\t\t}\n\t\t\tthis._childPrograms.length;\n\t\t}\n\t\tdelete this._childPrograms;\n\t\t\n\t\t// Vertex shaders are owned by GPUComposer and shared across many GPUPrograms.\n\n\t\t// Delete all references.\n\t\t// @ts-ignore\n\t\tdelete this._composer;\n\t\t// @ts-ignore\n\t\tdelete this.name;\n\t\t// @ts-ignore\n\t\tdelete this._fragmentShaderSource;\n\t\t// @ts-ignore\n\t\tdelete this._compileTimeConstants;\n\t\t// @ts-ignore\n\t\tdelete this._uniforms;\n\t\t// @ts-ignore\n\t\tdelete this._programs;\n\t\t// @ts-ignore\n\t\tdelete this._programsKeyLookup;\n\t\t// @ts-ignore\n\t\tdelete this._fragmentShaders;\n\t\t// @ts-ignore\n\t\tdelete this._samplerUniformsIndices;\n\t}\n}\n\nclass GPUProgramChild extends GPUProgram {\n\tconstructor(\n\t\tcomposer: GPUComposer,\n\t\tparams: {\n\t\t\tname: string,\n\t\t\t// We may want to pass in an array of shader string sources, if split across several files.\n\t\t\tfragmentShader: string | string[],\n\t\t\tuniforms?: UniformParams[],\n\t\t\t// We'll allow some compile time constants to be passed in as #define to the preprocessor for the fragment shader.\n\t\t\tcompileTimeConstants?: CompileTimeConstants,\n\t\t},\n\t\t_gpuio_child_params: {\n\t\t\tfragmentShaderSource: string,\n\t\t},\n\t) {\n\t\tsuper(composer, params);\n\n\t\tconst { fragmentShaderSource } = _gpuio_child_params;\n\t\t// fragmentShader has already been pre-processed.\n\t\tthis._fragmentShaderSource = fragmentShaderSource;\n\t}\n}","import { isArray } from '@amandaghassaei/type-checks';\nimport {\n\tFLOAT,\n\tGLSLPrecision,\n\tGPULayerNumComponents,\n\tGPULayerType,\n\tINT,\n} from './constants';\nimport {\n\tglslComponentSelectionForNumComponents,\n\tglslPrefixForType,\n\tglslTypeForType,\n\tuniformTypeForType,\n} from './conversions';\nimport type { GPUComposer } from './GPUComposer';\nimport { GPUProgram } from './GPUProgram';\n\n/**\n * Init GPUProgram to copy contents of one GPULayer to another GPULayer.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input/output.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the input/output.\n * @returns\n */\nexport function copyProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst glslType = glslTypeForType(type, 4);\n\tconst name = params.name ||`copy_${uniformTypeForType(type, composer.glslVersion)}_layer`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform ${precision} ${glslPrefixForType(type)}sampler2D u_state;\nout ${precision} ${glslType} out_result;\nvoid main() {\n\tout_result = texture(u_state, v_uv);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to add several GPULayers together.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the inputs/output.\n * @param params.components - Component(s) of inputs to add, defaults to 'xyzw.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.numInputs - The number of inputs to add together, defaults to 2.\n * @param params.precision - Optionally specify the precision of the inputs/output.\n * @returns\n */\n export function addLayersProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tcomponents?: string,\n\tname?: string,\n\tnumInputs?: number,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst numInputs = params.numInputs || 2;\n\tconst precision = params.precision || '';\n\tconst components = params.components || 'xyzw';\n\tconst glslType = glslTypeForType(type, components.length as GPULayerNumComponents);\n\tconst arrayOfLengthNumInputs = new Array(numInputs);\n\tconst name = params.name || `${numInputs}-way_add_${uniformTypeForType(type, composer.glslVersion)}_${components}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\n${ arrayOfLengthNumInputs.map((el, i) => `uniform ${precision} ${glslPrefixForType(type)}sampler2D u_state${i};`).join('\\n') }\nout ${precision} ${glslType} out_result;\nvoid main() {\n\tout_result = ${ arrayOfLengthNumInputs.map((el, i) => `texture(u_state${i}, v_uv).${components}`).join(' + ') };\n}`,\n\t\tuniforms: arrayOfLengthNumInputs.map((el, i) => {\n\t\t\treturn {\n\t\t\t\tname: `u_state${i}`,\n\t\t\t\tvalue: i,\n\t\t\t\ttype: INT,\n\t\t\t};\n\t\t}),\n\t});\n}\n\n/**\n * Init GPUProgram to add uniform \"u_value\" to a GPULayer.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input/output (we assume \"u_value\" has the same type).\n * @param params.value - Initial value to add, if value has length 1 it will be applied to all components of GPULayer.  Change this later using uniform \"u_value\".\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the input/output/\"u_value\".\n * @returns\n */\n export function addValueProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tvalue: number | number[],\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type, value } = params;\n\tconst precision = params.precision || '';\n\tconst valueLength = isArray(value) ? (value as number[]).length : 1;\n\tconst valueType = glslTypeForType(type, valueLength as GPULayerNumComponents);\n\tconst numComponents = valueLength === 1 ? 4 : valueLength;\n\tconst outputType = glslTypeForType(type, numComponents as GPULayerNumComponents);\n\tconst componentSelection = glslComponentSelectionForNumComponents(numComponents as GPULayerNumComponents);\n\tconst name = params.name || `addValue_${valueType}_w_length_${valueLength}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform ${precision} ${valueType} u_value;\nuniform ${precision} ${glslPrefixForType(type)}sampler2D u_state;\nout ${precision} ${outputType} out_result;\nvoid main() {\n\tout_result = ${valueType !== outputType ? outputType : ''}(u_value) + texture(u_state, v_uv)${componentSelection};\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_value',\n\t\t\t\tvalue,\n\t\t\t\ttype: uniformTypeForType(type, composer.glslVersion),\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to multiply uniform \"u_value\" to a GPULayer.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input/output (we assume \"u_value\" has the same type).\n * @param params.value - Initial value to multiply, if value has length 1 it will be applied to all components of GPULayer.  Change this later using uniform \"u_value\".\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the input/output/\"u_value\".\n * @returns\n */\n export function multiplyValueProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tvalue: number | number[],\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type, value } = params;\n\tconst precision = params.precision || '';\n\tconst valueLength = isArray(value) ? (value as number[]).length : 1;\n\tconst valueType = glslTypeForType(type, valueLength as GPULayerNumComponents);\n\tconst numComponents = valueLength === 1 ? 4 : valueLength;\n\tconst outputType = glslTypeForType(type, numComponents as GPULayerNumComponents);\n\tconst componentSelection = glslComponentSelectionForNumComponents(numComponents as GPULayerNumComponents);\n\tconst name = params.name || `addValue_${valueType}_w_length_${valueLength}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform ${precision} ${valueType} u_value;\nuniform ${precision} ${glslPrefixForType(type)}sampler2D u_state;\nout ${precision} ${outputType} out_result;\nvoid main() {\n\tout_result = ${valueType !== outputType ? outputType : ''}(u_value) * texture(u_state, v_uv)${componentSelection};\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_value',\n\t\t\t\tvalue,\n\t\t\t\ttype: uniformTypeForType(type, composer.glslVersion),\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to set all elements in a GPULayer to uniform \"u_value\".\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the output (we assume \"u_value\" has same type).\n * @param params.value - Initial value to set, if value has length 1 it will be applied to all components of GPULayer.  Change this later using uniform \"u_value\".\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the output/\"u_value\".\n * @returns\n */\nexport function setValueProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tvalue: number | number[],\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type, value } = params;\n\tconst precision = params.precision || '';\n\tconst valueLength = isArray(value) ? (value as number[]).length : 1;\n\tconst valueType = glslTypeForType(type, valueLength as GPULayerNumComponents);\n\tconst numComponents = valueLength === 1 ? 4 : valueLength;\n\tconst outputType = glslTypeForType(type, numComponents as GPULayerNumComponents);\n\tconst name = params.name || `setValue_${valueType}_w_length_${valueLength}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nuniform ${precision} ${valueType} u_value;\nout ${precision} ${outputType} out_result;\nvoid main() {\n\tout_result = ${valueType !== outputType ? outputType : ''}(u_value);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_value',\n\t\t\t\tvalue,\n\t\t\t\ttype: uniformTypeForType(type, composer.glslVersion),\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to set all elements in a GPULayer to uniform \"u_value\".\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the output.\n * @param params.color - Initial color as RGB in range [0, 1], defaults to [0, 0, 0].  Change this later using uniform \"u_color\".\n * @param params.opacity - Initial opacity in range [0, 1], defaults to 1.  Change this later using uniform \"u_opacity\".\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.precision - Optionally specify the precision of the output/uniforms.\n * @returns\n */\n export function setColorProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tcolor?: number[],\n\topacity?: number,\n\tname?: string,\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst opacity = params.opacity === undefined ? 1 : params.opacity;\n\tconst color = params.color || [0, 0, 0];\n\tconst name = params.name || `setColor`;\n\tconst glslType = glslTypeForType(type, 4);\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nuniform ${precision} vec3 u_color;\nuniform ${precision} float u_opacity;\nout ${precision} ${glslType} out_result;\nvoid main() {\n\tout_result = ${glslType}(u_color, u_opacity);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_color',\n\t\t\t\tvalue: color,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_opacity',\n\t\t\t\tvalue: opacity,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to zero output GPULayer.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @returns\n */\n export function zeroProgram(composer: GPUComposer, params: {\n\tname?: string,\n}) {\n\treturn setValueProgram(composer, {\n\t\ttype: FLOAT,\n\t\tvalue: 0,\n\t\tname: params.name,\n\t});\n}\n\n/**\n * Init GPUProgram to render RGBA amplitude of an input GPULayer's components, defaults to grayscale rendering and works for scalar and vector fields.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input.\n * @param params.components - Component(s) of input GPULayer to render, defaults to 'xyzw'.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.scale - Scaling factor, defaults to 1.  Change this later using uniform \"u_scale\".\n * @param params.opacity - Opacity, defaults to 1.  Change this later using uniform \"u_opacity\".\n * @param params.color - RGB color for non-zero amplitudes, scaled to [-0,1] range, defaults to white.  Change this later using uniform \"u_color\".\n * @param params.colorZero - RGB color for zero amplitudes, scaled to [-0,1] range, defaults to black.  Change this later using uniform \"u_colorZero\".\n * @param params.precision - Optionally specify the precision of the input.\n * @returns\n */\n export function renderAmplitudeProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tcomponents?: string,\n\tname?: string,\n\tscale?: number,\n\topacity?: number,\n\tcolor?: number[],\n\tcolorZero: number[],\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst components = params.components || 'xyzw';\n\tconst numComponents = components.length as GPULayerNumComponents;\n\tconst glslType = glslTypeForType(type, numComponents);\n\tconst glslFloatType = glslTypeForType(FLOAT, numComponents);\n\tconst glslPrefix = glslPrefixForType(type);\n\tconst shouldCast = glslFloatType === glslType;\n\tconst name = params.name || `renderAmplitude_${glslType}_w_${numComponents}_components`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform float u_opacity;\nuniform float u_scale;\nuniform vec3 u_color;\nuniform vec3 u_colorZero;\nuniform ${precision} ${glslPrefix}sampler2D u_state;\nout vec4 out_result;\nvoid main() {\n\tfloat amplitude = u_scale * ${ numComponents === 1 ? 'abs' : 'length'}(${shouldCast ? '' : glslFloatType}(texture(u_state, v_uv)${components === 'xyzw' || components === 'rgba' || components === 'stpq' ? '' : `.${components}`}));\n\tvec3 color = mix(u_colorZero, u_color, amplitude);\n\tout_result = vec4(color, u_opacity);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_scale',\n\t\t\t\tvalue: params.scale !== undefined ? params.scale : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_opacity',\n\t\t\t\tvalue: params.opacity !== undefined ? params.opacity : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_color',\n\t\t\t\tvalue: params.color || [1, 1, 1],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorZero',\n\t\t\t\tvalue: params.colorZero || [0, 0, 0],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * Init GPUProgram to render signed amplitude of an input GPULayer to linearly interpolated colors.\n * @category GPUProgram Helper\n * @param composer - The current GPUComposer.\n * @param params - Program parameters.\n * @param params.type - The type of the input.\n * @param params.name - Optionally pass in a GPUProgram name, used for error logging.\n * @param params.scale - Scaling factor, defaults to 1.  Change this later using uniform \"u_scale\".\n * @param params.opacity - Opacity, defaults to 1.  Change this later using uniform \"u_opacity\".\n * @param params.colorNegative - RGB color for negative amplitudes, scaled to [-0,1] range, defaults to blue.  Change this later using uniform \"u_colorNegative\".\n * @param params.colorPositive - RGB color for positive amplitudes, scaled to [-0,1] range, defaults to red.  Change this later using uniform \"u_colorPositive\".\n * @param params.colorZero - RGB color for zero amplitudes, scaled to [-0,1] range, defaults to white.  Change this later using uniform \"u_colorZero\".\n * @param params.component - Component of input GPULayer to render, defaults to \"x\".\n * @param params.precision - Optionally specify the precision of the input.\n * @returns\n */\n export function renderSignedAmplitudeProgram(composer: GPUComposer, params: {\n\ttype: GPULayerType,\n\tcomponent?: 'x' | 'y' | 'z' | 'w',\n\tname?: string,\n\tscale?: number,\n\topacity?: number,\n\tcolorNegative?: number[],\n\tcolorPositive?: number[],\n\tcolorZero?: number[],\n\tprecision?: GLSLPrecision,\n}) {\n\tconst { type } = params;\n\tconst precision = params.precision || '';\n\tconst glslType = glslTypeForType(type, 1);\n\tconst glslPrefix = glslPrefixForType(type);\n\tconst castFloat = glslType === 'float';\n\tconst component = params.component || 'x';\n\tconst name = params.name || `renderAmplitude_${glslType}_${component}`;\n\treturn new GPUProgram(composer, {\n\t\tname,\n\t\tfragmentShader: `\nin vec2 v_uv;\nuniform float u_opacity;\nuniform float u_scale;\nuniform vec3 u_colorNegative;\nuniform vec3 u_colorPositive;\nuniform vec3 u_colorZero;\nuniform ${precision} ${glslPrefix}sampler2D u_state;\nout vec4 out_result;\nvoid main() {\n\tfloat signedAmplitude = u_scale * ${castFloat ? '' : 'float'}(texture(u_state, v_uv).${component});\n\tfloat amplitudeSign = sign(signedAmplitude);\n\tvec3 interpColor = mix(u_colorNegative, u_colorPositive, amplitudeSign / 2.0 + 0.5);\n\tvec3 color = mix(u_colorZero, interpColor, signedAmplitude * amplitudeSign);\n\tout_result = vec4(color, u_opacity);\n}`,\n\t\tuniforms: [\n\t\t\t{\n\t\t\t\tname: 'u_state',\n\t\t\t\tvalue: 0,\n\t\t\t\ttype: INT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_scale',\n\t\t\t\tvalue: params.scale !== undefined ? params.scale : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_opacity',\n\t\t\t\tvalue: params.opacity !== undefined ? params.opacity : 1,\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorNegative',\n\t\t\t\tvalue: params.colorNegative || [0, 0, 1],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorPositive',\n\t\t\t\tvalue: params.colorPositive || [1, 0, 0],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'u_colorZero',\n\t\t\t\tvalue: params.colorZero || [1, 1, 1],\n\t\t\t\ttype: FLOAT,\n\t\t\t},\n\t\t],\n\t});\n}\n\n/**\n * @private\n */\nexport function wrappedLineColorProgram(composer: GPUComposer) {\n\treturn new GPUProgram(composer, {\n\t\tname: `wrappedLineColor`,\n\t\tfragmentShader: `\nin vec2 v_lineWrapping;\nuniform vec4 u_value;\nout vec4 out_result;\nvoid main() {\n\t// Check if this line has wrapped.\n\tif ((v_lineWrapping.x != 0.0 && v_lineWrapping.x != 1.0) || (v_lineWrapping.y != 0.0 && v_lineWrapping.y != 1.0)) {\n\t\t// Render nothing.\n\t\tdiscard;\n\t\treturn;\n\t}\n\tout_result = vec4(u_value);\n}`,\n\t});\n}\n","/**\n * These are the parts of threejs Vector4 that we need.\n * Used internally.\n * @private\n */\nexport class Vector4 {\n\tx: number;\n\ty: number;\n\tz: number;\n\tw: number;\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t}\n\tget width() {\n\t\treturn this.z;\n\t}\n\tget height() {\n\t\treturn this.w;\n\t}\n\tcopy(v: Vector4) {\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = v.w;\n\t\treturn this;\n\t}\n}","import {\n\tisArray,\n\tisFiniteNumber,\n\tisInteger,\n\tisNonNegativeInteger,\n} from '@amandaghassaei/type-checks';\nimport {\n\tvalidDataTypes,\n\tvalidFilters,\n\tvalidWraps,\n\tGPULayerType,\n\tHALF_FLOAT,\n\tFLOAT,\n\tBYTE,\n\tSHORT,\n\tINT,\n\tUNSIGNED_BYTE,\n\tUNSIGNED_SHORT,\n\tUNSIGNED_INT,\n\tvalidImageFormats,\n\tvalidImageTypes,\n} from './constants';\n\n/**\n * Checks if type is valid GPULayer data type.\n * @private\n */\nexport function isValidDataType(type: string) {\n\treturn validDataTypes.indexOf(type) > -1;\n}\n\n/**\n * Checks if filter is valid GPULayer filter type.\n * @private\n */\nexport function isValidFilter(type: string) {\n\treturn validFilters.indexOf(type) > -1;\n}\n\n/**\n * Checks if wrap is valid GPULayer wrap type.\n * @private\n */\nexport function isValidWrap(type: string) {\n\treturn validWraps.indexOf(type) > -1;\n}\n\n/**\n * For image urls that are passed in and inited as GPULayers.\n * @private\n */\nexport function isValidImageFormat(type: string) {\n\treturn validImageFormats.indexOf(type) > -1;\n}\n/**\n * For image urls that are passed in and inited as GPULayers.\n * @private\n */\nexport function isValidImageType(type: string) {\n\treturn validImageTypes.indexOf(type) > -1;\n}\n\n/**\n * Checks if value is valid GPULayer clear value for numComponents and type.\n * @private\n */\nexport function isValidClearValue(clearValue: number | number[], numComponents: number, type: GPULayerType) {\n\tif (isArray(clearValue)) {\n\t\t// Length of clearValue must match numComponents.\n\t\tif ((clearValue as number[]).length !== numComponents) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < (clearValue as number[]).length; i++) {\n\t\t\tif (!isNumberOfType((clearValue as number[])[i], type)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!isNumberOfType(clearValue, type)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Checks if value is valid number for a given GPULayer type.\n * Checks extrema values.\n * @private\n */\nexport function isNumberOfType(value: any, type: GPULayerType) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\tcase FLOAT:\n\t\t\treturn isFiniteNumber(value);\n\t\tcase BYTE:\n\t\t\t// -(2 ** 7)\n\t\t\tif (value < -128) return false;\n\t\t\t// 2 ** 7 - 1\n\t\t\tif (value > 127) return false;\n\t\t\treturn isInteger(value);\n\t\tcase SHORT:\n\t\t\t// -(2 ** 15)\n\t\t\tif (value < -32768) return false;\n\t\t\t// 2 ** 15 - 1\n\t\t\tif (value > 32767) return false;\n\t\t\treturn isInteger(value);\n\t\tcase INT:\n\t\t\t// -(2 ** 31)\n\t\t\tif (value < -2147483648) return false;\n\t\t\t// 2 ** 31 - 1\n\t\t\tif (value > 2147483647) return false;\n\t\t\treturn isInteger(value);\n\t\tcase UNSIGNED_BYTE:\n\t\t\t// 2 ** 8 - 1\n\t\t\tif (value > 255) return false;\n\t\t\treturn isNonNegativeInteger(value);\n\t\tcase UNSIGNED_SHORT:\n\t\t\t// 2 ** 16 - 1\n\t\t\tif (value > 65535) return false;\n\t\t\treturn isNonNegativeInteger(value);\n\t\tcase UNSIGNED_INT:\n\t\t\t// 2 ** 32 - 1\n\t\t\tif (value > 4294967295) return false;\n\t\t\treturn isNonNegativeInteger(value);\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown type ${type}`);\n\t}\n}\n\nexport function checkValidKeys(keys: string[], validKeys: string[], methodName: string, name?: string) {\n\tkeys.forEach(key => {\n\t\tif (validKeys.indexOf(key) < 0) {\n\t\t\tthrow new Error(`Invalid params key \"${key}\" passed to ${methodName}${name ? ` with name \"${name}\"` : ''}.  Valid keys are ${JSON.stringify(validKeys)}.`);\n\t\t}\n\t});\n}\n\nexport function checkRequiredKeys(keys: string[], requiredKeys: string[], methodName: string, name?: string) {\n\trequiredKeys.forEach(key => {\n\t\tif (keys.indexOf(key) < 0) {\n\t\t\tthrow new Error(`Required params key \"${key}\" was not passed to ${methodName}${name ? ` with name \"${name}\"` : ''}.`);\n\t\t}\n\t});\n}","import type { GPULayer } from './GPULayer';\n\n// Data types and constants.\n\n/**\n * Half float data type.\n */\nexport const HALF_FLOAT = 'HALF_FLOAT';\n/**\n * Float data type.\n */\nexport const FLOAT = 'FLOAT';\n/**\n * Unsigned byte data type.\n */\nexport const UNSIGNED_BYTE = 'UNSIGNED_BYTE';\n/**\n * Byte data type.\n */\nexport const BYTE = 'BYTE';\n/**\n * Unsigned short data type.\n */\nexport const UNSIGNED_SHORT = 'UNSIGNED_SHORT';\n/**\n * Short data type.\n */\nexport const SHORT = 'SHORT';\n/**\n * Unsigned int data type.\n */\nexport const UNSIGNED_INT = 'UNSIGNED_INT';\n/**\n * Int data type.\n */\nexport const INT = 'INT';\n/**\n * Boolean data type (GPUProgram uniforms only).\n */\nexport const BOOL = 'BOOL';\n/**\n * Unsigned int data type (GPUProgram uniforms only).\n */\nexport const UINT = 'UINT';\n\n// Filter types.\n/**\n * Nearest texture filtering.\n */\nexport const NEAREST = 'NEAREST';\n/**\n * Linear texture filtering.\n */\nexport const LINEAR = 'LINEAR';\n\n// Wrap types.\n/**\n * Clamp to edge wrapping (no wrapping).\n */\nexport const CLAMP_TO_EDGE = 'CLAMP_TO_EDGE';\n/**\n * Repeat/periodic wrapping.\n */\nexport const REPEAT = 'REPEAT';\n// export const MIRRORED_REPEAT = 'MIRRORED_REPEAT';\n\n// GPULayer parameter types.\n/**\n * GPULayer array types.\n */\nexport type GPULayerArray =  Float32Array | Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array;\n/**\n * @private\n */\nexport const validArrayTypes = [Float32Array, Uint8Array, Int8Array, Uint16Array, Int16Array, Uint32Array, Int32Array, Array];\n/**\n * GPULayer data types.\n */\nexport type GPULayerType = typeof HALF_FLOAT | typeof FLOAT | typeof UNSIGNED_BYTE | typeof BYTE | typeof UNSIGNED_SHORT | typeof SHORT | typeof UNSIGNED_INT | typeof INT;\n/**\n * @private\n */\nexport const validDataTypes = [HALF_FLOAT, FLOAT, UNSIGNED_BYTE, BYTE, UNSIGNED_SHORT, SHORT, UNSIGNED_INT, INT];\n/**\n * GPULayer numComponents options.\n */\nexport type GPULayerNumComponents = 1 | 2 | 3 | 4;\n/**\n * GPULayer filter/interpolation types.\n */\nexport type GPULayerFilter = typeof LINEAR | typeof NEAREST;\n/**\n * @private\n */\nexport const validFilters = [NEAREST, LINEAR];\n/**\n * @private\n */\n/**\n * GPULayer wrap types.\n */\nexport type GPULayerWrap = typeof REPEAT | typeof CLAMP_TO_EDGE;// | typeof MIRRORED_REPEAT;\n/**\n * @private\n */\nexport const validWraps = [CLAMP_TO_EDGE, REPEAT]; // MIRRORED_REPEAT\n/**\n * The WebGLTexture corresponding to a GPULayer buffer (e.g. currentState or lastState).\n * This data structure also includes a reference back to the GPULayer that it originated from.\n */\nexport type GPULayerState = {\n\ttexture: WebGLTexture,\n\tlayer: GPULayer,\n}\n\n// For image urls that are passed in and inited as textures.\n/**\n * RGB image format.\n */\nexport const RGB = 'RGB';\n/**\n * RGBA image format.\n */\nexport const RGBA = 'RGBA';\n/**\n * Image formats for GPULayer.initFromImage().\n */\nexport type ImageFormat = typeof RGB | typeof RGBA;\n/**\n * Image types for GPULayer.initFromImage().\n */\n export type ImageType = typeof UNSIGNED_BYTE | typeof FLOAT | typeof HALF_FLOAT;\n/**\n * @private\n */\nexport const validImageFormats = [RGB, RGBA];\n/**\n * @private\n */\n export const validImageTypes = [UNSIGNED_BYTE, FLOAT, HALF_FLOAT];\n\n// GLSL versions.\n/**\n * GLSL version 300 (WebGL2 only).\n */\nexport const GLSL3 = '300 es';\n/**\n * GLSL version 100 (WebGL1 and WebGL2).\n */\nexport const GLSL1 = '100';\n/**\n * GLSL available versions.\n */\nexport type GLSLVersion = typeof GLSL1 | typeof GLSL3;\n\n// WebGL versions.\n/**\n * WebGL2 context ID.\n */\nexport const WEBGL2 = 'webgl2';\n/**\n * WebGL1 context ID.\n */\nexport const WEBGL1 = 'webgl';\n/**\n * Experimental WebGL context ID.\n */\nexport const EXPERIMENTAL_WEBGL = 'experimental-webgl';\n/**\n * Experimental WebGL context ID.\n */\n export const EXPERIMENTAL_WEBGL2 = 'experimental-webgl2';\n\n// Precision declarations.\n/**\n * GLSL lowp precision declaration.\n */\nexport const PRECISION_LOW_P = 'lowp';\n/**\n * GLSL mediump precision declaration.\n */\nexport const PRECISION_MEDIUM_P = 'mediump';\n/**\n * GLSL highp precision declaration.\n */\nexport const PRECISION_HIGH_P = 'highp';\n/**\n * GLSL available precision declarations.\n */\nexport type GLSLPrecision = typeof PRECISION_LOW_P | typeof PRECISION_MEDIUM_P | typeof PRECISION_HIGH_P;\n\n// Uniform types.\n/**\n * @private\n */\nexport const FLOAT_1D_UNIFORM = 'FLOAT_1D_UNIFORM';\n/**\n * @private\n */\nexport const FLOAT_2D_UNIFORM = 'FLOAT_2D_UNIFORM';\n/**\n * @private\n */\nexport const FLOAT_3D_UNIFORM = 'FLOAT_3D_UNIFORM';\n/**\n * @private\n */\nexport const FLOAT_4D_UNIFORM = 'FLOAT_4D_UNIFORM';\n/**\n * @private\n */\nexport const INT_1D_UNIFORM = 'INT_1D_UNIFORM';\n/**\n * @private\n */\nexport const INT_2D_UNIFORM = 'INT_2D_UNIFORM';\n/**\n * @private\n */\nexport const INT_3D_UNIFORM = 'INT_3D_UNIFORM';\n/**\n * @private\n */\nexport const INT_4D_UNIFORM = 'INT_4D_UNIFORM';\n/**\n * @private\n */\nexport const UINT_1D_UNIFORM = 'UINT_1D_UNIFORM';\n/**\n * @private\n */\nexport const UINT_2D_UNIFORM = 'UINT_2D_UNIFORM';\n/**\n * @private\n */\nexport const UINT_3D_UNIFORM = 'UINT_3D_UNIFORM';\n/**\n * @private\n */\nexport const UINT_4D_UNIFORM = 'UINT_4D_UNIFORM';\n/**\n * @private\n */\n export const BOOL_1D_UNIFORM = 'BOOL_1D_UNIFORM';\n /**\n * @private\n */\n  export const BOOL_2D_UNIFORM = 'BOOL_2D_UNIFORM';\n  /**\n * @private\n */\n export const BOOL_3D_UNIFORM = 'BOOL_3D_UNIFORM';\n /**\n * @private\n */\n  export const BOOL_4D_UNIFORM = 'BOOL_4D_UNIFORM';\n\n// Uniform types and values.\n/**\n * GPUProgram uniform types.\n */\nexport type UniformType = typeof FLOAT | typeof INT | typeof UINT | typeof BOOL;\n/**\n * @private\n */\nexport type UniformInternalType = \n\ttypeof BOOL_1D_UNIFORM |\n\ttypeof BOOL_2D_UNIFORM |\n\ttypeof BOOL_3D_UNIFORM |\n\ttypeof BOOL_4D_UNIFORM |\n\ttypeof FLOAT_1D_UNIFORM |\n\ttypeof FLOAT_2D_UNIFORM |\n\ttypeof FLOAT_3D_UNIFORM |\n\ttypeof FLOAT_4D_UNIFORM |\n\ttypeof INT_1D_UNIFORM |\n\ttypeof INT_2D_UNIFORM |\n\ttypeof INT_3D_UNIFORM |\n\ttypeof INT_4D_UNIFORM |\n\ttypeof UINT_1D_UNIFORM |\n\ttypeof UINT_2D_UNIFORM |\n\ttypeof UINT_3D_UNIFORM |\n\ttypeof UINT_4D_UNIFORM;\n/**\n * GPUProgram uniform values.\n */\nexport type UniformValue = boolean | boolean[] | number | number[];\n/**\n * GPUProgram uniform parameters.\n */\nexport type UniformParams = {\n\tname: string,\n\tvalue: UniformValue,\n\ttype: UniformType,\n};\n/**\n * @private\n */\nexport type Uniform = { \n\tlocation: { [key: string]: WebGLUniformLocation },\n\ttype: UniformInternalType,\n\tvalue: UniformValue,\n};\n\n// Vertex shader types.\n/**\n * @private\n */\nexport const DEFAULT_PROGRAM_NAME = 'DEFAULT';\n/**\n * @private\n */\nexport const SEGMENT_PROGRAM_NAME = 'SEGMENT';\n/**\n * @private\n */\nexport const LAYER_POINTS_PROGRAM_NAME = 'LAYER_POINTS';\n/**\n * @private\n */\nexport const LAYER_LINES_PROGRAM_NAME = 'LAYER_LINES';\n/**\n * @private\n */\nexport const LAYER_VECTOR_FIELD_PROGRAM_NAME = 'LAYER_VECTOR_FIELD';\n// Vertex shader compile time constants.\n/**\n * @private\n */\nexport const GPUIO_VS_WRAP_X = 'GPUIO_VS_WRAP_X';\n/**\n * @private\n */\nexport const GPUIO_VS_WRAP_Y = 'GPUIO_VS_WRAP_Y';\n/**\n * @private\n */\n export const GPUIO_VS_INDEXED_POSITIONS = 'GPUIO_VS_INDEXED_POSITIONS';\n/**\n * @private\n */\nexport const GPUIO_VS_UV_ATTRIBUTE = 'GPUIO_VS_UV_ATTRIBUTE';\n /**\n * @private\n */\nexport const GPUIO_VS_NORMAL_ATTRIBUTE = 'GPUIO_VS_NORMAL_ATTRIBUTE';\n/**\n * @private\n */\nexport const GPUIO_VS_POSITION_W_ACCUM = 'GPUIO_VS_POSITION_W_ACCUM';\n\n/**\n * @private\n */\nexport type PROGRAM_NAME_INTERNAL =\n\ttypeof DEFAULT_PROGRAM_NAME |\n\ttypeof SEGMENT_PROGRAM_NAME |\n\ttypeof LAYER_POINTS_PROGRAM_NAME |\n\ttypeof LAYER_LINES_PROGRAM_NAME |\n\ttypeof LAYER_VECTOR_FIELD_PROGRAM_NAME;\n\n// Pass in #defines as strings to make it easier to control float vs int.\n/**\n * Object containing compile time #define constants for GPUProgram fragment shader.\n */\nexport type CompileTimeConstants = { [key: string]: string };\n\n// Error callback, defaults to throwing an error.\nexport type ErrorCallback = (message: string) => void;\n/**\n * @private\n */\nexport const DEFAULT_ERROR_CALLBACK = (message: string) => { throw new Error(message); };\n\n// For stepCircle() and stepSegment() (with end caps).\n/**\n * @private\n */\nexport const DEFAULT_CIRCLE_NUM_SEGMENTS = 18;// Must be divisible by 6 to work with stepSegment().\n\n// Extrema values.\n/**\n * @private\n */\nexport const MIN_UNSIGNED_BYTE = 0;\n/**\n * @private\n */\nexport const MAX_UNSIGNED_BYTE = 2 ** 8 - 1;\n/**\n * @private\n */\nexport const MIN_BYTE = -(2 ** 7);\n/**\n * @private\n */\nexport const MAX_BYTE = 2 ** 7 - 1;\n/**\n * @private\n */\nexport const MIN_UNSIGNED_SHORT = 0;\n/**\n * @private\n */\nexport const MAX_UNSIGNED_SHORT = 2 ** 16 - 1;\n/**\n * @private\n */\nexport const MIN_SHORT = -(2 ** 15);\n/**\n * @private\n */\nexport const MAX_SHORT = 2 ** 15 - 1;\n/**\n * @private\n */\nexport const MIN_UNSIGNED_INT = 0;\n/**\n * @private\n */\nexport const MAX_UNSIGNED_INT = 2 ** 32 - 1;\n/**\n * @private\n */\nexport const MIN_INT = -(2 ** 31);\n/**\n * @private\n */\nexport const MAX_INT = 2 ** 31 - 1;\n// There are larger HALF_FLOAT and FLOAT ints, but they may be spaced out by > 1.\n/**\n * @private\n */\nexport const MIN_HALF_FLOAT_INT = -2048;\n/**\n * @private\n */\nexport const MAX_HALF_FLOAT_INT = 2048;\n/**\n * @private\n */\nexport const MIN_FLOAT_INT = -16777216;\n/**\n * @private\n */\nexport const MAX_FLOAT_INT = 16777216;\n\n// Precision compile time constants\n/**\n * @private\n */\nexport const GPUIO_INT_PRECISION = 'GPUIO_INT_PRECISION';\n/**\n * @private\n */\nexport const GPUIO_FLOAT_PRECISION = 'GPUIO_FLOAT_PRECISION';\n\nexport const BOUNDARY_TOP = 'BOUNDARY_TOP';\nexport const BOUNDARY_BOTTOM = 'BOUNDARY_BOTTOM';\nexport const BOUNDARY_LEFT = 'BOUNDARY_LEFT';\nexport const BOUNDARY_RIGHT = 'BOUNDARY_RIGHT';\nexport type BoundaryEdge = typeof BOUNDARY_TOP | typeof BOUNDARY_BOTTOM | typeof BOUNDARY_LEFT | typeof BOUNDARY_RIGHT;","import {\n\tBYTE,\n\tFLOAT,\n\tGLSL1,\n\tGLSLPrecision,\n\tGLSLVersion,\n\tGPULayerNumComponents,\n\tGPULayerType,\n\tHALF_FLOAT,\n\tINT,\n\tPRECISION_HIGH_P,\n\tPRECISION_LOW_P,\n\tPRECISION_MEDIUM_P,\n\tSHORT,\n\tUINT,\n\tUNSIGNED_BYTE,\n\tUNSIGNED_INT,\n\tUNSIGNED_SHORT,\n} from './constants';\n\n/**\n * Enum for precision values.\n * See src/glsl/common/precision.ts for more info.\n * @private\n */\n export function intForPrecision(precision: GLSLPrecision) {\n\tif (precision === PRECISION_HIGH_P) return 2;\n\tif (precision === PRECISION_MEDIUM_P) return 1;\n\tif (precision === PRECISION_LOW_P) return 0;\n\tthrow new Error(`Unknown shader precision value: ${JSON.stringify(precision)}.`);\n}\n\n/**\n * @private\n */\nexport function uniformTypeForType(type: GPULayerType, glslVersion: GLSLVersion) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\tcase FLOAT:\n\t\t\treturn FLOAT;\n\t\tcase UNSIGNED_BYTE:\n\t\tcase UNSIGNED_SHORT:\n\t\tcase UNSIGNED_INT:\n\t\t\tif (glslVersion === GLSL1) return INT;\n\t\t\treturn UINT;\n\t\tcase BYTE:\n\t\tcase SHORT:\n\t\tcase INT:\n\t\t\treturn INT;\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid type: ${type} passed to glslKeyForType.`);\n\t}\n}\n\n/**\n * @private\n */\nexport function arrayConstructorForType(\n\ttype: GPULayerType,\n\thalfFloatsAsFloats = false,\n) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\t\tif (halfFloatsAsFloats) return Float32Array;\n\t\t\treturn Uint16Array;\n\t\tcase FLOAT:\n\t\t\treturn Float32Array;\n\t\tcase UNSIGNED_BYTE:\n\t\t\treturn Uint8Array;\n\t\tcase BYTE:\n\t\t\treturn Int8Array;\n\t\tcase UNSIGNED_SHORT:\n\t\t\treturn Uint16Array;\n\t\tcase SHORT:\n\t\t\treturn Int16Array;\n\t\tcase UNSIGNED_INT:\n\t\t\treturn Uint32Array;\n\t\tcase INT:\n\t\t\treturn Int32Array;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported type: \"${type}\".`);\n\t}\n}\n\n/**\n * @private\n */\nexport function glslTypeForType(type: GPULayerType, numComponents: GPULayerNumComponents) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\tcase FLOAT:\n\t\t\tif (numComponents === 1) return 'float';\n\t\t\treturn `vec${numComponents}`;\n\t\tcase UNSIGNED_BYTE:\n\t\tcase UNSIGNED_SHORT:\n\t\tcase UNSIGNED_INT:\n\t\t\tif (numComponents === 1) return 'uint';\n\t\t\treturn `uvec${numComponents}`;\n\t\tcase BYTE:\n\t\tcase SHORT:\n\t\tcase INT:\n\t\t\tif (numComponents === 1) return 'int';\n\t\t\treturn `ivec${numComponents}`;\n\t}\n\tthrow new Error(`Invalid type: ${type} passed to glslTypeForType.`);\n}\n\n/**\n * @private\n */\n export function glslPrefixForType(type: GPULayerType) {\n\tswitch (type) {\n\t\tcase HALF_FLOAT:\n\t\tcase FLOAT:\n\t\t\treturn '';\n\t\tcase UNSIGNED_BYTE:\n\t\tcase UNSIGNED_SHORT:\n\t\tcase UNSIGNED_INT:\n\t\t\treturn 'u';\n\t\tcase BYTE:\n\t\tcase SHORT:\n\t\tcase INT:\n\t\t\treturn 'i';\n\t}\n\tthrow new Error(`Invalid type: ${type} passed to glslPrefixForType.`);\n}\n\n/**\n * @private\n */\nexport function glslComponentSelectionForNumComponents(numComponents: GPULayerNumComponents) {\n\tswitch (numComponents) {\n\t\tcase 1:\n\t\t\treturn '.x';\n\t\tcase 2:\n\t\t\treturn '.xy';\n\t\tcase 3:\n\t\t\treturn '.xyz';\n\t\tcase 4:\n\t\t\treturn '';\n\t}\n\tthrow new Error(`Invalid numComponents: ${numComponents} passed to glslComponentSelectionForNumComponents.`);\n}","import type { GPUComposer } from './GPUComposer';\n\n// https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float\n// Float is provided by default in WebGL2 contexts.\n// This extension implicitly enables the WEBGL_color_buffer_float extension (if supported), which allows rendering to 32-bit floating-point color buffers.\nexport const OES_TEXTURE_FLOAT = 'OES_texture_float';\n// https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_half_float\n// Half float is supported by modern mobile browsers, float not yet supported.\n// Half float is provided by default for Webgl2 contexts.\n// This extension implicitly enables the EXT_color_buffer_half_float extension (if supported), which allows rendering to 16-bit floating point formats.\nexport const OES_TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n// https://www.khronos.org/registry/OpenGL/extensions/OES/OES_texture_float_linear.txt\nexport const OES_TEXTURE_FLOAT_LINEAR = 'OES_texture_float_linear';\nexport const OES_TEXTURE_HAlF_FLOAT_LINEAR = 'OES_texture_half_float_linear';\n// https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture\n// Adds gl.UNSIGNED_SHORT, gl.UNSIGNED_INT types to textImage2D in WebGL1.0\nexport const WEBGL_DEPTH_TEXTURE = 'WEBGL_depth_texture';\n// EXT_COLOR_BUFFER_FLOAT adds ability to render to a variety of floating pt textures.\n// This is needed for the WebGL2 contexts that do not support OES_TEXTURE_FLOAT / OES_TEXTURE_HALF_FLOAT extensions.\n// https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float\n// https://stackoverflow.com/questions/34262493/framebuffer-incomplete-attachment-for-texture-with-internal-format\n// https://stackoverflow.com/questions/36109347/framebuffer-incomplete-attachment-only-happens-on-android-w-firefox\nexport const EXT_COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n// On WebGL 2, EXT_COLOR_BUFFER_HALF_FLOAT is an alternative to using the EXT_color_buffer_float extension on platforms\n// that support 16-bit floating point render targets but not 32-bit floating point render targets.\nexport const EXT_COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\nexport function getExtension(\n\tcomposer: GPUComposer,\n\textensionName: string,\n\toptional = false,\n) {\n\t// Check if we've already loaded the extension.\n\tif (composer._extensions[extensionName] !== undefined) return composer._extensions[extensionName];\n\n\tconst { gl, _errorCallback, _extensions, verboseLogging } = composer;\n\tlet extension;\n\ttry {\n\t\textension = gl.getExtension(extensionName);\n\t} catch (e) {}\n\tif (extension) {\n\t\t// Cache this extension.\n\t\t_extensions[extensionName] = extension;\n\t\tif (composer.verboseLogging) console.log(`Loaded extension: ${extensionName}.`);\n\t} else {\n\t\t_extensions[extensionName] = false; // Cache the bad extension lookup.\n\t\tif (composer.verboseLogging) console.log(`Unsupported ${optional ? 'optional ' : ''}extension: ${extensionName}.`);\n\t}\n\t// If the extension is not optional, throw error.\n\tif (!extension && !optional) {\n\t\t_errorCallback(`Required extension unsupported by this device / browser: ${extensionName}.`);\n\t}\n\treturn extension;\n}","import type { GPUComposer } from './GPUComposer';\nimport type { GPULayer } from './GPULayer';\n\n// Cache framebuffers to minimize invalidating FBO attachment bindings:\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#avoid_invalidating_fbo_attachment_bindings\nconst framebufferMap: WeakMap<WebGLTexture | WebGLTexture[], WebGLFramebuffer> = new WeakMap();\nconst allTextureFramebuffersMap: WeakMap<WebGLTexture, WebGLFramebuffer[]> = new WeakMap();\n\nfunction initFrameBuffer(\n\tcomposer: GPUComposer,\n\tlayer0: GPULayer,\n\ttexture0: WebGLTexture,\n\tadditionalTextures?: WebGLTexture[],\n) {\n\tconst { gl, _errorCallback, isWebGL2 } = composer;\n\t// Init a framebuffer for this texture so we can write to it.\n\tconst framebuffer = gl.createFramebuffer();\n\tif (!framebuffer) {\n\t\t_errorCallback(`Could not init framebuffer for GPULayer \"${layer0.name}\": ${gl.getError()}.`);\n\t\treturn;\n\t}\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/framebufferTexture2D\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture0, 0);\n\tif (additionalTextures) {\n\t\t// Check if length additional textures exceeds a max.\n\t\tif (!isWebGL2) {\n\t\t\tthrow new Error('WebGL1 does not support drawing to multiple outputs.');\n\t\t}\n\t\tif (additionalTextures.length > 15) {\n\t\t\tthrow new Error(`Can't draw to more than 16 outputs.`);\n\t\t}\n\t\tfor (let i = 0, numTextures = additionalTextures.length; i < numTextures; i++) {\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, additionalTextures[i], 0);\n\t\t}\n\t}\n\n\tconst status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\tif(status !== gl.FRAMEBUFFER_COMPLETE){\n\t\t_errorCallback(`Invalid status for framebuffer for GPULayer \"${layer0.name}\": ${status}.`);\n\t}\n\n\treturn framebuffer;\n}\n\n/**\n * Bind framebuffer for write operation.\n * @private\n */\nexport function bindFrameBuffer(\n\tcomposer: GPUComposer,\n\tlayer0: GPULayer,\n\ttexture0: WebGLTexture,\n\tadditionalTextures?: WebGLTexture[],\n) {\n\tconst { gl } = composer;\n\tconst key = additionalTextures ? [texture0, ...additionalTextures] : texture0;\n\tlet framebuffer = framebufferMap.get(key);\n\tif (!framebuffer) {\n\t\tframebuffer = initFrameBuffer(composer, layer0, texture0, additionalTextures);\n\t\tif (!framebuffer) return;\n\t\tframebufferMap.set(key, framebuffer);\n\t\tconst allFramebuffers = allTextureFramebuffersMap.get(texture0) || [];\n\t\tallFramebuffers.push(framebuffer);\n\t\tallTextureFramebuffersMap.set(texture0, allFramebuffers);\n\t\tif (additionalTextures) {\n\t\t\tfor (let i = 0, numTextures = additionalTextures.length; i < numTextures; i++) {\n\t\t\t\tconst texture = additionalTextures[i];\n\t\t\t\tconst allFramebuffers = allTextureFramebuffersMap.get(texture) || [];\n\t\t\t\tallFramebuffers.push(framebuffer);\n\t\t\t\tallTextureFramebuffersMap.set(texture, allFramebuffers);\n\t\t\t}\n\t\t}\n\t}\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n}\n\n/**\n * Delete framebuffers when no longer needed.\n * @private\n */\nexport function disposeFramebuffers(gl: WebGLRenderingContext | WebGL2RenderingContext, texture: WebGLTexture) {\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t// Delete all framebuffers associated with this texture.\n\tconst allFramebuffers = allTextureFramebuffersMap.get(texture);\n\tif (allFramebuffers) {\n\t\tfor (let i = 0, numFramebuffers = allFramebuffers.length; i < numFramebuffers; i++) {\n\t\t\tgl.deleteFramebuffer(allFramebuffers[i]);\n\t\t}\n\t}\n\tallTextureFramebuffersMap.delete(texture);\n}","import {\n\tGPUIO_FLOAT_PRECISION,\n\tGPUIO_INT_PRECISION,\n\tPRECISION_LOW_P,\n\tPRECISION_MEDIUM_P,\n} from '../../constants';\nimport { intForPrecision } from '../../conversions';\n\n// These precision definitions are applied to all vertex and fragment shaders.\n// Default to highp, but fallback to mediump if highp not available.\n// These defaults can be set in GPUComposer constructor as intPrecision and floatPrecision parameters.\n// https://webglfundamentals.org/webgl/lessons/webgl-precision-issues.html\nexport const PRECISION_SOURCE = `\n#if (${GPUIO_INT_PRECISION} == ${intForPrecision(PRECISION_LOW_P)})\n\tprecision lowp int;\n\t#if (__VERSION__ == 300)\n\t\tprecision lowp isampler2D;\n\t\tprecision lowp usampler2D;\n\t#endif\n#elif (${GPUIO_INT_PRECISION} == ${intForPrecision(PRECISION_MEDIUM_P)})\n\tprecision mediump int;\n\t#if (__VERSION__ == 300)\n\t\tprecision mediump isampler2D;\n\t\tprecision mediump usampler2D;\n\t#endif\n#else \n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\n\t\tprecision highp int;\n\t\t#if (__VERSION__ == 300)\n\t\t\tprecision highp isampler2D;\n\t\t\tprecision highp usampler2D;\n\t\t#endif\n\t#else\n\t\tprecision mediump int;\n\t\t#if (__VERSION__ == 300)\n\t\t\tprecision mediump isampler2D;\n\t\t\tprecision mediump usampler2D;\n\t\t#endif\n\t#endif\n#endif\n#if (${GPUIO_FLOAT_PRECISION} == ${intForPrecision(PRECISION_LOW_P)})\n\tprecision lowp float;\n\tprecision lowp sampler2D;\n#elif (${GPUIO_FLOAT_PRECISION} == ${intForPrecision(PRECISION_MEDIUM_P)})\n\tprecision mediump float;\n\tprecision mediump sampler2D;\n#else\n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\n\t\tprecision highp float;\n\t\tprecision highp sampler2D;\n\t#else\n\t\tprecision mediump float;\n\t\tprecision mediump sampler2D;\n\t#endif\n#endif\n`;","import {\n\tGPUIO_VS_UV_ATTRIBUTE,\n\tGPUIO_VS_NORMAL_ATTRIBUTE,\n} from '../../constants';\n\nexport const DEFAULT_VERT_SHADER_SOURCE = `\nin vec2 a_gpuio_position;\n#ifdef ${GPUIO_VS_UV_ATTRIBUTE}\n\tin vec2 a_gpuio_uv;\n#endif\n#ifdef ${GPUIO_VS_NORMAL_ATTRIBUTE}\n\tin vec2 a_gpuio_normal;\n#endif\n\nuniform vec2 u_gpuio_scale;\nuniform vec2 u_gpuio_translation;\n\nout vec2 v_uv;\nout vec2 v_uv_local;\n#ifdef ${GPUIO_VS_NORMAL_ATTRIBUTE}\n\tout vec2 v_normal;\n#endif\n\nvoid main() {\n\t// Optional varyings.\n\t#ifdef ${GPUIO_VS_UV_ATTRIBUTE}\n\t\tv_uv_local = a_gpuio_uv;\n\t#else\n\t\tv_uv_local = 0.5 * (a_gpuio_position + 1.0);\n\t#endif\n\t#ifdef ${GPUIO_VS_NORMAL_ATTRIBUTE}\n\t\tv_normal = a_gpuio_normal;\n\t#endif\n\n\t// Apply transformations.\n\tvec2 position = u_gpuio_scale * a_gpuio_position + u_gpuio_translation;\n\n\t// Calculate a global uv for the viewport.\n\tv_uv = 0.5 * (position + 1.0);\n\n\t// Calculate vertex position.\n\tgl_Position = vec4(position, 0, 1);\n}`;","import {\n\tGPUIO_VS_INDEXED_POSITIONS, GPUIO_VS_POSITION_W_ACCUM, GPUIO_VS_WRAP_X, GPUIO_VS_WRAP_Y,\n} from '../../constants';\nimport { VERTEX_SHADER_HELPERS_SOURCE } from './VertexShaderHelpers';\n\nexport const LAYER_LINES_VERTEX_SHADER_SOURCE = `\n${VERTEX_SHADER_HELPERS_SOURCE}\n\n#if (__VERSION__ != 300 || ${GPUIO_VS_INDEXED_POSITIONS} == 1)\n\t// Cannot use int vertex attributes.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\tin float a_gpuio_index;\n#endif\n\nuniform sampler2D u_gpuio_positions; // Texture lookup with position data.\nuniform vec2 u_gpuio_positionsDimensions;\nuniform vec2 u_gpuio_scale;\n\nout vec2 v_uv;\nout vec2 v_lineWrapping; // Use this to test if line is only half wrapped and should not be rendered.\nflat out int v_index;\n\nvoid main() {\n\t// Calculate a uv based on the point's index attribute.\n\t#if (__VERSION__ != 300 || ${GPUIO_VS_INDEXED_POSITIONS} == 1)\n\t\tvec2 positionUV = uvFromIndex(a_gpuio_index, u_gpuio_positionsDimensions);\n\t\tv_index = int(a_gpuio_index);\n\t#else\n\t\tvec2 positionUV = uvFromIndex(gl_VertexID, u_gpuio_positionsDimensions);\n\t\tv_index = gl_VertexID;\n\t#endif\n\n\t// Calculate a global uv for the viewport.\n\t// Lookup vertex position and scale to [0, 1] range.\n\t#ifdef ${GPUIO_VS_POSITION_W_ACCUM}\n\t\t// We have packed a 2D displacement with the position.\n\t\tvec4 positionData = texture(u_gpuio_positions, positionUV);\n\t\t// position = first two components plus last two components (optional accumulation buffer).\n\t\tv_uv = (positionData.rg + positionData.ba) * u_gpuio_scale;\n\t#else\n\t\tv_uv = texture(u_gpuio_positions, positionUV).rg  * u_gpuio_scale;\n\t#endif\n\n\t// Wrap if needed.\n\tv_lineWrapping = vec2(0.0);\n\t#ifdef ${GPUIO_VS_WRAP_X}\n\t\tv_lineWrapping.x = max(step(1.0, v_uv.x), step(v_uv.x, 0.0));\n\t\tv_ux.x = fract(v_uv.x + 1.0);\n\t#endif\n\t#ifdef ${GPUIO_VS_WRAP_Y}\n\t\tv_lineWrapping.y = max(step(1.0, v_uv.y), step(v_uv.y, 0.0));\n\t\tv_ux.y = fract(v_uv.y + 1.0);\n\t#endif\n\n\t// Calculate position in [-1, 1] range.\n\tvec2 position = v_uv * 2.0 - 1.0;\n\n\tgl_Position = vec4(position, 0, 1);\n}`;","import {\n\tGPUIO_VS_POSITION_W_ACCUM, GPUIO_VS_WRAP_X, GPUIO_VS_WRAP_Y,\n} from '../../constants';\nimport { VERTEX_SHADER_HELPERS_SOURCE } from './VertexShaderHelpers';\n\nexport const LAYER_POINTS_VERTEX_SHADER_SOURCE = `\n${VERTEX_SHADER_HELPERS_SOURCE}\n\n#if (__VERSION__ != 300)\n\t// Cannot use int vertex attributes.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\tin float a_gpuio_index;\n#endif\n\nuniform sampler2D u_gpuio_positions; // Texture lookup with position data.\nuniform vec2 u_gpuio_positionsDimensions;\nuniform vec2 u_gpuio_scale;\nuniform float u_gpuio_pointSize;\n\nout vec2 v_uv;\nout vec2 v_uv_1d;\nout vec2 v_position;\nflat out int v_index;\n\nvoid main() {\n\t// Calculate a uv based on the point's index attribute.\n\t#if (__VERSION__ == 300)\n\t\tv_uv_1d = uvFromIndex(gl_VertexID, u_gpuio_positionsDimensions);\n\t\tv_index = gl_VertexID;\n\t#else\n\t\tv_uv_1d = uvFromIndex(a_gpuio_index, u_gpuio_positionsDimensions);\n\t\tv_index = int(a_gpuio_index);\n\t#endif\n\n\t// Calculate a global uv for the viewport.\n\t// Lookup vertex position and scale to [0, 1] range.\n\t#ifdef ${GPUIO_VS_POSITION_W_ACCUM}\n\t\t// We have packed a 2D displacement with the position.\n\t\tvec4 positionData = texture(u_gpuio_positions, v_uv_1d);\n\t\t// position = first two components plus last two components (optional accumulation buffer).\n\t\tv_position = positionData.rg + positionData.ba;\n\t\tv_uv = v_position * u_gpuio_scale;\n\t#else\n\t\tv_position = texture(u_gpuio_positions, v_uv_1d).rg;\n\t\tv_uv = v_position * u_gpuio_scale;\n\t#endif\n\n\t// Wrap if needed.\n\t#ifdef ${GPUIO_VS_WRAP_X}\n\t\tv_uv.x = fract(v_uv.x + ceil(abs(v_uv.x)));\n\t#endif\n\t#ifdef ${GPUIO_VS_WRAP_Y}\n\t\tv_uv.y = fract(v_uv.y + ceil(abs(v_uv.y)));\n\t#endif\n\n\t// Calculate position in [-1, 1] range.\n\tvec2 position = v_uv * 2.0 - 1.0;\n\n\tgl_PointSize = u_gpuio_pointSize;\n\tgl_Position = vec4(position, 0, 1);\n}`;","import { VERTEX_SHADER_HELPERS_SOURCE } from './VertexShaderHelpers';\n\nexport const LAYER_VECTOR_FIELD_VERTEX_SHADER_SOURCE = `\n${VERTEX_SHADER_HELPERS_SOURCE}\n\n#if (__VERSION__ != 300)\n\t// Cannot use int vertex attributes.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n\tin float a_gpuio_index;\n#endif\n\nuniform sampler2D u_gpuio_vectors; // Texture lookup with vector data.\nuniform vec2 u_gpuio_dimensions;\nuniform vec2 u_gpuio_scale;\n\nout vec2 v_uv;\nflat out int v_index;\n\nvoid main() {\n\t#if (__VERSION__ == 300)\n\t\t// Divide index by 2.\n\t\tint index = gl_VertexID / 2;\n\t\tv_index = index;\n\t#else\n\t\t// Divide index by 2.\n\t\tfloat index = floor((a_gpuio_index + 0.5) / 2.0);\n\t\tv_index = int(index);\n\t#endif\n\n\t// Calculate a uv based on the vertex index attribute.\n\tv_uv = uvFromIndex(index, u_gpuio_dimensions);\n\t#if (__VERSION__ == 300)\n\t\t// Add vector displacement if needed.\n\t\tv_uv += float(gl_VertexID - 2 * index) * texture(u_gpuio_vectors, v_uv).xy * u_gpuio_scale;\n\t#else\n\t\t// Add vector displacement if needed.\n\t\tv_uv += (a_gpuio_index - 2.0 * index) * texture(u_gpuio_vectors, v_uv).xy * u_gpuio_scale;\n\t#endif\n\n\n\t// Calculate position in [-1, 1] range.\n\tvec2 position = v_uv * 2.0 - 1.0;\n\n\tgl_Position = vec4(position, 0, 1);\n}`;","export const SEGMENT_VERTEX_SHADER_SOURCE = `\nin vec2 a_gpuio_position;\n\nuniform float u_gpuio_halfThickness;\nuniform vec2 u_gpuio_scale;\nuniform float u_gpuio_length;\nuniform float u_gpuio_rotation;\nuniform vec2 u_gpuio_translation;\n\nout vec2 v_uv_local;\nout vec2 v_uv;\n\nmat2 rotate2d(float _angle){\n\treturn mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n\t// Calculate UV coordinates of current rendered object.\n\tv_uv_local = 0.5 * (a_gpuio_position + 1.0);\n\n\tvec2 position = a_gpuio_position;\n\t// Apply thickness / radius.\n\tposition *= u_gpuio_halfThickness;\n\t// Stretch center of shape to form a round-capped line segment.\n\tfloat signX = sign(position.x);\n\tposition.x += signX * u_gpuio_length / 2.0;\n\tv_uv_local.x = (signX + 1.0) / 2.0;// Set entire cap uv.x to 1 or 0.\n\t// Apply transformations.\n\tposition = u_gpuio_scale * (rotate2d(-u_gpuio_rotation) * position) + u_gpuio_translation;\n\n\t// Calculate a global uv for the viewport.\n\tv_uv = 0.5 * (position + 1.0);\n\n\t// Calculate vertex position.\n\tgl_Position = vec4(position, 0, 1);\n}`;","export const VERTEX_SHADER_HELPERS_SOURCE = `\n/**\n * Returns accurate MOD when arguments are approximate integers.\n */\nfloat modI(float a, float b) {\n    float m = a - floor((a + 0.5) / b) * b;\n    return floor(m + 0.5);\n}\n\n/**\n * Create UV coordinates from a 1D index for data stored in a texture of size \"dimensions\".\n */\nvec2 uvFromIndex(const float index, const vec2 dimensions) {\n    return vec2(\n        modI(index, dimensions.x),\n\t\tfloor(floor(index + 0.5) / dimensions.x)\n\t) / dimensions;\n}\nvec2 uvFromIndex(const int index, const vec2 dimensions) {\n    int width = int(dimensions.x);\n    int y = index / width;\n    return vec2(\n        index - y * width,\n\t\ty\n\t) / dimensions;\n}`\n","import * as utils from './utils';\nimport { GPUComposer } from './GPUComposer';\nimport { GPULayer } from './GPULayer';\nimport * as GPULayerHelpers from './GPULayerHelpers';\nimport { GPUProgram } from './GPUProgram';\nimport * as checks from './checks';\nimport * as regex from './regex';\nimport * as extensions from './extensions';\nimport * as polyfills from './polyfills';\nimport * as conversions from './conversions';\nimport * as Programs from './Programs';\n\n// These exports are only used for testing.\n/**\n * @private\n */\nconst _testing = {\n\tisFloatType: utils.isFloatType,\n\tisUnsignedIntType: utils.isUnsignedIntType,\n\tisSignedIntType: utils.isSignedIntType,\n\tisIntType: utils.isIntType,\n\tmakeShaderHeader: utils.makeShaderHeader,\n\tcompileShader: utils.compileShader,\n\tinitGLProgram: utils.initGLProgram,\n\treadyToRead: utils.readyToRead,\n\tpreprocessVertexShader: utils.preprocessVertexShader,\n\tpreprocessFragmentShader: utils.preprocessFragmentShader,\n\tisPowerOf2: utils.isPowerOf2,\n\tinitSequentialFloatArray: utils.initSequentialFloatArray,\n\tuniformInternalTypeForValue: utils.uniformInternalTypeForValue,\n\tindexOfLayerInArray: utils.indexOfLayerInArray,\n\treadPixelsAsync: utils.readPixelsAsync,\n\t...extensions,\n\t...regex,\n\t...checks,\n\t...GPULayerHelpers,\n\t...polyfills,\n\t...conversions,\n}\n\n// Named exports.\nconst {\n\tisWebGL2,\n\tisWebGL2Supported,\n\tisHighpSupportedInVertexShader,\n\tisHighpSupportedInFragmentShader,\n\tgetVertexShaderMediumpPrecision,\n\tgetFragmentShaderMediumpPrecision,\n} = utils;\nconst {\n\tcopyProgram,\n\taddLayersProgram,\n\taddValueProgram,\n\tmultiplyValueProgram,\n\trenderAmplitudeProgram,\n\trenderSignedAmplitudeProgram,\n\tsetValueProgram,\n\tsetColorProgram,\n} = Programs;\n\nexport {\n\tGPUComposer,\n\tGPULayer,\n\tGPUProgram,\n\tisWebGL2,\n\tisWebGL2Supported,\n\tisHighpSupportedInVertexShader,\n\tisHighpSupportedInFragmentShader,\n\tgetVertexShaderMediumpPrecision,\n\tgetFragmentShaderMediumpPrecision,\n\tcopyProgram,\n\taddLayersProgram,\n\taddValueProgram,\n\tmultiplyValueProgram,\n\trenderAmplitudeProgram,\n\trenderSignedAmplitudeProgram,\n\tsetValueProgram,\n\tsetColorProgram,\n\t_testing,\n}\nexport * from './constants';","import { getSampler2DsInProgram } from './regex';\n\n/**\n * Wrap type to use in polyfill.\n * (0) Default behavior (no polyfill).\n * (1) REPEAT polyfill.\n * @private\n */\nexport const SAMPLER2D_WRAP_X = 'GPUIO_WRAP_X';\n/**\n * Wrap type to use in polyfill.\n * (0) Default behavior (no polyfill).\n * (1) REPEAT polyfill.\n * @private\n */\nexport const SAMPLER2D_WRAP_Y = 'GPUIO_WRAP_Y';\n/**\n * Flag to cast texture() result to int type (needed for GLSL1).\n * @private\n */\n export const SAMPLER2D_CAST_INT = 'GPUIO_CAST_INT';\n\n/**\n * Filter type to use in polyfill.\n * (0) Default behavior (no polyfill).\n * (0) LINEAR polyfill.\n * @private\n */\nexport const SAMPLER2D_FILTER = 'GPUIO_FILTER';\n\n/**\n * UV size of half a pixel for this texture.\n * @private\n */\nexport const SAMPLER2D_HALF_PX_UNIFORM = 'u_gpuio_half_px';\n\n/**\n * Dimensions of texture\n * @private\n */\nexport const SAMPLER2D_DIMENSIONS_UNIFORM = 'u_gpuio_dimensions';\n\n/**\n * Override texture function to perform polyfill filter/wrap.\n * https://www.codeproject.com/Articles/236394/Bi-Cubic-and-Bi-Linear-Interpolation-with-GLSL\n * @private\n */\nexport function texturePolyfill(shaderSource: string) {\n\tconst textureCalls = shaderSource.match(/\\btexture\\(/g);\n\tif (!textureCalls || textureCalls.length === 0) return { shaderSource, samplerUniforms: [] };\n\tconst samplerUniforms = getSampler2DsInProgram(shaderSource);\n\tif (samplerUniforms.length === 0) return { shaderSource, samplerUniforms };\n\tsamplerUniforms.forEach((name, i) => {\n\t\tconst regex = new RegExp(`\\\\btexture(2D)?\\\\(\\\\s?${name}\\\\b`, 'gs');\n\t\tshaderSource = shaderSource.replace(regex, `GPUIO_TEXTURE_POLYFILL${i}(${name}`);\n\t});\n\tconst remainingTextureCalls = shaderSource.match(/\\btexture(2D)?\\(/g);\n\tif (remainingTextureCalls?.length) {\n\t\tconsole.warn('Fragment shader polyfill has missed some calls to texture().', shaderSource);\n\t}\n\t\n\tlet polyfillUniforms: {[key: string] : string } = {};\n\tfor (let i = 0; i < samplerUniforms.length; i++) {\n\t\t// Init uniforms with a type.\n\t\tpolyfillUniforms[`${SAMPLER2D_HALF_PX_UNIFORM}${i}`] = 'vec2';\n\t\tpolyfillUniforms[`${SAMPLER2D_DIMENSIONS_UNIFORM}${i}`] = 'vec2';\n\t}\n\n\tfunction make_GPUIO_TEXTURE_POLYFILL(i: number, prefix: string, castOpening = '') {\n\t\tconst castEnding = castOpening === '' ? '' : ')';\n\t\tconst returnPrefix = castOpening === '' ? prefix : 'i';\n\t\treturn `\n${returnPrefix}vec4 GPUIO_TEXTURE_POLYFILL${i}(const ${prefix}sampler2D sampler, const vec2 uv) {\n\t${ prefix === '' ? `#if (${SAMPLER2D_FILTER}${i} == 0)` : ''}\n\t\t#if (${SAMPLER2D_WRAP_X}${i} == 0)\n\t\t\t#if (${SAMPLER2D_WRAP_Y}${i} == 0)\n\t\t\t\treturn ${castOpening}texture(sampler, uv)${castEnding};\n\t\t\t#else\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_WRAP_CLAMP_REPEAT(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i})${castEnding};\n\t\t\t#endif\n\t\t#else\n\t\t\t#if (${SAMPLER2D_WRAP_Y}${i} == 0)\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_WRAP_REPEAT_CLAMP(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i})${castEnding};\n\t\t\t#else\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_WRAP_REPEAT_REPEAT(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i})${castEnding};\n\t\t\t#endif\n\t\t#endif\n\t${ prefix === '' ? `#else\n\t\t#if (${SAMPLER2D_WRAP_X}${i} == 0)\n\t\t\t#if (${SAMPLER2D_WRAP_Y}${i} == 0)\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_BILINEAR_INTERP(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i}, ${SAMPLER2D_DIMENSIONS_UNIFORM}${i})${castEnding};\n\t\t\t#else\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_BILINEAR_INTERP_WRAP_CLAMP_REPEAT(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i}, ${SAMPLER2D_DIMENSIONS_UNIFORM}${i})${castEnding};\n\t\t\t#endif\n\t\t#else\n\t\t\t#if (${SAMPLER2D_WRAP_Y}${i} == 0)\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_BILINEAR_INTERP_WRAP_REPEAT_CLAMP(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i}, ${SAMPLER2D_DIMENSIONS_UNIFORM}${i})${castEnding};\n\t\t\t#else\n\t\t\t\treturn ${castOpening}GPUIO_TEXTURE_BILINEAR_INTERP_WRAP_REPEAT_REPEAT(sampler, uv, ${SAMPLER2D_HALF_PX_UNIFORM}${i}, ${SAMPLER2D_DIMENSIONS_UNIFORM}${i})${castEnding};\n\t\t\t#endif\n\t\t#endif\n\t#endif` : '' }\n}\\n`;\n\t}\n\n\tfunction make_GPUIO_TEXTURE_WRAP(prefix: string) {\n\t\treturn `\n${prefix}vec4 GPUIO_TEXTURE_WRAP_REPEAT_REPEAT(const ${prefix}sampler2D sampler, const vec2 uv, const vec2 halfPx) {\n\treturn texture(sampler, GPUIO_WRAP_REPEAT_UV(uv));\n}\n${prefix}vec4 GPUIO_TEXTURE_WRAP_REPEAT_CLAMP(const ${prefix}sampler2D sampler, vec2 uv, const vec2 halfPx) {\n\tuv.x = GPUIO_WRAP_REPEAT_UV_COORD(uv.x);\n\t// uv.y = GPUIO_WRAP_CLAMP_UV_COORD(uv.y, halfPx.y);\n\treturn texture(sampler, uv);\n}\n${prefix}vec4 GPUIO_TEXTURE_WRAP_CLAMP_REPEAT(const ${prefix}sampler2D sampler, vec2 uv, const vec2 halfPx) {\n\t// uv.x = GPUIO_WRAP_CLAMP_UV_COORD(uv.x, halfPx.x);\n\tuv.y = GPUIO_WRAP_REPEAT_UV_COORD(uv.y);\n\treturn texture(sampler, uv);\n}\\n`;\n\t}\n\n\tfunction make_GPUIO_BILINEAR_INTERP(wrapType: string | null) {\n\t\tconst lookupFunction = wrapType ? `GPUIO_TEXTURE_WRAP_${wrapType}` : 'texture';\n\t\tconst extraParams =  wrapType ? `, halfPx` : '';\n\t\treturn`\nvec4 GPUIO_TEXTURE_BILINEAR_INTERP${ wrapType ? `_WRAP_${wrapType}` : '' }(const sampler2D sampler, const vec2 uv, const vec2 halfPx, const vec2 dimensions) {\n\tvec2 pxFraction = fract(uv * dimensions);\n\tvec2 offset = halfPx - vec2(0.00001, 0.00001) * max(\n\t\t\tstep(abs(pxFraction.x - 0.5), 0.001),\n\t\t\tstep(abs(pxFraction.y - 0.5), 0.001)\n\t\t);\n\tvec2 baseUV = uv - offset;\n\tvec2 diagOffset = vec2(offset.x, -offset.y);\n\tvec4 minmin = ${lookupFunction}(sampler, baseUV${extraParams});\n\tvec4 maxmin = ${lookupFunction}(sampler, uv + diagOffset${extraParams});\n\tvec4 minmax = ${lookupFunction}(sampler, uv - diagOffset${extraParams});\n\tvec4 maxmax = ${lookupFunction}(sampler, uv + offset${extraParams});\n\tvec2 t = fract(baseUV * dimensions);\n\tvec4 yMin = mix(minmin, maxmin, t.x);\n\tvec4 yMax = mix(minmax, maxmax, t.x);\n\treturn mix(yMin, yMax, t.y);\n}\\n`;\n\t}\n\n\tshaderSource = `\n${ Object.keys(polyfillUniforms).map((key) => `uniform ${polyfillUniforms[key]} ${key};`).join('\\n') }\n\nfloat GPUIO_WRAP_REPEAT_UV_COORD(const float coord) {\n\treturn fract(coord + ceil(abs(coord)));\n}\nvec2 GPUIO_WRAP_REPEAT_UV(const vec2 uv) {\n\treturn fract(uv + ceil(abs(uv)));\n}\n// float GPUIO_WRAP_CLAMP_UV_COORD(const float coord, const float halfPx) {\n// \treturn clamp(coord, halfPx, 1.0 - halfPx);\n// }\n\n${ make_GPUIO_TEXTURE_WRAP('') }\n#if (__VERSION__ == 300)\n${ ['u', 'i'].map(prefix => make_GPUIO_TEXTURE_WRAP(prefix)).join('\\n') }\n#endif\n\n${ [ null,\n\t'REPEAT_REPEAT',\n\t'REPEAT_CLAMP',\n\t'CLAMP_REPEAT',\n].map(wrap => make_GPUIO_BILINEAR_INTERP(wrap)).join('\\n') }\n\n${ samplerUniforms.map((uniform, index) => {\nreturn `#ifndef ${SAMPLER2D_CAST_INT}${index}\n\t${ make_GPUIO_TEXTURE_POLYFILL(index, '') }\n#endif`}).join('\\n') }\n#if (__VERSION__ == 300)\n${ ['u', 'i'].map(prefix => {\n\treturn samplerUniforms.map((uniform, index) => {\n\t\treturn make_GPUIO_TEXTURE_POLYFILL(index, prefix);\n\t}).join('\\n');\n}).join('\\n') }\n#else\n\t${ samplerUniforms.map((uniform, index) => {\nreturn `#ifdef ${SAMPLER2D_CAST_INT}${index}\n\t${make_GPUIO_TEXTURE_POLYFILL(index, '', 'ivec4(') }\n#endif`}).join('\\n') }\n#endif\n\n${shaderSource}`;\n\treturn {\n\t\tshaderSource,\n\t\tsamplerUniforms,\n\t}\n}\n\ntype T = 'float' | 'vec2' | 'vec3' | 'vec4';\ntype TI = 'int' | 'ivec2' | 'ivec3' | 'ivec4';\ntype TU = 'uint' | 'uvec2' | 'uvec3' | 'uvec4';\ntype TB = 'bool' | 'bvec2' | 'bvec3' | 'bvec4';\n\nfunction floatTypeForIntType(type: TI | TU): T {\n\tswitch(type) {\n\t\tcase 'int':\n\t\tcase 'uint':\n\t\t\treturn 'float';\n\t\tcase 'ivec2':\n\t\tcase 'uvec2':\n\t\t\treturn 'vec2';\n\t\tcase 'ivec3':\n\t\tcase 'uvec3':\n\t\t\treturn 'vec3';\n\t\tcase 'ivec4':\n\t\tcase 'uvec4':\n\t\t\treturn 'vec4';\n\t}\n\tthrow new Error(`Unknown type ${type}.`);\n}\n\nfunction floatTypeForBoolType(type: TB): T {\n\tswitch(type) {\n\t\tcase 'bool':\n\t\t\treturn 'float';\n\t\tcase 'bvec2':\n\t\t\treturn 'vec2';\n\t\tcase 'bvec3':\n\t\t\treturn 'vec3';\n\t\tcase 'bvec4':\n\t\t\treturn 'vec4';\n\t}\n\tthrow new Error(`Unknown type ${type}.`);\n}\n\nlet GLSL1_POLYFILLS: string;\n/**\n * Polyfill common functions/operators that GLSL1 lacks.\n * @private\n */\nexport function GLSL1Polyfills() {\n\tif (GLSL1_POLYFILLS) return GLSL1_POLYFILLS;\n\n\tconst abs = (type: TI) => `${type} abs(const ${type} a) { return ${type}(abs(${floatTypeForIntType(type)}(a))); }`;\n\tconst sign = (type: TI) => `${type} sign(const ${type} a) { return ${type}(sign(${floatTypeForIntType(type)}(a))); }`;\n\tconst trunc = (type: T) => `${type} trunc(const ${type} a) { return round(a - fract(a) * sign(a)); }`;\n\tconst round = (type: T) => `${type} round(const ${type} a) { return floor(a + 0.5); }`;\n\tconst roundEven = (type: T) => `${type} roundEven(const ${type} a) { return 2.0 * round(a / 2.0); }`;\n\tconst min = (type1: TI, type2: TI) => `${type1} min(const ${type1} a, const ${type2} b) { return ${type1}(min(${floatTypeForIntType(type1)}(a), ${floatTypeForIntType(type2)}(b))); }`;\n\tconst max = (type1: TI, type2: TI) => `${type1} max(const ${type1} a, const ${type2} b) { return ${type1}(max(${floatTypeForIntType(type1)}(a), ${floatTypeForIntType(type2)}(b))); }`;\n\tconst clamp = (type1: TI, type2: TI) => `${type1} clamp(const ${type1} a, const ${type2} min, const ${type2} max) { return ${type1}(clamp(${floatTypeForIntType(type1)}(a), ${floatTypeForIntType(type2)}(min), ${floatTypeForIntType(type2)}(max))); }`;\n\tconst mix = (type1: T, type2: TB) => `${type1} mix(const ${type1} a, const ${type1} b, const ${type2} c) { return mix(a, b, ${floatTypeForBoolType(type2)}(c)); }`;\n\tconst det2 = (n: number, m: number, size: number) => `a[${n}][${m}] * a[${(n + 1) % size}][${(m + 1) % size}] - a[${(n + 1) % size}][${m}] * a[${n}][${(m + 1) % size}]`;\n\t// TODO: I don't think these are quite right yet.\n\tconst det3 = (n: number, m: number, size: number) => [0, 1, 2].map(offset => `a[${n}][${(m + offset) % size}] * (${det2((n + 1) % size, (m + 1 + offset) % size, size)})`).join(' + ');\n\tconst det4 = (n: number, m: number, size: number) => [0, 1, 2, 3].map(offset => `a[${n}][${(m + offset) % size}] * (${det3((n + 1) % size, (m + 1 + offset) % size, size)})`).join(' + ');\n\n\t// We don't need to create unsigned int polyfills, bc unsigned int is not a supported type in GLSL1.\n\t// All unsigned int variables will be cast as int and be caught by the signed int polyfills.\n\tGLSL1_POLYFILLS = `\n${abs('int')}\n${abs('ivec2')}\n${abs('ivec3')}\n${abs('ivec4')}\n\n${sign('int')}\n${sign('ivec2')}\n${sign('ivec3')}\n${sign('ivec4')}\n\n${round('float')}\n${round('vec2')}\n${round('vec3')}\n${round('vec4')}\n\n${trunc('float')}\n${trunc('vec2')}\n${trunc('vec3')}\n${trunc('vec4')}\n\n${roundEven('float')}\n${roundEven('vec2')}\n${roundEven('vec3')}\n${roundEven('vec4')}\n\n${min('int', 'int')}\n${min('ivec2', 'ivec2')}\n${min('ivec3', 'ivec3')}\n${min('ivec4', 'ivec4')}\n${min('ivec2', 'int')}\n${min('ivec3', 'int')}\n${min('ivec4', 'int')}\n\n${max('int', 'int')}\n${max('ivec2', 'ivec2')}\n${max('ivec3', 'ivec3')}\n${max('ivec4', 'ivec4')}\n${max('ivec2', 'int')}\n${max('ivec3', 'int')}\n${max('ivec4', 'int')}\n\n${clamp('int', 'int')}\n${clamp('ivec2', 'ivec2')}\n${clamp('ivec3', 'ivec3')}\n${clamp('ivec4', 'ivec4')}\n${clamp('ivec2', 'int')}\n${clamp('ivec3', 'int')}\n${clamp('ivec4', 'int')}\n\n${mix('float', 'bool')}\n${mix('vec2', 'bvec2')}\n${mix('vec3', 'bvec3')}\n${mix('vec4', 'bvec4')}\n\nmat2 outerProduct(const vec2 a, const vec2 b) {\n\treturn mat2(\n\t\ta.x * b.x, a.x * b.y,\n\t\ta.y * b.x, a.y * b.y\n\t);\n}\nmat3 outerProduct(const vec3 a, const vec3 b) {\n\treturn mat3(\n\t\ta.x * b.x, a.x * b.y, a.x * b.z,\n\t\ta.y * b.x, a.y * b.y, a.y * b.z,\n\t\ta.z * b.x, a.z * b.y, a.z * b.z\n\t);\n}\nmat4 outerProduct(const vec4 a, const vec4 b) {\n\treturn mat4(\n\t\ta.x * b.x, a.x * b.y, a.x * b.z, a.x * b.w,\n\t\ta.y * b.x, a.y * b.y, a.y * b.z, a.y * b.w,\n\t\ta.z * b.x, a.z * b.y, a.z * b.z, a.z * b.w,\n\t\ta.w * b.x, a.w * b.y, a.w * b.z, a.w * b.w\n\t);\n}\nmat2 transpose(mat2 a) {\n\tfloat temp = a[0][1];\n\ta[0][1] = a[1][0];\n\ta[1][0] = temp;\n\treturn a;\n}\nmat3 transpose(mat3 a) {\n\tfloat temp = a[0][2];\n\ta[0][2] = a[2][0];\n\ta[2][0] = temp;\n\ttemp = a[0][1];\n\ta[0][1] = a[1][0];\n\ta[1][0] = temp;\n\ttemp = a[1][2];\n\ta[1][2] = a[2][1];\n\ta[2][1] = temp;\n\treturn a;\n}\nmat4 transpose(mat4 a) {\n\tfloat temp = a[0][3];\n\ta[0][3] = a[3][0];\n\ta[3][0] = temp;\n\ttemp = a[0][2];\n\ta[0][2] = a[2][0];\n\ta[2][0] = temp;\n\ttemp = a[2][3];\n\ta[2][3] = a[3][2];\n\ta[3][2] = temp;\n\ttemp = a[0][1];\n\ta[0][1] = a[1][0];\n\ta[1][0] = temp;\n\ttemp = a[1][2];\n\ta[1][2] = a[2][1];\n\ta[2][1] = temp;\n\ttemp = a[2][3];\n\ta[2][3] = a[3][2];\n\ta[3][2] = temp;\n\treturn a;\n}\n\nfloat determinant(const mat2 a) {\n\treturn ${ det2(0, 0, 2) };\n}\nfloat determinant(const mat3 a) {\n\treturn ${ det3(0, 0, 3) };\n}\nfloat determinant(const mat4 a) {\n\treturn ${ det4(0, 0, 4) };\n}\n` + \n// Copied from https://github.com/gpujs/gpu.js/blob/master/src/backend/web-gl/fragment-shader.js\n`\nfloat cosh(const float x) {\n\treturn (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; \n}\nfloat sinh(const float x) {\n\treturn (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;\n}\nfloat tanh(const float x) {\n\tfloat e = exp(2.0 * x);\n\treturn (e - 1.0) / (e + 1.0);\n}\nfloat asinh(const float x) {\n\treturn log(x + sqrt(x * x + 1.0));\n}\nfloat acosh(const float x) {\n\treturn log(x + sqrt(x * x - 1.0));\n}\nfloat atanh(float x) {\n\tx = (x + 1.0) / (x - 1.0);\n\treturn 0.5 * log(x * sign(x));\n}`;\n\treturn GLSL1_POLYFILLS;\n}\n\nlet FRAGMENT_SHADER_POLYFILLS: string;\n/**\n * Polyfills to be make available for both GLSL1 and GLSL3 fragment shaders.\n * @private\n */\nexport function fragmentShaderPolyfills() {\n\tif (FRAGMENT_SHADER_POLYFILLS) return FRAGMENT_SHADER_POLYFILLS;\n\n\tconst modi = (type1: TI | TU, type2: TI | TU) => `${type1} modi(const ${type1} x, const ${type2} y) { return x - y * (x / y); }`;\n\tconst stepi = (type1: TI | TU, type2: TI | TU) => `${type2} stepi(const ${type1} x, const ${type2} y) { return ${type2}(step(${floatTypeForIntType(type1)}(x), ${floatTypeForIntType(type2)}(y))); }`;\n\tconst bitshiftLeft = (type1: TI | TU, type2: TI | TU) => {\nreturn`${type1} bitshiftLeft(const ${type1} a, const ${type2} b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a << b;\n\t#else\n\t\treturn a * ${type1}(pow(${floatTypeForIntType(type2)}(2.0), ${floatTypeForIntType(type2)}(b)));\n\t#endif\n}`;\n\t}\n\tconst bitshiftRight = (type1: TI | TU, type2: TI | TU) => {\nreturn `${type1} bitshiftRight(const ${type1} a, const ${type2} b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a >> b;\n\t#else\n\t\treturn ${type1}(round(${floatTypeForIntType(type1)}(a) / pow(${floatTypeForIntType(type2)}(2.0), ${floatTypeForIntType(type2)}(b))));\n\t#endif\n}`;\n\t}\n\t// Copied from https://github.com/gpujs/gpu.js/blob/master/src/backend/web-gl/fragment-shader.js\n\t// Seems like these could be optimized.\n\tconst bitwiseOr = (numBits: 8 | 16 | 32) => {\nreturn `int bitwiseOr${numBits === 32 ? '' : numBits}(int a, int b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a | b;\n\t#else\n\t\tint result = 0;\n\t\tint n = 1;\n\t\t\n\t\tfor (int i = 0; i < ${numBits}; i++) {\n\t\t\tif ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\n\t\t\t\tresult += n;\n\t\t\t}\n\t\t\ta = a / 2;\n\t\t\tb = b / 2;\n\t\t\tn = n * 2;\n\t\t\tif(!(a > 0 || b > 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t#endif\n}`; };\nconst bitwiseXOR = (numBits: 8 | 16 | 32) => {\nreturn `int bitwiseXOR${numBits === 32 ? '' : numBits}(int a, int b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a ^ b;\n\t#else\n\t\tint result = 0;\n\t\tint n = 1;\n\t\t\n\t\tfor (int i = 0; i < ${numBits}; i++) {\n\t\t\tif ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\n\t\t\t\tresult += n;\n\t\t\t}\n\t\t\ta = a / 2;\n\t\t\tb = b / 2;\n\t\t\tn = n * 2;\n\t\t\tif(!(a > 0 || b > 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t#endif\n}`; }\n\tconst bitwiseAnd = (numBits: 8 | 16 | 32) => {\nreturn `int bitwiseAnd${numBits === 32 ? '' : numBits}(int a, int b) {\n\t#if (__VERSION__ == 300)\n\t\treturn a & b;\n\t#else\n\t\tint result = 0;\n\t\tint n = 1;\n\t\tfor (int i = 0; i < ${numBits}; i++) {\n\t\t\tif ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n\t\t\t\tresult += n;\n\t\t\t}\n\t\t\ta = a / 2;\n\t\t\tb = b / 2;\n\t\t\tn = n * 2;\n\t\t\tif(!(a > 0 && b > 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t#endif\n}`; };\n\tconst bitwiseNot = (numBits: 8 | 16 | 32) => {\nreturn `int bitwiseNot${numBits === 32 ? '' : numBits}(int a) {\n\t#if (__VERSION__ == 300)\n\t\treturn ~a;\n\t#else\n\t\tint result = 0;\n\t\tint n = 1;\n\n\t\tfor (int i = 0; i < ${numBits}; i++) {\n\t\t\tif (modi(a, 2) == 0) {\n\t\t\t\tresult += n;\n\t\t\t}\n\t\t\ta = a / 2;\n\t\t\tn = n * 2;\n\t\t}\n\t\treturn result;\n\t#endif\n}`; }\n\n\tFRAGMENT_SHADER_POLYFILLS = `\n${modi('int', 'int')}\n${modi('ivec2', 'ivec2')}\n${modi('ivec3', 'ivec3')}\n${modi('ivec4', 'ivec4')}\n${modi('ivec2', 'int')}\n${modi('ivec3', 'int')}\n${modi('ivec4', 'int')}\n#if (__VERSION__ == 300)\n${modi('uint', 'uint')}\n${modi('uvec2', 'uvec2')}\n${modi('uvec3', 'uvec3')}\n${modi('uvec4', 'uvec4')}\n${modi('uvec2', 'uint')}\n${modi('uvec3', 'uint')}\n${modi('uvec4', 'uint')}\n#endif\n\n${stepi('int', 'int')}\n${stepi('ivec2', 'ivec2')}\n${stepi('ivec3', 'ivec3')}\n${stepi('ivec4', 'ivec4')}\n${stepi('int', 'ivec2')}\n${stepi('int', 'ivec3')}\n${stepi('int', 'ivec4')}\n#if (__VERSION__ == 300)\n${stepi('uint', 'uint')}\n${stepi('uvec2', 'uvec2')}\n${stepi('uvec3', 'uvec3')}\n${stepi('uvec4', 'uvec4')}\n${stepi('uint', 'uvec2')}\n${stepi('uint', 'uvec3')}\n${stepi('uint', 'uvec4')}\n#endif\n\n${bitshiftLeft('int', 'int')}\n${bitshiftLeft('ivec2', 'ivec2')}\n${bitshiftLeft('ivec3', 'ivec3')}\n${bitshiftLeft('ivec4', 'ivec4')}\n${bitshiftLeft('ivec2', 'int')}\n${bitshiftLeft('ivec3', 'int')}\n${bitshiftLeft('ivec4', 'int')}\n#if (__VERSION__ == 300)\n${bitshiftLeft('uint', 'uint')}\n${bitshiftLeft('uvec2', 'uvec2')}\n${bitshiftLeft('uvec3', 'uvec3')}\n${bitshiftLeft('uvec4', 'uvec4')}\n${bitshiftLeft('uvec2', 'uint')}\n${bitshiftLeft('uvec3', 'uint')}\n${bitshiftLeft('uvec4', 'uint')}\n#endif\n\n${bitshiftRight('int', 'int')}\n${bitshiftRight('ivec2', 'ivec2')}\n${bitshiftRight('ivec3', 'ivec3')}\n${bitshiftRight('ivec4', 'ivec4')}\n${bitshiftRight('ivec2', 'int')}\n${bitshiftRight('ivec3', 'int')}\n${bitshiftRight('ivec4', 'int')}\n#if (__VERSION__ == 300)\n${bitshiftRight('uint', 'uint')}\n${bitshiftRight('uvec2', 'uvec2')}\n${bitshiftRight('uvec3', 'uvec3')}\n${bitshiftRight('uvec4', 'uvec4')}\n${bitshiftRight('uvec2', 'uint')}\n${bitshiftRight('uvec3', 'uint')}\n${bitshiftRight('uvec4', 'uint')}\n#endif\n\n${bitwiseOr(8)}\n${bitwiseOr(16)}\n${bitwiseOr(32)}\n\n${bitwiseXOR(8)}\n${bitwiseXOR(16)}\n${bitwiseXOR(32)}\n\n${bitwiseAnd(8)}\n${bitwiseAnd(16)}\n${bitwiseAnd(32)}\n\n${bitwiseNot(8)}\n${bitwiseNot(16)}\n${bitwiseNot(32)}\n\n#if (__VERSION__ == 300)\n${ [8, 16, ''].map(suffix => {\nreturn `\nuint bitwiseOr${suffix}(uint a, uint b) {\n\treturn uint(bitwiseOr${suffix}(int(a), int(b)));\n}\nuint bitwiseXOR${suffix}(uint a, uint b) {\n\treturn uint(bitwiseXOR${suffix}(int(a), int(b)));\n}\nuint bitwiseAnd${suffix}(uint a, uint b) {\n\treturn uint(bitwiseAnd${suffix}(int(a), int(b)));\n}\nuint bitwiseNot${suffix}(uint a) {\n\treturn uint(bitwiseNot${suffix}(int(a)));\n}` }).join('\\n')}\n\n#endif\n`;\n\treturn FRAGMENT_SHADER_POLYFILLS;\n}\n","import { GLSLVersion, GLSL3 } from './constants';\n\n/**\n * Helper functions for converting GLSL3 to GLSL1 and checking for valid shader code.\n * Note: there is no positive lookbehind support in some browsers, use capturing parens instead.\n * https://stackoverflow.com/questions/3569104/positive-look-behind-in-javascript-regular-expression/3569116#3569116\n */\n\ntype GLSLType = 'float' | 'int' | 'uint' | 'vec2' | 'vec3' | 'vec4' | 'ivec2' | 'ivec3' | 'ivec4' | 'uvec2' | 'uvec3' | 'uvec4';\n\n/**\n * Convert vertex shader \"in\" to \"attribute\".\n * @private\n */\nexport function glsl1VertexIn(shaderSource: string) {\n\treturn shaderSource.replace(/\\bin\\b/g, 'attribute');\n}\n\nfunction escapeRegExp(string: string){\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * Typecast variable assignment.\n * This is used in cases when e.g. varyings have to be converted to float in GLSL1.\n */\nfunction typecastVariable(shaderSource: string, variableName: string, type: string) {\n\t// \"s\" makes this work for multiline values.\n\t// Do this without lookbehind to support older browsers.\n\t// const regexMatch = new RegExp(`(?<=\\\\b${escapeRegExp(variableName)}\\\\s*=\\\\s*)\\\\S[^;]*(?=;)`, 'sg');\n\tconst regexMatch = new RegExp(`\\\\b${escapeRegExp(variableName)}\\\\s*=\\\\s*\\\\S[^;]*;`, 'sg');\n\tconst assignmentExpressions = shaderSource.match(regexMatch);\n\tif (assignmentExpressions) {\n\t\t// Loop through all places where variable is assigned and typecast.\n\t\tfor (let i = 0; i < assignmentExpressions.length; i++) {\n\t\t\tconst regexValueMatch = new RegExp(`\\\\b${escapeRegExp(variableName)}\\\\s*=\\\\s*(\\\\S[^;]*);`, 's');\n\t\t\tconst value = assignmentExpressions[i].match(regexValueMatch);\n\t\t\tif (value && value[1]) {\n\t\t\t\tconst regexReplace = new RegExp(`\\\\b${escapeRegExp(variableName)}\\\\s*=\\\\s*${escapeRegExp(value[1])}\\\\s*;`, 's');\n\t\t\t\tshaderSource = shaderSource.replace(regexReplace, `${variableName} = ${type}(${value[1]});`);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Could not find value in expression: \"${assignmentExpressions[i]}\"`);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconsole.warn(`No assignment found for shader variable ${variableName}.`);\n\t}\n\treturn shaderSource;\n}\n\n/**\n * Convert int varyings to float types.\n * Also update any variable assignments so that they are cast to float.\n * @private\n */\nfunction _castVaryingToFloat(shaderSource: string, regexString: string, type: string) {\n\t// Do this without lookbehind to support older browsers.\n\t// const regexMatch = new RegExp(`(?<=${regexString}\\\\s+)\\\\S[^;]*(?=;)`, 'g');\n\tconst regexMatch = new RegExp(`${regexString}\\\\s+\\\\S[^;]*;`, 'g');\n\tconst castToFloatExpressions = shaderSource.match(regexMatch);\n\tif (castToFloatExpressions) {\n\t\t// Replace all with new type.\n\t\tconst regexReplace = new RegExp(`${regexString}\\\\b`, 'g');\n\t\tshaderSource = shaderSource.replace(regexReplace, `varying ${type}`);\n\t\t// Loop through each expression, grab variable name, and cast all assignments.\n\t\tfor (let i = 0; i < castToFloatExpressions.length; i++) {\n\t\t\tconst regexVariableMatch = new RegExp(`${regexString}\\\\s+(\\\\S[^;]*);`);\n\t\t\tconst variable = castToFloatExpressions[i].match(regexVariableMatch);\n\t\t\tif (variable && variable[2]) {\n\t\t\t\tshaderSource = typecastVariable(shaderSource, variable[2], type);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Could not find variable name in expression: \"${castToFloatExpressions[i]}\"`);\n\t\t\t}\n\t\t}\n\t}\n\treturn shaderSource;\n}\n\n/**\n * Convert int varyings to float types.\n * Only exported for testing.\n * @private\n */\nexport function castVaryingToFloat(shaderSource: string) {\n\t// Need to init all expressions with the same number of capturing groups\n\t// so that this will work in _castVaryingToFloat.\n\tshaderSource = _castVaryingToFloat(shaderSource, '\\\\bvarying\\\\s+(u)?int', 'float');\n\tshaderSource = _castVaryingToFloat(shaderSource, '\\\\bvarying\\\\s+(i|u)vec2', 'vec2');\n\tshaderSource = _castVaryingToFloat(shaderSource, '\\\\bvarying\\\\s+(i|u)vec3', 'vec3');\n\tshaderSource = _castVaryingToFloat(shaderSource, '\\\\bvarying\\\\s+(i|u)vec4', 'vec4');\n\treturn shaderSource;\n}\n\n/**\n * Convert vertex shader \"out\" to \"varying\".\n * Also remove \"flat\" if necessary.\n * Also cast as float if necessary.\n * @private\n */\nexport function glsl1VertexOut(shaderSource: string) {\n\tshaderSource = shaderSource.replace(/(\\bflat\\s+)?\\bout\\b/g, 'varying');\n\tshaderSource = castVaryingToFloat(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Convert fragment shader \"in\" to \"varying\".\n * Also remove \"flat\" if necessary.\n * Also cast as float if necessary.\n * @private\n */\nexport function glsl1FragmentIn(shaderSource: string) {\n\tshaderSource = shaderSource.replace(/(\\bflat\\s+)?\\bin\\b/g, 'varying');\n\tshaderSource = castVaryingToFloat(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Get variable name, type, and layout number for out variables.\n * Only exported for testing.\n * @private\n */\nexport function getFragmentOuts(shaderSource: string, programName: string) {\n\tconst outs: { [key: string]: {\n\t\tlocation: number,\n\t\ttype: GLSLType,\n\t}} = {};\n\tlet maxLocation = 0;\n\twhile (true) {\n\t\t// Do this without lookbehind to support older browsers.\n\t\tconst match = shaderSource.match(/\\b(layout\\s*\\(\\s*location\\s*=\\s*([0-9]+)\\s*\\)\\s*)?out\\s+((lowp|mediump|highp)\\s+)?((float|int|uint|([iu]?vec[234]))\\s+)?([_$a-zA-Z0-9]+)\\s*;/);\n\t\tif (!match) {\n\t\t\tif (Object.keys(outs).length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\t// Sort by location.\n\t\t\tconst variableNames = Object.keys(outs);\n\t\t\tconst numVariables = variableNames.length;\n\t\t\tconst outsSorted: {\n\t\t\t\tname: string,\n\t\t\t\ttype: GLSLType,\n\t\t\t}[] = new Array(maxLocation).fill(undefined);\n\t\t\t\n\t\t\tfor (let i = 0; i < numVariables; i++) {\n\t\t\t\tconst name = variableNames[i];\n\t\t\t\tconst { location, type } = outs[name];\n\t\t\t\tif (outsSorted[location] !== undefined) {\n\t\t\t\t\tthrow new Error(`Must be exactly one out declaration per layout location in GPUProgram \"${programName}\", conflicting declarations found at location ${location}.`);\n\t\t\t\t}\n\t\t\t\toutsSorted[location] =  { name, type };\n\t\t\t}\n\t\t\tif (variableNames.length !== maxLocation + 1) {\n\t\t\t\tthrow new Error(`Must be exactly one out declaration per layout location in GPUProgram \"${programName}\", layout locations must be sequential (no missing location numbers) starting from 0.`);\n\t\t\t}\n\t\t\tfor (let i = 0; i <= maxLocation; i++) {\n\t\t\t\tif (outsSorted[i] === undefined) {\n\t\t\t\t\tthrow new Error(`Missing out declaration at location ${i} in GPUProgram \"${programName}\", layout locations must be sequential (no missing location numbers) starting from 0.`);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn outsSorted;\n\t\t}\n\t\t// Save out parameters.\n\t\tconst name = match[8];\n\t\tconst location = parseInt(match[2] || '0');\n\t\tconst type = match[6] as GLSLType;\n\t\tif (!type) {\n\t\t\tthrow new Error(`No type found for out declaration \"${match[0]}\" for GPUProgram \"${programName}\".`);\n\t\t}\n\t\tif (!name) {\n\t\t\tthrow new Error(`No variable name found for out declaration \"${match[0]}\" for GPUProgram \"${programName}\".`);\n\t\t}\n\t\tif (outs[name]) {\n\t\t\tif (outs[name].location !== location) {\n\t\t\t\tthrow new Error(`All out declarations for variable \"${name}\" must have same location in GPUProgram \"${programName}\".`);\n\t\t\t}\n\t\t} else {\n\t\t\tif (location > maxLocation) maxLocation = location;\n\t\t\touts[name] = {\n\t\t\t\tlocation,\n\t\t\t\ttype,\n\t\t\t};\n\t\t}\n\t\t// Remove out definition so we can match to the next one.\n\t\tshaderSource = shaderSource.replace(match[0], '');\n\t}\n}\n\n/**\n * Convert out variables to gl_FragColor.\n * @private\n */\nexport function glsl1FragmentOut(shaderSource: string, programName: string) {\n\tconst outs = getFragmentOuts(shaderSource, programName);\n\tif (outs.length === 0) {\n\t\treturn [shaderSource];\n\t}\n\t// Remove layout declarations.\n\tshaderSource = shaderSource.replace(/\\blayout\\s*\\(\\s*location\\s*=\\s*([0-9]+)\\s*\\)\\s*/g, '');\n\t// If we detect multiple out declarations, we need to split the shader source.\n\n\tconst shaderSources: string[] = [];\n\tfor (let i = 0, numOuts = outs.length; i < numOuts; i++) {\n\t\tconst { type, name } = outs[i];\n\n\t\t// Remove out declaration for this variable.\n\t\tconst outRegex = new RegExp(`\\\\bout\\\\s+((lowp|mediump|highp)\\\\s+)?(float|int|uint|([iu]?vec[234]))\\\\s+${name}\\\\s*;`, 'g');\n\t\tlet outShaderSource = shaderSource.replace(outRegex, '');\n\t\t// Remove any other out declarations.\n\t\toutShaderSource = outShaderSource.replace(/\\bout\\b/g, '');\n\n\t\tlet assignmentFound = false;\n\t\t// Replace each instance of \"name =\" with gl_FragColor = and cast to vec4.\n\t\t// Do this without lookbehind to support older browsers.\n\t\t// const output = outShaderSource.match(/(?<=\\b${name}\\s*=\\s*)\\S.*(?=;)/s); // /s makes this work for multiline.\n\t\t// ? puts this in lazy mode (match shortest strings).\n\t\tconst regex = new RegExp(`\\\\b${name}\\\\s*=\\\\s*(\\\\S.*?);`, 's'); // 's' makes this work for multiline.\n\t\twhile (true) {\n\t\t\tconst output = outShaderSource.match(regex);\n\t\t\tif (output && output[1]) {\n\t\t\t\tassignmentFound = true;\n\t\t\t\tlet filler = '';\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'float':\n\t\t\t\t\tcase 'int':\n\t\t\t\t\tcase 'uint':\n\t\t\t\t\t\tfiller = ', 0, 0, 0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vec2':\n\t\t\t\t\tcase 'ivec2':\n\t\t\t\t\tcase 'uvec2':\n\t\t\t\t\t\tfiller = ', 0, 0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vec3':\n\t\t\t\t\tcase 'ivec3':\n\t\t\t\t\tcase 'uvec3':\n\t\t\t\t\t\tfiller = ', 0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toutShaderSource = outShaderSource.replace(regex, `gl_FragColor = vec4(${output[1]}${filler});`);\n\t\t\t} else {\n\t\t\t\tif (!assignmentFound) throw new Error(`No assignment found for out declaration in GPUProgram \"${programName}\".`);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tshaderSources.push(outShaderSource);\n\t}\n\treturn shaderSources;\n}\n\n/**\n * Contains gl_FragColor.\n * @private\n */\n function containsGLFragColor(shaderSource: string) {\n\treturn !!shaderSource.match(/\\bgl_FragColor\\b/);\n}\n\n/**\n * Check for presence of gl_FragColor in fragment shader source.\n * @private \n */\n export function checkFragmentShaderForFragColor(shaderSource: string, glslVersion: GLSLVersion, name: string) {\n\tconst gl_FragColor = containsGLFragColor(shaderSource);\n\tif (glslVersion === GLSL3) {\n\t\t// Check that fragment shader source DOES NOT contain gl_FragColor\n\t\tif (gl_FragColor) {\n\t\t\tthrow new Error(`Found \"gl_FragColor\" declaration in fragment shader for GPUProgram \"${name}\": either init GPUComposer with glslVersion = GLSL1 or use GLSL3 syntax in your fragment shader.`);\n\t\t}\n\t}\n}\n\n/**\n * Convert texture to texture2D.\n * @private\n */\nexport function glsl1Texture(shaderSource: string) {\n\treturn shaderSource.replace(/\\btexture\\(/g, 'texture2D(');\n}\n\n/**\n * Convert isampler2D and usampler2D to sampler2D.\n * @private\n */\nexport function glsl1Sampler2D(shaderSource: string) {\n\treturn shaderSource.replace(/\\b(i|u)sampler2D\\b/g, 'sampler2D');\n}\n\n/**\n * Unsigned int types are not supported, use int types instead.\n * @private\n */\nexport function glsl1Uint(shaderSource: string) {\n\tshaderSource = shaderSource.replace(/\\buint\\b/g, 'int');\n\tshaderSource = shaderSource.replace(/\\buvec2\\b/g, 'ivec2');\n\tshaderSource = shaderSource.replace(/\\buvec3\\b/g, 'ivec3');\n\tshaderSource = shaderSource.replace(/\\buvec4\\b/g, 'ivec4');\n\tshaderSource = shaderSource.replace(/\\buint\\(/g, 'int(');\n\tshaderSource = shaderSource.replace(/\\buvec2\\(/g, 'ivec2(');\n\tshaderSource = shaderSource.replace(/\\buvec3\\(/g, 'ivec3(');\n\tshaderSource = shaderSource.replace(/\\buvec4\\(/g, 'ivec4(');\n\treturn shaderSource;\n}\n\n/**\n * Replace all highp with mediump.\n * @private\n */\nexport function highpToMediump(shaderSource: string) {\n\treturn shaderSource.replace(/\\bhighp\\b/, 'mediump');\n}\n\n/**\n * Strip out any version numbers.\n * https://github.com/Jam3/glsl-version-regex\n * @private\n */\nexport function stripVersion(shaderSource: string) {\n\tconst origLength = shaderSource.length;\n\tshaderSource = shaderSource.replace(/^\\s*\\#version\\s+([0-9]+(\\s+(es)+)?)\\s*/, '');\n\tif (shaderSource.length !== origLength) {\n\t\tconsole.warn('GPUIO expects shader source that does not contain #version declarations, removing....');\n\t}\n\treturn shaderSource;\n}\n\n/**\n * Strip out any precision declarations.\n * @private\n */\nexport function stripPrecision(shaderSource: string) {\n\tconst origLength = shaderSource.length;\n\tshaderSource = shaderSource.replace(/\\s*precision\\s+((highp)|(mediump)|(lowp))\\s+[a-zA-Z0-9]+\\s*;/g, '');\n\tif (shaderSource.length !== origLength) {\n\t\tconsole.warn('GPUIO expects shader source that does not contain precision declarations, removing....');\n\t}\n\treturn shaderSource;\n}\n\n/**\n * Strip out comments from shader code.\n * @private\n */\nexport function stripComments(shaderSource: string) {\n\tshaderSource = shaderSource.replace(/[\\t ]*\\/\\/.*\\n/g, ''); // Remove single-line comments.\n\t// ? puts this in lazy mode (match shortest strings).\n\tshaderSource = shaderSource.replace(/\\/\\*.*?\\*\\//gs, ''); /* Remove multi-line comments */\n\treturn shaderSource;\n}\n\n/**\n * Get the number of sampler2D's in a fragment shader program.\n * @private\n */\nexport function getSampler2DsInProgram(shaderSource: string) {\n\t// Do this without lookbehind to support older browsers.\n\t// const samplers = shaderSource.match(/(?<=\\buniform\\s+(((highp)|(mediump)|(lowp))\\s+)?(i|u)?sampler2D\\s+)\\w+(?=\\s?;)/g);\n\tconst samplersNoDuplicates: {[key: string]: boolean} = {};\n\tconst regex = '\\\\buniform\\\\s+(((highp)|(mediump)|(lowp))\\\\s+)?(i|u)?sampler2D\\\\s+(\\\\w+)\\\\s*;';\n\tconst samplers = shaderSource.match(new RegExp(regex, 'g'));\n\tif (!samplers || samplers.length === 0) return [];\n\t// We need to be a bit careful as same sampler could be declared multiple times if compile time conditionals are used.\n\t// Extract uniform name.\n\tconst uniformMatch = new RegExp(regex);\n\tsamplers.forEach(sampler => {\n\t\tconst uniform = sampler.match(uniformMatch);\n\t\tif (!uniform || !uniform[7]) {\n\t\t\tconsole.warn(`Could not find sampler2D uniform name in string \"${sampler}\".`);\n\t\t\treturn;\n\t\t}\n\t\tsamplersNoDuplicates[uniform[7]] = true;\n\t})\n\treturn Object.keys(samplersNoDuplicates);\n}","import {\n\tisArray,\n\tisBoolean,\n\tisFiniteNumber,\n\tisInteger,\n\tisNonNegativeInteger,\n\tisString,\n} from '@amandaghassaei/type-checks';\nimport {\n\tBOOL,\n\tBOOL_1D_UNIFORM,\n\tBOOL_2D_UNIFORM,\n\tBOOL_3D_UNIFORM,\n\tBOOL_4D_UNIFORM,\n\tBYTE,\n\tCompileTimeConstants,\n\tDEFAULT_ERROR_CALLBACK,\n\tErrorCallback,\n\tFLOAT,\n\tFLOAT_1D_UNIFORM,\n\tFLOAT_2D_UNIFORM,\n\tFLOAT_3D_UNIFORM,\n\tFLOAT_4D_UNIFORM,\n\tGLSL1,\n\tGLSL3,\n\tGLSLPrecision,\n\tGLSLVersion,\n\tGPUIO_FLOAT_PRECISION,\n\tGPUIO_INT_PRECISION,\n\tGPULayerState,\n\tGPULayerType,\n\tHALF_FLOAT,\n\tINT,\n\tINT_1D_UNIFORM,\n\tINT_2D_UNIFORM,\n\tINT_3D_UNIFORM,\n\tINT_4D_UNIFORM,\n\tPRECISION_HIGH_P,\n\tPRECISION_MEDIUM_P,\n\tSHORT,\n\tUINT,\n\tUINT_1D_UNIFORM,\n\tUINT_2D_UNIFORM,\n\tUINT_3D_UNIFORM,\n\tUINT_4D_UNIFORM,\n\tUniformType,\n\tUniformValue,\n\tUNSIGNED_BYTE,\n\tUNSIGNED_INT,\n\tUNSIGNED_SHORT,\n\tWEBGL1,\n\tWEBGL2,\n} from './constants';\nimport { intForPrecision } from './conversions';\nimport { PRECISION_SOURCE } from './glsl/common/precision';\nimport type { GPULayer } from './GPULayer';\nimport { fragmentShaderPolyfills, GLSL1Polyfills, texturePolyfill } from './polyfills';\nimport {\n\tcheckFragmentShaderForFragColor,\n\tglsl1FragmentIn,\n\tglsl1FragmentOut,\n\tglsl1Sampler2D,\n\tglsl1Texture,\n\tglsl1Uint,\n\tglsl1VertexIn,\n\tglsl1VertexOut,\n\thighpToMediump,\n\tstripComments,\n\tstripPrecision,\n\tstripVersion,\n} from './regex';\n\n/**\n * Memoize results of more complex WebGL tests (that require allocations/deallocations).\n * @private\n */\nconst results = {\n\tsupportsWebGL2: undefined as undefined | boolean,\n\tsupportsHighpVertex: undefined as  undefined | boolean,\n\tsupportsHighpFragment: undefined as undefined | boolean,\n\tmediumpVertexPrecision: undefined as undefined | typeof PRECISION_HIGH_P | typeof PRECISION_MEDIUM_P,\n\tmediumpFragmentPrecision: undefined as undefined | typeof PRECISION_HIGH_P | typeof PRECISION_MEDIUM_P,\n}\n\n/**\n * Test whether a GPULayer type is a float type.\n * @private\n */\nexport function isFloatType(type: GPULayerType) {\n\treturn type === FLOAT || type === HALF_FLOAT;\n}\n\n/**\n * Test whether a GPULayer type is an unsigned int type.\n * @private\n */\n export function isUnsignedIntType(type: GPULayerType) {\n\treturn type === UNSIGNED_BYTE || type === UNSIGNED_SHORT || type === UNSIGNED_INT;\n}\n\n/**\n * Test whether a GPULayer type is a signed int type.\n * @private\n */\n export function isSignedIntType(type: GPULayerType) {\n\treturn type === BYTE || type === SHORT || type === INT;\n}\n\n/**\n * Test whether a GPULayer type is a int type.\n * @private\n */\n export function isIntType(type: GPULayerType) {\n\treturn isUnsignedIntType(type) || isSignedIntType(type);\n}\n\n/**\n * Create a string to pass compile time constants into shader.\n * @private\n */\nfunction convertCompileTimeConstantsToString(compileTimeConstants: CompileTimeConstants) {\n\tlet CTCSource = '';\n\tconst keys = Object.keys(compileTimeConstants);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\t// Check that define is passed in as a string.\n\t\tif (!isString(key) || !isString(compileTimeConstants[key])) {\n\t\t\tthrow new Error(`GPUProgram compile time constants must be passed in as key value pairs that are both strings, got key value pair of type [${typeof key} : ${typeof compileTimeConstants[key]}] for key ${key}.`)\n\t\t}\n\t\tCTCSource += `#define ${key} ${compileTimeConstants[key]}\\n`;\n\t}\n\treturn CTCSource;\n}\n\n/**\n * Create header string for fragment and vertex shaders.\n * Export this for testing purposes.\n * @private\n */\nexport function makeShaderHeader(\n\tglslVersion: GLSLVersion,\n\tintPrecision: GLSLPrecision,\n\tfloatPrecision: GLSLPrecision,\n\tcompileTimeConstants?: CompileTimeConstants,\n) {\n\tconst versionSource = glslVersion === GLSL3 ? `#version ${GLSL3}\\n` : '';\n\tconst compileTimeConstantsSource = compileTimeConstants ? convertCompileTimeConstantsToString(compileTimeConstants) : '';\n\tconst precisionConstantsSource = convertCompileTimeConstantsToString({\n\t\t[GPUIO_INT_PRECISION]: `${intForPrecision(intPrecision)}`,\n\t\t[GPUIO_FLOAT_PRECISION]: `${intForPrecision(floatPrecision)}`,\n\t});\n\treturn `${versionSource}${compileTimeConstantsSource}${precisionConstantsSource}${PRECISION_SOURCE}`;\n}\n\n/**\n * Compile vertex or fragment shaders.\n * Fragment shaders may be compiled on the fly, so keep this efficient.\n * Copied from http://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html\n * @private\n */\nexport function compileShader(\n\tgl: WebGLRenderingContext | WebGL2RenderingContext,\n\tglslVersion: GLSLVersion,\n\tintPrecision: GLSLPrecision,\n\tfloatPrecision: GLSLPrecision,\n\tshaderSource: string,\n\tshaderType: number,\n\tprogramName: string,\n\terrorCallback: ErrorCallback,\n\tcompileTimeConstants?: CompileTimeConstants,\n\tcheckCompileStatus = false,\n) {\n\t// Create the shader object\n\tconst shader = gl.createShader(shaderType);\n\tif (!shader) {\n\t\terrorCallback('Unable to init gl shader.');\n\t\treturn null;\n\t}\n\n\t// Set the shader source code.\n\tconst shaderHeader = makeShaderHeader(\n\t\tglslVersion,\n\t\tintPrecision,\n\t\tfloatPrecision,\n\t\tcompileTimeConstants,\n\t);\n\tconst fullShaderSource = `${shaderHeader}${shaderSource}`;\n\tgl.shaderSource(shader, fullShaderSource);\n\n\t// Compile the shader\n\tgl.compileShader(shader);\n\n\tif (checkCompileStatus) {\n\t\t// Check if shaders compiled - do this only on the first compilation bc of:\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#dont_check_shader_compile_status_unless_linking_fails\n\t\tconst success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t\tif (!success) {\n\t\t\t// Something went wrong during compilation - print shader source (with line number) and the error.\n\t\t\tconsole.log(fullShaderSource.split('\\n').map((line, i) => `${i}\\t${line}`).join('\\n'));\n\t\t\terrorCallback(`Could not compile ${shaderType === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'} shader for program \"${programName}\": ${gl.getShaderInfoLog(shader)}.`);\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn shader;\n}\n\n/**\n * Init a WebGL program from vertex and fragment shaders.\n * GLPrograms may be inited on the fly, so keep this efficient.\n * @private\n */\nexport function initGLProgram(\n\tgl: WebGLRenderingContext | WebGL2RenderingContext,\n\tvertexShader: WebGLShader,\n\tfragmentShader: WebGLShader,\n\tname: string,\n\terrorCallback: ErrorCallback,\n) {\n\t// Create a program.\n\tconst program = gl.createProgram();\n\tif (!program) {\n\t\terrorCallback(`Unable to init GL program for GPUProgram \"${name}\", gl.createProgram() has failed.`);\n\t\treturn;\n\t}\n\t// Link the program.\n\tgl.attachShader(program, vertexShader);\n\tgl.attachShader(program, fragmentShader);\n\tgl.linkProgram(program);\n\t// Check if it linked.\n\tconst success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\tif (!success) {\n\t\t// Something went wrong with the link.\n\t\terrorCallback(`GPUProgram \"${name}\" failed to link: ${gl.getProgramInfoLog(program)}`);\n\t\treturn;\n\t}\n\treturn program;\n}\n\n/**\n * Returns whether a WebGL context is WebGL2.\n * This code is pulled from https://github.com/mrdoob/three.js/blob/master/src/renderers/webgl/WebGLCapabilities.js\n * @param gl - WebGL context to test.\n * @returns - true if WebGL2 context, else false.\n */\nexport function isWebGL2(gl: WebGLRenderingContext | WebGL2RenderingContext) {\n\t// @ts-ignore\n\treturn (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) || (typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext);\n}\n\n/**\n * Returns whether WebGL2 is supported by the current browser.\n * @returns - true if WebGL2 is supported, else false.\n*/\nexport function isWebGL2Supported() {\n\tif (results.supportsWebGL2 === undefined) {\n\t\tconst gl = document.createElement('canvas').getContext(WEBGL2);\n\t\t// GL context and canvas will be garbage collected.\n\t\tresults.supportsWebGL2 = isWebGL2(gl!); // Will return false in case of gl = null.\n\t}\n\treturn results.supportsWebGL2;\n}\n\n/**\n * Checks if the framebuffer is ready to read.\n * @private\n */\nexport function readyToRead(gl: WebGLRenderingContext | WebGL2RenderingContext) {\n\treturn gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE;\n};\n\n/**\n * Detects whether highp is supported by this browser.\n * This is supposed to be relatively easy. You call gl.getShaderPrecisionFormat, you pass in the shader type,\n * VERTEX_SHADER or FRAGMENT_SHADER and you pass in one of LOW_FLOAT, MEDIUM_FLOAT, HIGH_FLOAT, LOW_INT, MEDIUM_INT, HIGH_INT,\n * and it returns the precision info.\n * Unfortunately Safari has a bug here which means checking this way will fail on iPhone, at least as of April 2020.\n * https://webglfundamentals.org/webgl/webgl-precision-lowp-mediump-highp.html\n * @private\n */\nfunction isHighpSupported(vsSource: string, fsSource: string) {\n\tconst gl = document.createElement('canvas').getContext(WEBGL1);\n\tif (!gl) {\n\t\tthrow new Error(`Unable to init webgl context.`);\n\t}\n\ttry {\n\t\tconst vs = compileShader(\n\t\t\tgl,\n\t\t\tGLSL1,\n\t\t\tPRECISION_HIGH_P,\n\t\t\tPRECISION_HIGH_P,\n\t\t\tvsSource,\n\t\t\tgl.VERTEX_SHADER,\n\t\t\t'highpFragmentTest',\n\t\t\tDEFAULT_ERROR_CALLBACK,\n\t\t)!;\n\t\tconst fs = compileShader(\n\t\t\tgl,\n\t\t\tGLSL1,\n\t\t\tPRECISION_HIGH_P,\n\t\t\tPRECISION_HIGH_P,\n\t\t\tfsSource,\n\t\t\tgl.FRAGMENT_SHADER,\n\t\t\t'highpFragmentTest',\n\t\t\tDEFAULT_ERROR_CALLBACK,\n\t\t)!;\n\t\tconst program = initGLProgram(gl, vs, fs, 'highpFragmentTest', DEFAULT_ERROR_CALLBACK)!;\n\t\t// Deallocate everything.\n\t\tgl.deleteProgram(program);\n\t\tgl.deleteShader(vs);\n\t\tgl.deleteShader(fs);\n\t\t// GL context and canvas will be garbage collected.\n\t} catch {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/**\n * Detects whether highp precision is supported in vertex shaders in the current browser.\n * @returns - true is highp is supported in vertex shaders, else false.\n */\nexport function isHighpSupportedInVertexShader() {\n\tif (results.supportsHighpVertex === undefined) {\n\t\tconst vertexSupport = isHighpSupported(\n\t\t\t'void main() { highp float test = 0.524; gl_Position = vec4(test, test, 0, 1); }',\n\t\t\t'void main() { gl_FragColor = vec4(0); }',\n\t\t);\n\t\tresults.supportsHighpVertex = vertexSupport;\n\t}\n\treturn results.supportsHighpVertex;\n}\n\n/**\n * Detects whether highp precision is supported in fragment shaders in the current browser.\n * @returns - true is highp is supported in fragment shaders, else false.\n */\nexport function isHighpSupportedInFragmentShader() {\n\tif (results.supportsHighpFragment === undefined) {\n\t\tconst fragmentSupport = isHighpSupported(\n\t\t\t'void main() { gl_Position = vec4(0.5, 0.5, 0, 1); }',\n\t\t\t'void main() { highp float test = 1.35; gl_FragColor = vec4(test); }',\n\t\t);\n\t\tresults.supportsHighpFragment = fragmentSupport;\n\t}\n\treturn results.supportsHighpFragment;\n}\n\n/**\n * Helper function to perform a 1px math calculation in order to determine WebGL capabilities.\n * From https://webglfundamentals.org/\n * @private\n */\nfunction test1PxCalc(\n\tname: string,\n\tgl: WebGL2RenderingContext | WebGLRenderingContext,\n\tfs: WebGLShader,\n\tvs: WebGLShader,\n\taddUniforms: (program: WebGLProgram) => void,\n) {\n\tconst program = initGLProgram(gl, vs, fs, name, DEFAULT_ERROR_CALLBACK);\n\tif (!program) {\n\t\tthrow new Error(`Unable to init WebGLProgram.`);\n\t}\n\tconst positionLocation = gl.getAttribLocation(program, 'position');\n\n\t// create a buffer and setup an attribute\n\t// We wouldn't need this except for a bug in Safari.\n\t// See https://webglfundamentals.org/webgl/lessons/webgl-smallest-programs.html\n\t// and https://bugs.webkit.org/show_bug.cgi?id=197592\n\tconst buffer = gl.createBuffer();\n\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, 1, gl.STATIC_DRAW);\n\tgl.enableVertexAttribArray(positionLocation);\n\tgl.vertexAttribPointer(\n\t\tpositionLocation,\n\t\t1,                // pull 1 value per vertex shader iteration from buffer\n\t\tgl.UNSIGNED_BYTE, // type of data in buffer,\n\t\tfalse,            // don't normalize\n\t\t0,                // bytes to advance per iteration (0 = compute from size and type)\n\t\t0,                // offset into buffer\n\t);\n\n\tgl.viewport(0, 0, 1, 1);\n\tgl.useProgram(program);\n\n\taddUniforms(program);\n\t\n\tgl.drawArrays(\n\t\tgl.POINTS,\n\t\t0, // offset\n\t\t1, // number of vertices to process\n\t);\n\n\tconst pixel = new Uint8Array(4);\n\tgl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n\t// Deallocate everything.\n\tgl.deleteProgram(program);\n\tgl.deleteShader(vs);\n\tgl.deleteShader(fs);\n\tgl.deleteBuffer(buffer);\n\t// GL context and canvas will be garbage collected.\n\n\treturn pixel;\n}\n\n/**\n * Returns the actual precision of mediump inside vertex shader.\n * From https://webglfundamentals.org/webgl/lessons/webgl-precision-issues.html\n * @returns - Vertex shader mediump precision.\n */\nexport function getVertexShaderMediumpPrecision() {\n\tif (results.mediumpVertexPrecision === undefined) {\n\t\t// This entire program is only needed because of a bug in Safari.\n\t\t// Safari doesn't correctly report precision from getShaderPrecisionFormat\n\t\t// at least as of April 2020\n\t\t// see: https://bugs.webkit.org/show_bug.cgi?id=211013\n\n\t\t// Get A WebGL context\n\t\t/** @type {HTMLCanvasElement} */\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tconst gl = canvas.getContext(\"webgl\");\n\t\tif (!gl) {\n\t\t\tthrow new Error(`Unable to init webgl context.`);\n\t\t}\n\n\t\tconst vs = compileShader(gl, GLSL1, PRECISION_MEDIUM_P, PRECISION_MEDIUM_P, `\n\tattribute vec4 position;  // needed because of another bug in Safari\n\tuniform mediump vec3 v;\n\tvarying mediump vec4 v_result;\n\tvoid main() {\n\t\tgl_Position = position;\n\t\tgl_PointSize = 1.0;\n\t\tv_result = vec4(normalize(v) * 0.5 + 0.5, 1);\n\t}\n\t\t`, gl.VERTEX_SHADER, 'mediumpPrecisionVertexTest', DEFAULT_ERROR_CALLBACK);\n\t\tif (!vs) {\n\t\t\tthrow new Error(`Unable to init vertex shader.`);\n\t\t}\n\n\t\tconst fs = compileShader(gl, GLSL1, PRECISION_MEDIUM_P, PRECISION_MEDIUM_P, `\n\tvarying mediump vec4 v_result;\n\tvoid main() {\n\t\tgl_FragColor = v_result;\n\t}\n\t\t`, gl.FRAGMENT_SHADER, 'mediumpPrecisionVertexTest', DEFAULT_ERROR_CALLBACK);\n\t\tif (!fs) {\n\t\t\tthrow new Error(`Unable to init fragment shader.`);\n\t\t}\n\n\t\t// we're going to compute the normalize vector of\n\t\t// (sqrt(2^31-1), sqrt(2^31-1), sqrt(2^31-1))\n\t\t// which should be impossible on mediump\n\t\tconst value = 2 ** 31 - 1;\n\t\tconst input = Math.sqrt(value);\n\t\tconst expected = ((input / Math.sqrt(input * input * 3)) * 0.5 + 0.5) * 255 | 0;\n\n\t\tconst pixel = test1PxCalc(\n\t\t\t'mediumpPrecisionVertexTest',\n\t\t\tgl,\n\t\t\tfs,\n\t\t\tvs,\n\t\t\t(program: WebGLProgram) => {\n\t\t\t\tconst vLocation = gl.getUniformLocation(program, 'v');\n\t\t\t\tgl.uniform3f(vLocation, input, input, input);\n\t\t\t},\n\t\t);\n\n\t\tconst mediumpPrecision = Math.abs(pixel[0] - expected) > 16;\n\t\tresults.mediumpVertexPrecision = mediumpPrecision ? PRECISION_MEDIUM_P : PRECISION_HIGH_P;\n\t}\n\treturn results.mediumpVertexPrecision;\n}\n\n/**\n * Returns the actual precision of mediump inside fragment shader.\n * From https://webglfundamentals.org/webgl/lessons/webgl-precision-issues.html\n * @returns - Fragment shader supported mediump precision.\n */\nexport function getFragmentShaderMediumpPrecision() {\n\tif (results.mediumpFragmentPrecision === undefined) {\n\t\t// This entire program is only needed because of a bug in Safari.\n\t\t// Safari doesn't correctly report precision from getShaderPrecisionFormat\n\t\t// at least as of April 2020\n\t\t// see: https://bugs.webkit.org/show_bug.cgi?id=211013\n\n\t\t// Get A WebGL context\n\t\tconst canvas = document.createElement(\"canvas\");\n\t\tconst gl = canvas.getContext(\"webgl\");\n\t\tif (!gl) {\n\t\t\tthrow new Error(`Unable to init webgl context.`);\n\t\t}\n\n\t\tconst vs = compileShader(gl, GLSL1, PRECISION_MEDIUM_P, PRECISION_MEDIUM_P,`\n\tattribute vec4 position;  // needed because of another bug in Safari\n\tvoid main() {\n\t\tgl_Position = position;\n\t\tgl_PointSize = 1.0;\n\t}\n\t\t`, gl.VERTEX_SHADER, 'mediumpPrecisionFragmentTest', DEFAULT_ERROR_CALLBACK);\n\t\tif (!vs) {\n\t\t\tthrow new Error(`Unable to init vertex shader.`);\n\t\t}\n\n\t\tconst fs = compileShader(gl, GLSL1, PRECISION_MEDIUM_P, PRECISION_MEDIUM_P, `\n\tuniform mediump vec3 v;\n\tvoid main() {\n\t\tgl_FragColor = vec4(normalize(v) * 0.5 + 0.5, 1);\n\t}\n\t\t`, gl.FRAGMENT_SHADER, 'mediumpPrecisionFragmentTest', DEFAULT_ERROR_CALLBACK);\n\t\tif (!fs) {\n\t\t\tthrow new Error(`Unable to init fragment shader.`);\n\t\t}\n\n\t\t// we're going to compute the normalize vector of\n\t\t// (sqrt(2^31-1), sqrt(2^31-1), sqrt(2^31-1))\n\t\t// which should be impossible on mediump\n\t\tconst value = 2 ** 31 - 1;\n\t\tconst input = Math.sqrt(value);\n\t\tconst expected = ((input / Math.sqrt(input * input * 3)) * 0.5 + 0.5) * 255 | 0;\n\n\t\tconst pixel = test1PxCalc(\n\t\t\t'mediumpPrecisionFragmentTest',\n\t\t\tgl,\n\t\t\tfs,\n\t\t\tvs,\n\t\t\t(program: WebGLProgram) => {\n\t\t\t\tconst vLocation = gl.getUniformLocation(program, 'v');\n\t\t\t\tgl.uniform3f(vLocation, input, input, input);\n\t\t\t},\n\t\t);\n\n\t\tconst mediumpPrecision = Math.abs(pixel[0] - expected) > 16;\n\t\tresults.mediumpFragmentPrecision =  mediumpPrecision ? PRECISION_MEDIUM_P : PRECISION_HIGH_P;\n\t}\n\treturn results.mediumpFragmentPrecision;\n}\n\n/**\n * Returns whether a number is a power of 2.\n * @private\n */\nexport function isPowerOf2(value: number) {\n\t// Use bitwise operation to evaluate this.\n\treturn value > 0 && (value & (value - 1)) == 0;\n}\n\n/**\n * Returns a Float32 array with sequential values [0, 1, 2, 3...].\n * @private\n */\nexport function initSequentialFloatArray(length: number) {\n\tconst array = new Float32Array(length);\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = i;\n\t}\n\treturn array;\n}\n\n/**\n * Strip out any unnecessary elements in shader source, e.g. #version and precision declarations.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nfunction preprocessShader(shaderSource: string) {\n\t// Strip out any version numbers.\n\tshaderSource = stripVersion(shaderSource);\n\t// Strip out any precision declarations.\n\tshaderSource = stripPrecision(shaderSource);\n\t// Strip out comments.\n\tshaderSource = stripComments(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Common code for converting vertex/fragment shader source to GLSL1.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nfunction convertShaderToGLSL1(shaderSource: string) {\n\t// No isampler2D or usampler2D.\n\tshaderSource = glsl1Sampler2D(shaderSource);\n\t// Unsigned int types are not supported, use int types instead.\n\tshaderSource = glsl1Uint(shaderSource);\n\t// Convert texture to texture2D.\n\tshaderSource = glsl1Texture(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Convert vertex shader source to GLSL1.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nfunction convertVertexShaderToGLSL1(shaderSource: string) {\n\tshaderSource = convertShaderToGLSL1(shaderSource);\n\t// Convert in to attribute.\n\tshaderSource = glsl1VertexIn(shaderSource);\n\t// Convert out to varying.\n\tshaderSource = glsl1VertexOut(shaderSource);\n\treturn shaderSource;\n}\n\n/**\n * Convert fragment shader source to GLSL1.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nexport function convertFragmentShaderToGLSL1(shaderSource: string, name: string) {\n\tshaderSource = convertShaderToGLSL1(shaderSource);\n\t// Convert in to varying.\n\tshaderSource = glsl1FragmentIn(shaderSource);\n\t// Convert out to gl_FragColor.\n\treturn glsl1FragmentOut(shaderSource, name);\n}\n\n/**\n * Preprocess vertex shader for glslVersion and browser capabilities.\n * This is called once on initialization, so doesn't need to be extremely efficient.\n * @private\n */\nexport function preprocessVertexShader(shaderSource: string, glslVersion: GLSLVersion) {\n\tshaderSource = preprocessShader(shaderSource);\n\t// Check if highp supported in vertex shaders.\n\tif (!isHighpSupportedInVertexShader()) {\n\t\tconsole.warn('highp not supported in vertex shader in this browser, falling back to mediump.');\n\t\t// Replace all highp with mediump.\n\t\tshaderSource = highpToMediump(shaderSource);\n\t}\n\tif (glslVersion === GLSL3) {\n\t\treturn shaderSource;\n\t}\n\treturn convertVertexShaderToGLSL1(shaderSource);\n}\n\n\n\n/**\n * Preprocess fragment shader for glslVersion and browser capabilities.\n * This is called once on initialization of GPUProgram, so doesn't need to be extremely efficient.\n * @private\n */\nexport function preprocessFragmentShader(shaderSource: string, glslVersion: GLSLVersion, name: string) {\n\tshaderSource = preprocessShader(shaderSource);\n\tcheckFragmentShaderForFragColor(shaderSource, glslVersion, name);\n\t// Check if highp supported in fragment shaders.\n\tif (!isHighpSupportedInFragmentShader()) {\n\t\tconsole.warn('highp not supported in fragment shader in this browser, falling back to mediump.');\n\t\t// Replace all highp with mediump.\n\t\tshaderSource = highpToMediump(shaderSource);\n\t}\n\t// Add function/operator polyfills.\n\tshaderSource = fragmentShaderPolyfills() + shaderSource;\n\t// Add texture() polyfills.\n\tlet samplerUniforms: string[];\n\t({ shaderSource, samplerUniforms } = texturePolyfill(shaderSource));\n\tif (glslVersion !== GLSL3) {\n\t\tconst sources = convertFragmentShaderToGLSL1(shaderSource, name);\n\t\t// If this shader has multiple outputs, it is split into multiple sources.\n\t\tfor (let i = 0, numSources = sources.length; i < numSources; i++) {\n\t\t\t// Add glsl1 specific polyfills.\n\t\t\tsources[i] = GLSL1Polyfills() + sources[i];\n\t\t}\n\t\tshaderSource = sources.shift()!;\n\t\tif (sources.length) {\n\t\t\treturn { shaderSource, samplerUniforms, additionalSources: sources };\n\t\t}\n\t}\n\treturn { shaderSource, samplerUniforms };\n}\n\n/**\n * Check uniforms and return internal WebGL type (e.g. [1234][u]?[if])\n * @private\n */\nexport function uniformInternalTypeForValue(\n\tvalue: UniformValue,\n\ttype: UniformType,\n\tuniformName: string,\n\tprogramName: string,\n) {\n\tif (type === FLOAT) {\n\t\t// Check that we are dealing with a number.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < (value as number[]).length; i++) {\n\t\t\t\tif (!isFiniteNumber((value as number[])[i])) {\n\t\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected float or float[] of length 1-4.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isFiniteNumber(value)) {\n\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected float or float[] of length 1-4.`);\n\t\t\t}\n\t\t}\n\t\tif (!isArray(value) || (value as number[]).length === 1) {\n\t\t\treturn FLOAT_1D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 2) {\n\t\t\treturn FLOAT_2D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 3) {\n\t\t\treturn FLOAT_3D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 4) {\n\t\t\treturn FLOAT_4D_UNIFORM;\n\t\t}\n\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected float or float[] of length 1-4.`);\n\t} else if (type === INT) {\n\t\t// Check that we are dealing with an int.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < (value as number[]).length; i++) {\n\t\t\t\tif (!isInteger((value as number[])[i])) {\n\t\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected int or int[] of length 1-4.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isInteger(value)) {\n\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected int or int[] of length 1-4.`);\n\t\t\t}\n\t\t}\n\t\tif (!isArray(value) || (value as number[]).length === 1) {\n\t\t\treturn INT_1D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 2) {\n\t\t\treturn INT_2D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 3) {\n\t\t\treturn INT_3D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 4) {\n\t\t\treturn INT_4D_UNIFORM;\n\t\t}\n\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected int or int[] of length 1-4.`);\n\t} else if (type === UINT) {\n\t\t// Check that we are dealing with a uint.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < (value as number[]).length; i++) {\n\t\t\t\tif (!isNonNegativeInteger((value as number[])[i])) {\n\t\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected uint or uint[] of length 1-4.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isNonNegativeInteger(value)) {\n\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected uint or uint[] of length 1-4.`);\n\t\t\t}\n\t\t}\n\t\tif (!isArray(value) || (value as number[]).length === 1) {\n\t\t\treturn UINT_1D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 2) {\n\t\t\treturn UINT_2D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 3) {\n\t\t\treturn UINT_3D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 4) {\n\t\t\treturn UINT_4D_UNIFORM;\n\t\t}\n\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected uint or uint[] of length 1-4.`);\n\t} else if (type === BOOL) {\n\t\t// Check that we are dealing with a boolean.\n\t\tif (isArray(value)) {\n\t\t\tfor (let i = 0; i < (value as boolean[]).length; i++) {\n\t\t\t\tif (!isBoolean((value as boolean[])[i])) {\n\t\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected bool or bool[] of length 1-4.`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!isBoolean(value)) {\n\t\t\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected bool or bool[] of length 1-4.`);\n\t\t\t}\n\t\t}\n\t\tif (!isArray(value) || (value as number[]).length === 1) {\n\t\t\treturn BOOL_1D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 2) {\n\t\t\treturn BOOL_2D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 3) {\n\t\t\treturn BOOL_3D_UNIFORM;\n\t\t}\n\t\tif ((value as number[]).length === 4) {\n\t\t\treturn BOOL_4D_UNIFORM;\n\t\t}\n\t\tthrow new Error(`Invalid value ${JSON.stringify(value)} for uniform \"${uniformName}\" in program \"${programName}\", expected boolean.`);\n\t} else {\n\t\tthrow new Error(`Invalid type \"${type}\" for uniform \"${uniformName}\" in program \"${programName}\", expected ${FLOAT} or ${INT} or ${BOOL}.`);\n\t}\n}\n\n/**\n * Get index of GPULayer in array of inputs.\n * Used by GPUComposer.\n * @private\n */\nexport function indexOfLayerInArray(layer: GPULayer, array: (GPULayer | GPULayerState)[]) {\n\treturn array.findIndex(item => item === layer || (item as GPULayerState).layer === layer);\n}\n\nfunction clientWaitAsync(\n\tgl: WebGL2RenderingContext,\n\tsync: WebGLSync,\n\tflags: number,\n\tinterval_ms: number,\n) {\n\treturn new Promise<void>((resolve, reject) => {\n\t  function test() {\n\t\tconst res = gl.clientWaitSync(sync, flags, 0);\n\t\tif (res === gl.WAIT_FAILED) {\n\t\t  reject();\n\t\t  return;\n\t\t}\n\t\tif (res === gl.TIMEOUT_EXPIRED) {\n\t\t  setTimeout(test, interval_ms);\n\t\t  return;\n\t\t}\n\t\tresolve();\n\t  }\n\t  test();\n\t});\n  }\n  \n async function getBufferSubDataAsync(\n\tgl: WebGL2RenderingContext,\n\ttarget: number,\n\tbuffer: WebGLBuffer,\n\tsrcByteOffset: number,\n\tdstBuffer: ArrayBufferView,\n) {\n\tconst sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0)!;\n\tgl.flush();\n  \n\tawait clientWaitAsync(gl, sync, 0, 10);\n\tgl.deleteSync(sync);\n  \n\tgl.bindBuffer(target, buffer);\n\tgl.getBufferSubData(target, srcByteOffset, dstBuffer);\n\tgl.bindBuffer(target, null);\n}\n\n/**\n * Non-blocking version of gl.readPixels for WebGL2 only.\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#use_non-blocking_async_data_readback\n * @param gl - WebGL2 Rendering Context\n * @param x - The first horizontal pixel that is read from the lower left corner of a rectangular block of pixels.\n * @param y - The first vertical pixel that is read from the lower left corner of a rectangular block of pixels.\n * @param w - The width of the rectangle.\n * @param h - The height of the rectangle.\n * @param format - The GLenum format of the pixel data.\n * @param type - The GLenum data type of the pixel data.\n * @param dstBuffer - An object to read data into. The array type must match the type of the type parameter.\n * @returns \n */\nexport async function readPixelsAsync(\n\tgl: WebGL2RenderingContext,\n\tx: number, y: number,\n\tw: number, h: number,\n\tformat: number,\n\ttype: number,\n\tdstBuffer: ArrayBufferView,\n) {\n\tconst buf = gl.createBuffer()!;\n\tgl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n\tgl.bufferData(gl.PIXEL_PACK_BUFFER, dstBuffer.byteLength, gl.STREAM_READ);\n\tgl.readPixels(x, y, w, h, format, type, 0);\n\tgl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n  \n\tawait getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dstBuffer);\n  \n\tgl.deleteBuffer(buf);\n\treturn dstBuffer;\n  }","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["root","factory","exports","module","define","amd","self","isNumber","value","Number","isNaN","isFiniteNumber","isFinite","isInteger","isPositiveInteger","isNonNegativeInteger","isString","isTypedArray","ArrayBuffer","isView","DataView","isArray","Array","isObject","isBoolean","Object","defineProperty","buffer","floatView","Float32Array","uint32View","Uint32Array","baseTable","shiftTable","i","e","roundToFloat16Bits","num","f","mantissaTable","exponentTable","offsetTable","m","convertToNumber","float16bits","hfround","global","freeSelf","Function","objectProto","prototype","hasOwnProperty","nativeObjectToString","toString","symToStringTag","undefined","isOwn","call","tag","unmasked","result","type","uid","maskSrcKey","exec","func","funcToString","reIsHostCtor","reIsNative","RegExp","replace","test","object","key","this","__data__","size","has","data","Hash","entries","index","length","clear","entry","set","get","other","array","splice","pop","push","ListCache","map","MapCache","memoize","resolver","TypeError","memoized","args","arguments","apply","cache","Cache","isTypedArrayIndexedPropertyWritable","getOwnPropertyDescriptor","Uint8Array","writable","ToInteger","target","number","Math","trunc","defaultCompareFunction","x","y","isNaN_x","isNaN_y","isPlusZero_x","isPlusZero_y","is","isDataView","view","isStringNumberKey","freeExports","nodeType","freeModule","freeProcess","nodeUtil","types","require","binding","nodeIsArrayBuffer","_","wm","WeakMap","obj","create","createPrivateStorage","isFloat16Array","Float16Array","assertFloat16Array","copyToArray","applyHandler","thisArg","defaultFloat16ArrayMethods","Reflect","handler","wrapper","ret","proxy","Proxy","isFrozen","getPrototypeOf","setPrototypeOf","descriptor","deleteProperty","isExtensible","preventExtensions","ownKeys","Uint16Array","constructor","input","byteOffset","super","arrayLike","Symbol","iterator","static","src","opts","from","mapFunc","val","keys","values","callback","l","filter","reduce","start","reduceRight","forEach","find","findIndex","every","some","offset","reverse","fill","copyWithin","sort","compareFunction","_convertToNumber","slice","subarray","indexOf","element","lastIndexOf","includes","join","toLocaleString","toStringTag","Float16Array$prototype","WeakSet","add","getFloat16","dataView","getUint16","setFloat16","setUint16","calcCrc","buf","c","pngDataTable","crcTable","Int32Array","n","k","createPngDataTable","changeDpiBlob","blob","dpi","headerChunk","Promise","resolve","reject","fileReader","FileReader","onload","dataArray","tail","changedArray","changeDpiOnArray","Blob","readAsArrayBuffer","changeDpiDataUrl","base64Image","dataSplitted","split","format","body","headerLength","overwritepHYs","PNG","b64Index","b64index","b64PhysSignature1","b64PhysSignature2","b64PhysSignature3","detectPhysChunkFromDataUrl","ceil","JPEG","stringHeader","substring","restOfData","headerBytes","atob","charCodeAt","finalArray","base64Header","btoa","String","fromCharCode","arr","arr2","_toConsumableArray","_P","_H","_Y","_S","physChunk","crc","crcChunk","startingIndex","searchStartOfPhys","chunkLength","finalHeader","b","a","autoBom","console","warn","d","XMLHttpRequest","open","responseType","g","response","onerror","error","send","status","dispatchEvent","MouseEvent","document","createEvent","initMouseEvent","window","navigator","userAgent","saveAs","HTMLAnchorElement","h","URL","webkitURL","j","createElement","name","download","rel","href","origin","location","createObjectURL","setTimeout","revokeObjectURL","msSaveOrOpenBlob","title","innerText","HTMLElement","safari","onloadend","readAsDataURL","params","_errorState","_circlePositionsBuffer","_vertexAttributeLocations","_extensions","_copyPrograms","_setValuePrograms","_vertexShaders","DEFAULT_PROGRAM_NAME","DEFAULT_VERT_SHADER_SOURCE","compiledShaders","SEGMENT_PROGRAM_NAME","SEGMENT_VERTEX_SHADER_SOURCE","LAYER_POINTS_PROGRAM_NAME","LAYER_POINTS_VERTEX_SHADER_SOURCE","LAYER_VECTOR_FIELD_PROGRAM_NAME","LAYER_VECTOR_FIELD_VERTEX_SHADER_SOURCE","LAYER_LINES_PROGRAM_NAME","LAYER_LINES_VERTEX_SHADER_SOURCE","verboseLogging","_numTicks","checkValidKeys","checkRequiredKeys","_errorCallback","message","errorCallback","DEFAULT_ERROR_CALLBACK","canvas","gl","context","_gl","contextID","getContext","contextAttributes","WEBGL2","WEBGL1","EXPERIMENTAL_WEBGL2","EXPERIMENTAL_WEBGL","isWebGL2","log","glslVersion","GLSL3","GLSL1","intPrecision","PRECISION_HIGH_P","floatPrecision","disable","DEPTH_TEST","pixelStorei","UNPACK_ALIGNMENT","bindBuffer","ARRAY_BUFFER","resize","clientWidth","clientHeight","getParameter","MAX_TEXTURE_IMAGE_UNITS","initWithThreeRenderer","renderer","composer","GPUComposer","capabilities","precision","domElement","_setValueProgramForType","uniformTypeForType","setValueProgram","_copyProgramForType","copyProgram","_initVertexBuffer","createBuffer","bufferData","STATIC_DRAW","_getQuadPositionsBuffer","_quadPositionsBuffer","fsQuadPositions","_getBoundaryPositionsBuffer","_boundaryPositionsBuffer","boundaryPositions","_getCirclePositionsBuffer","numSegments","unitCirclePoints","cos","PI","sin","circlePositions","_cloneGPULayer","gpuLayer","dimensions","is1D","width","height","clone","GPULayer","numComponents","wrapX","wrapY","numBuffers","clearValue","incrementBufferIndex","step","program","getStateAtIndex","output","bufferIndex","_getVertexShader","vertexID","vertexCompileConstants","programName","Error","preprocessedSrc","preprocessVertexShader","shader","compileShader","VERTEX_SHADER","_width","_height","_drawSetup","gpuProgram","fullscreenRender","inputTextures","layer","currentState","_getProgramWithName","_setOutputLayer","useProgram","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texture","_setInternalFragmentUniforms","_setBlendMode","blendAlpha","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","_addLayerToInputs","indexOfLayerInArray","_passThroughLayerDataFromInputToOutput","state","_internalType","outputArray","numOutputs","outputLayer","_prepareForWrite","_usingTextureOverrideForCurrentBuffer","layer0","additionalTextures","drawBuffers","COLOR_ATTACHMENT0","_currentTexture","bindFrameBuffer","_widthHeightForOutput","viewport","bindFramebuffer","FRAMEBUFFER","_setVertexAttribute","locations","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","_setPositionAttribute","_setIndexAttribute","_setUVAttribute","firstOutput","nextOutput","_iterateOverOutputsIfNeeded","methodName","_childPrograms","glProgram","_setVertexUniform","drawArrays","TRIANGLE_STRIP","stepBoundary","onePx","edges","numEdges","edge","BOUNDARY_LEFT","LINES","BOUNDARY_RIGHT","BOUNDARY_TOP","BOUNDARY_BOTTOM","LINE_LOOP","stepNonBoundary","stepCircle","position","diameter","useOutputScale","DEFAULT_CIRCLE_NUM_SEGMENTS","TRIANGLE_FAN","stepSegment","position1","position2","thickness","diffX","diffY","angle","atan2","centerX","centerY","sqrt","numCapSegments","endCaps","stepRect","drawLayerAsPoints","_pointIndexArray","MAX_FLOAT_INT","count","color","JSON","stringify","setUniform","vertexShaderOptions","GPUIO_VS_POSITION_W_ACCUM","GPUIO_VS_WRAP_X","GPUIO_VS_WRAP_Y","INT","pointSize","positionLayerDimensions","_pointIndexBuffer","indices","initSequentialFloatArray","POINTS","drawLayerAsVectorField","_vectorFieldIndexArray","vectorScale","vectorSpacing","spacedDimensions","floor","_vectorFieldIndexBuffer","resetThreeState","_renderer","getViewport","ThreejsUtils","Vector4","setRenderTarget","resetState","savePNG","filename","toBlob","then","tick","_lastTickTime","_lastTickFPS","currentTime","performance","now","fps","numTicks","currentFPS","parseFloat","toFixed","dispose","deleteBuffer","_indexedLinesIndexBuffer","deleteShader","_wrappedLineColorProgram","_clearValue","_bufferIndex","_buffers","_composer","calcGPULayerSize","_length","defaultFilter","HALF_FLOAT","NEAREST","LINEAR","isValidFilter","validFilters","CLAMP_TO_EDGE","isValidWrap","validWraps","isValidDataType","validDataTypes","internalType","getGPULayerInternalType","getGLTextureParameters","glFormat","glInternalFormat","glType","glNumChannels","_glInternalFormat","_glFormat","_glType","_glNumChannels","internalFilter","getGPULayerInternalFilter","_internalFilter","_glFilter","_internalWrapX","getGPULayerInternalWrap","wrap","_glWrapS","_internalWrapY","_glWrapT","_initBuffers","initFromImageURL","url","isValidImageType","validImageTypes","isValidImageFormat","validImageFormats","image","Image","_textureOverrides","arrayOrImage","validatedArrayOrImage","validateGPULayerArray","HTMLImageElement","createTexture","getError","texParameteri","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","decrementBufferIndex","abs","setFromArray","validatedArray","_destroyBuffers","isValidClearValue","applyToAllBuffers","endIndex","_getValuesSetup","_valuesRaw","RGBA","UNSIGNED_BYTE","UNSIGNED_SHORT","RGBA_INTEGER","UNSIGNED_INT","BYTE","SHORT","readyToRead","checkFramebufferStatus","_getValuesPost","OUTPUT_LENGTH","handleFloat16Conversion","_valuesBufferView","arrayConstructorForType","_values","initArrayForType","index1","index2","getValues","readPixels","getValuesAsync","readPixelsAsync","multiplier","imageData","getImageData","indexFlipped","putImageData","attachToThreeTexture","offsetTextureProperties","properties","__webglTexture","__webglInit","deleteTexture","disposeFramebuffers","results","writeSupport","filterWrapSupport","shouldCastIntTypeAsFloat","testWriteSupport","framebuffer","createFramebuffer","framebufferTexture2D","validStatus","FRAMEBUFFER_COMPLETE","deleteFramebuffer","testFilterWrap","glWrap","glFilter","valuesTyped","valuesTyped16","float16View","fragmentShaderSource","convertFragmentShaderToGLSL1","fragmentShader","FRAGMENT_SHADER","isUnsignedIntType","isIntType","wrapValue","max","min","vertexShader","initGLProgram","uniform2fv","getUniformLocation","filtered","supported","tol","expected","_x","deleteProgram","minMaxValuesForType","Infinity","MIN_UNSIGNED_BYTE","MAX_UNSIGNED_BYTE","MIN_BYTE","MAX_BYTE","MIN_UNSIGNED_SHORT","MAX_UNSIGNED_SHORT","MIN_SHORT","MAX_SHORT","MIN_UNSIGNED_INT","MAX_UNSIGNED_INT","MIN_INT","MAX_INT","halfFloatsAsFloats","getExtension","OES_TEXTURE_HAlF_FLOAT_LINEAR","OES_TEXTURE_FLOAT_LINEAR","RED","RG","RED_INTEGER","RG_INTEGER","R16F","RG16F","RGBA16F","R32F","RG32F","RGBA32F","R8UI","RG8UI","RGBA8UI","R8I","RG8I","RGBA8I","R16I","RG16I","RGBA16I","R16UI","RG16UI","RGBA16UI","R32I","RG32I","RGBA32I","R32UI","RG32UI","RGBA32UI","OES_TEXTURE_HALF_FLOAT","HALF_FLOAT_OES","missingParams","EXT_COLOR_BUFFER_FLOAT","EXT_COLOR_BUFFER_HALF_FLOAT","OES_TEXTURE_FLOAT","shouldTypeCast","Int8Array","Int16Array","validArrayTypes","arrayLength","shouldResize","_len","origValue","clipped","_fragmentShaders","_compileTimeConstants","_uniforms","_programs","_programsKeyLookup","_samplerUniformsIndices","uniforms","compileTimeConstants","preprocessFragmentShader","shaderSource","samplerUniforms","additionalSources","_fragmentShaderSource","inputIndex","shaderIndex","GPUProgram","numChildren","GPUProgramChild","recompile","needsRecompile","programKeys","numPrograms","delete","fragmentShaderKeys","numFragmentShaders","numUniforms","_getFragmentShader","fragmentId","internalCompileTimeConstants","fragmentID","fragmentCompileConstants","wrapXVal","REPEAT","wrapYVal","filterVal","SAMPLER2D_WRAP_X","SAMPLER2D_WRAP_Y","SAMPLER2D_FILTER","SAMPLER2D_CAST_INT","uniformNames","uniformName","uniform","_setProgramUniform","isGLSL3","_location","getUniform","badType","BOOL_1D_UNIFORM","BOOL_2D_UNIFORM","BOOL_3D_UNIFORM","BOOL_4D_UNIFORM","FLOAT_1D_UNIFORM","FLOAT_2D_UNIFORM","FLOAT_3D_UNIFORM","FLOAT_4D_UNIFORM","INT_1D_UNIFORM","INT_2D_UNIFORM","INT_3D_UNIFORM","INT_4D_UNIFORM","UINT_1D_UNIFORM","UINT_2D_UNIFORM","UINT_3D_UNIFORM","UINT_4D_UNIFORM","uniform1i","uniform2i","uniform3i","uniform4i","uniform1f","uniform3fv","uniform4fv","uniform2iv","uniform3iv","uniform4iv","uniform1ui","uniform2uiv","uniform3uiv","uniform4uiv","currentType","uniformInternalTypeForValue","isChanged","samplerUniform","numKeys","indexLookup","filterMismatch","halfPxSize","halfPxUniform","SAMPLER2D_HALF_PX_UNIFORM","dimensionsUniform","SAMPLER2D_DIMENSIONS_UNIFORM","_gpuio_child_params","valueLength","valueType","glslTypeForType","outputType","glslType","glslPrefixForType","numInputs","components","arrayOfLengthNumInputs","el","componentSelection","glslComponentSelectionForNumComponents","opacity","glslFloatType","glslPrefix","shouldCast","scale","colorZero","castFloat","component","colorNegative","colorPositive","z","w","copy","v","isNumberOfType","validKeys","requiredKeys","BOOL","UINT","RGB","PRECISION_LOW_P","PRECISION_MEDIUM_P","GPUIO_VS_INDEXED_POSITIONS","GPUIO_VS_UV_ATTRIBUTE","GPUIO_VS_NORMAL_ATTRIBUTE","MIN_HALF_FLOAT_INT","MAX_HALF_FLOAT_INT","MIN_FLOAT_INT","GPUIO_INT_PRECISION","GPUIO_FLOAT_PRECISION","WEBGL_DEPTH_TEXTURE","extensionName","optional","extension","framebufferMap","allTextureFramebuffersMap","texture0","numTextures","initFrameBuffer","allFramebuffers","numFramebuffers","PRECISION_SOURCE","intForPrecision","VERTEX_SHADER_HELPERS_SOURCE","_testing","isFloatType","utils","isSignedIntType","makeShaderHeader","isPowerOf2","extensions","regex","checks","GPULayerHelpers","polyfills","conversions","isWebGL2Supported","isHighpSupportedInVertexShader","isHighpSupportedInFragmentShader","getVertexShaderMediumpPrecision","getFragmentShaderMediumpPrecision","Programs","addLayersProgram","addValueProgram","multiplyValueProgram","renderAmplitudeProgram","renderSignedAmplitudeProgram","setColorProgram","GLSL1_POLYFILLS","FRAGMENT_SHADER_POLYFILLS","floatTypeForIntType","textureCalls","match","getSampler2DsInProgram","remainingTextureCalls","polyfillUniforms","make_GPUIO_TEXTURE_POLYFILL","prefix","castOpening","castEnding","make_GPUIO_TEXTURE_WRAP","lookupFunction","wrapType","extraParams","sign","round","roundEven","type1","type2","clamp","mix","floatTypeForBoolType","det2","det3","E","modi","stepi","bitshiftLeft","bitshiftRight","bitwiseOr","numBits","bitwiseXOR","bitwiseAnd","bitwiseNot","suffix","escapeRegExp","string","typecastVariable","variableName","regexMatch","assignmentExpressions","regexValueMatch","regexReplace","_castVaryingToFloat","regexString","castToFloatExpressions","regexVariableMatch","variable","castVaryingToFloat","getFragmentOuts","outs","maxLocation","variableNames","numVariables","outsSorted","parseInt","shaderSources","numOuts","outRegex","outShaderSource","assignmentFound","filler","gl_FragColor","containsGLFragColor","origLength","samplersNoDuplicates","samplers","uniformMatch","sampler","supportsWebGL2","supportsHighpVertex","supportsHighpFragment","mediumpVertexPrecision","mediumpFragmentPrecision","convertCompileTimeConstantsToString","CTCSource","versionSource","compileTimeConstantsSource","precisionConstantsSource","shaderType","checkCompileStatus","createShader","shaderHeader","fullShaderSource","getShaderParameter","COMPILE_STATUS","line","getShaderInfoLog","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","WebGL2RenderingContext","WebGL2ComputeRenderingContext","isHighpSupported","vsSource","fsSource","vs","fs","vertexSupport","fragmentSupport","test1PxCalc","addUniforms","positionLocation","pixel","preprocessShader","stripVersion","stripPrecision","stripComments","convertShaderToGLSL1","glsl1Sampler2D","glsl1Uint","glsl1Texture","glsl1FragmentIn","glsl1FragmentOut","clientWaitAsync","sync","flags","interval_ms","res","clientWaitSync","WAIT_FAILED","TIMEOUT_EXPIRED","getBufferSubDataAsync","srcByteOffset","dstBuffer","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","deleteSync","getBufferSubData","vLocation","uniform3f","mediumpPrecision","highpToMediump","glsl1VertexIn","glsl1VertexOut","convertVertexShaderToGLSL1","checkFragmentShaderForFragColor","fragmentShaderPolyfills","texturePolyfill","sources","numSources","GLSL1Polyfills","shift","item","PIXEL_PACK_BUFFER","byteLength","STREAM_READ","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","definition","o","enumerable","globalThis","prop","r"],"sourceRoot":""}